---
title: "Overall_analysis_GLMM"
author: "Alma Steireif"
date: "`r Sys.Date()`"
output: 
  html_document:
      toc: TRUE
---

## 0.0. Description



## Hypotheses

*Q1: Do reference and restored sites exhibit differences in pollinator biodiversity?*

  **H0:**
  • no significant difference between reference and restored sites in pollinator biodiversity
  → pollinators are highly mobile and can easily colonize restored habitats, thereby achieving similar biodiversity and composition to reference sites.
  
  **H1:**
  • pollinator diversity is higher in reference sites compared to young restored sites
  → habitat complexity, trophic levels, vegetation structure, and resource availability, all take time to develop in restored sites


*Q2: Do traditional and automated methods yield different compositions of pollinators?*

  **H0:**
  • no significant differences in pollinator composition detected by traditional and automated methods
  → because all methods aim to capture a representative sample of the pollinator community.
  
  **H1:**
  • Traditional and automated methods yield different compositions of pollinators
  → due to inherent biases in sampling efficiency, taxonomy resolution, and target taxa, leading to discrepancies in the detection of certain pollinators.
  
*Q3: Can automated methods effectively detect biodiversity changes between reference and restored sites?*

  **H0:**
  • Automated methods do not effectively detect biodiversity changes between reference and restored sites
  → due to limitations in capturing the full spectrum of pollinator abundance and species richness, as well as potential challenges in achieving high taxonomic resolution.
  
  **H1:**
  • Automated methods can effectively detect biodiversity differences between reference and restored sites
  → machine learning algorithms can offer improved sensitivity and accuracy in detecting shifts in pollinator communities over time.

## 0. Setup    

### libraries    

```{r setup, include=FALSE}

library(vegan)  # For diversity indices
library(paletteer)  # For color palettes
library(RColorBrewer)  # For color palettes

library(reshape2)
library(patchwork) #for wrapping plots
library(chron)  # for time data
library(lubridate)  # for date data

library(Hmisc)  # correlation matrix
library(corrplot)  # plotting
library(factoextra) #install library for fviz_pca

library(easystats)#library(parameters) #library(performance)
library(lme4)
library(ggeffects)
library(glmmTMB) #for glmmTMB models
library(arm) #for residual plots of binomial models
library(DHARMa) #for residual plots
library(datawizard) #chek documentation
library(sjPlot)
library(pscl) #for zero inflation test
#library(mgcv) #tweedie models

library(tidyverse) 
```

### aesthetics

```{r custom colors}
#define custom colors for plotting
saturated_pal <- c(
  #reference sites
  "DES" = "#7F3B19FF",  
  "HLI" = "#FDB863FF",  
  "JEP" = "#E08214FF",  
  "STP" = "#B35806FF",
  "WUP" = "#FEE0B6FF",
  # restored sites
  "BUH" = "#93C6E1FF",  
  "KOT" = "#5F93ACFF",  
  "WDG" = "#2E627AFF",  
  "WED" = "#00344AFF"  
)

# bicolor palette
bicolor_pal <- c(
  "DES" = "darkorange",  
  "HLI" = "darkorange",  
  "JEP" = "darkorange",  
  "STP" = "darkorange",
  "WUP" = "darkorange",
  "BUH" = "steelblue",  
  "KOT" = "steelblue",  
  "WDG" = "steelblue",  
  "WED" = "steelblue" 
)

bicolor_bg <- c(
  "DES" = "lightyellow",  
  "HLI" = "lightyellow",  
  "JEP" = "lightyellow",  
  "STP" = "lightyellow",
  "WUP" = "lightyellow",
  "BUH" = "lightblue1",  
  "KOT" = "lightblue1",  
  "WDG" = "lightblue1",  
  "WED" = "lightblue1" 
)

theme_new <- theme_classic(base_size = 12) +
  theme(axis.line = element_blank(),
        axis.text = element_text(colour = "black"),
        axis.ticks = element_line(linewidth = 0.4, colour = "black"),
        legend.key.size = unit(0.5, "cm"),
        legend.margin = margin(t = 0),
        legend.text = element_text(size = 8),
        legend.title = element_text(size = 9),
        panel.border = element_rect(linewidth = 0.4, colour = "black", fill = NA),
        panel.grid.major.y = element_line(colour = "grey90", linewidth = 0.2),
        plot.margin = margin(2, 2, 2, 2, "pt"),
        plot.title = element_text(size = 10))
theme_set(theme_new)
```

#### Predictor colors

Setting predictor colors allows us to make unified plots with the same colors for the same variables in the modelling steps. 
Now in order to call one of the colors, we can do as follows:  `predictor_colors["Floral_simpson_index_T"]`.

```{r}
# Select 7 colors from the a palette
predictor_colors <- paletteer::paletteer_d("MetBrewer::Nattier")[1:7]

# Assign colors to the predictor variables
predictor_colors <- setNames(predictor_colors, c(
  "dm_temperature", 
  "Floral_simpson_index_T",
  "minutes_since_9am",
  "top2_ratio",
  "Plot_Cover_T",
  "Days_since_start",
  "dm_wind_velocity"
))

# View the named color mapping
print(predictor_colors)

barplot(
  rep(1, length(predictor_colors)),
  col = predictor_colors,
  names.arg = names(predictor_colors),
  las = 2,  # rotate labels
  cex.names = 0.8,
  main = "Predictor Color Preview"
)


```
**One option: MetBrewer::Derain**

predictor_colors <- paletteer::paletteer_d("MetBrewer::Derain")[1:7]

Assign colors to the predictor variables
predictor_colors <- setNames(predictor_colors, c(
  "dm_temperature", 
  "top2_ratio",
  "Plot_Cover_T",
  "Floral_simpson_index_T",
  "minutes_since_9am",
  "Days_since_start",
  "dm_wind_velocity"
))

## 0.3. data loading   
 
```{r loading all needed csv files}
### Environmental data ------------

## landscape data from "C:\Users\Almas\Desktop\UNI_LEIPSI\Thesis\Thesis_Rproject\data\landscape_data.csv"
landscape_data <- read.csv("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/data/corine_data.csv")

## weather data from the Deutscher Wetterdienst (DWD)
dwd_weather <- read.csv("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/data/dwd_weather_data.csv")

## weather data from the field
field_weather <- read.csv("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/data/field_weather_data.csv")

## plant data
plants <- read.csv("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/data/plants3.csv")
relative_flower <- read.csv("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/data/relative_flower.csv")
top2 <- read.csv("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/data/top2.csv")

## extrapolated plant data
#inext_plants <- read.csv("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/data/iNext_AsyEst_plants.csv")

### Traditional methods ------------

## netting data 
netting <- read.csv("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/data/net_data_long.csv")

## pan trap data for families
pan_family <- read.csv("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/data/bowltrap_clean.csv")

### Cameras ------------

## flower camera data
flower_camera <- read.csv("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/data/bioclip_flower_cams.csv")

## platfrom camera data 
platform_camera <- read.csv("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/data/InsectDetect_platform_cams.csv")
platform_logs_rec <- read.csv("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/data/platform_recording_logs.csv")
```


## 1. Enivronmental variables

### 1.1. Dwd weather data

```{r dwd weather}
#change dwd_weather date format from 20240724 to 2024-07-24 by adding a "-" after the year and month
dwd_weather <- dwd_weather %>%
  #adding a "-" after the year and month
  mutate(Date = gsub("(\\d{4})(\\d{2})", "\\1-\\2", MESS_DATUM))%>%
  #adding - after the month
  mutate(Date = gsub("(\\d{4}-\\d{2})(\\d{2})", "\\1-\\2", Date))

#select the relevant columns for out analysis: Date, SITE, FM, TMK and rename them properly dm= daily mean
dwd_weather <- dwd_weather %>%
  dplyr::select("Date"="Date",
         "Site"="SITE",
         "dm_wind_velocity"="FM",
         "dm_temperature"="TMK")
```


We will not keep the weather data written down by hand in the field, as it is not as reliable as the data from the DWD weather station. However, an interesting variable to keep is the start time of walking the transect for the netting method. This could be an important factor in the number of pollinators caught, as some species are more active in the morning or evening.

### 1.2. Field weather data - Start time of netting

```{r field weather start time}
#transform field_weather into start_net dataframe
start_net <- field_weather %>%
  dplyr::select(
         "Date"="date",
         "Site"="SITE",
         "Transect"="transect",
         "Start_time"="start_time")

start_net <- start_net %>%
  mutate(
    Start_time = gsub("\\.", ":", Start_time),  # Replace "." with ":"
    Start_time = ifelse(Start_time == "9:25", "09:25", Start_time),  # Fix specific case
    Start_time = ifelse(nchar(Start_time) == 4, paste0(Start_time, "0"), Start_time),  # Ensure "14:0" -> "14:00"
    Start_time = ifelse(nchar(Start_time) == 2, paste0(Start_time, ":00"), Start_time),  # Ensure "14" -> "14:00"
    Hour = as.integer(substr(Start_time, 1, 2)),  # Extract hour
    Minute = as.integer(substr(Start_time, 4, 5)))%>%  # Extract minutes
    #add new column minutes since 9 am
    mutate(minutes_since_9am = (Hour - 9) * 60 + Minute)%>%
  #remove unnecessary columns
  dplyr::select(-c("Hour", "Minute", "Start_time"))
    
     

#barplot start time per site, colored by transect
start_net %>%
    ggplot(aes(x = Site, y = minutes_since_9am, fill = Transect)) +
  geom_bar(stat = "identity", position= "dodge") +
  labs(title = "Start time of netting per site",
       x = "Site",
       y = "Time (minutes since 9 am)") +
  theme(legend.position = "left")+
  #viridis
  scale_fill_viridis_d() 

write.csv(start_net, "C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/data/start_net.csv", row.names = FALSE)

```

### 1.3. Landscape data & combining 

```{r landscape and top2}
Floral_simpson_index_T <- relative_flower %>%
  dplyr::select("Site"="Site",
         "Transect"="Transect",
         "Site_type"="Site_type",
         "Floral_simpson_index"="Floral_simpson_index")%>%
  distinct()%>%
  #new column with average simpson per transect
  group_by(Site, Transect, Site_type) %>%
  summarise(Floral_simpson_index_T = sum(Floral_simpson_index)/3)%>%
  ungroup()


planty <- relative_flower %>%
  dplyr::select(Site, Plot_Cover, Transect)%>%
  #average the plot cover per transect
  group_by(Site, Transect) %>%
  summarise(Plot_Cover_T = mean(Plot_Cover, na.rm = TRUE))
  

envir_data <- start_net %>%
  #select the relevant columns
  #dplyr::select(-c("Start_time", "Time_Bin"))%>%
  
  #join the dwd weather data
  full_join(dwd_weather, by = c("Date" = "Date", "Site"))%>%
  
  #join the landscape data
  full_join(landscape_data, by = c("Site" = "Site"))%>%
  
  #join the top2 data
  full_join(top2, by = c("Site" = "Site", "Transect")) %>%
  dplyr::select(-c( "Site_type"))%>% #site_type from the top2 is lacking some rows, we'll get this variable from another dataframe 

  
  #join the plant data
  full_join(planty, by = c("Site" = "Site", "Transect"))%>%
  
  #remove extra columns
  #dplyr::select( -c("top2_ratio", "Site_type"))%>%
  #dplyr::select( -c("top2_ratio", "Floral_shannon_index"   , "Floral_species_richness"))%>%
  
  #add only simpson index from relative_flower 
  full_join(Floral_simpson_index_T, by= c("Site", "Transect"))%>%

  
  #fill in NA with 0 in the Pastinaca.sativa"   "Daucus.carota"   "top2_ratio" columns   
  mutate(across(c("Pastinaca.sativa", "Daucus.carota"), ~replace_na(., 0)))%>%
  mutate(across(c("top2_ratio"), ~replace_na(., 0)))%>%

  
  #change the date to a date format
  mutate(Date = as.Date(Date, format = "%Y-%m-%d"))%>%
  
  #create Days_since_start variable
  mutate(Days_since_start = as.numeric(Date - min(Date)+1))%>%
  
  #rename rows in Site_type column 1-5y to young_restored and Reference to reference
  mutate(Site_type = ifelse(Site_type == "1-5 y", "young_restored", "reference"))%>%
  
  distinct()

```

### 1.4. Correlation matrix of environmental variables

At a transect level. 

```{r correlation matrix}
#correlation matrix of all the numerical environmental variables
tmp_cor_envir <- envir_data %>%
  select_if(is.numeric) %>%
  na.omit() %>%
  #remove minutes_since_9am column
  select(-c("minutes_since_9am")) %>%
  mutate(across(everything(), scale))%>% # scale the data - Z-score standardization
  distinct()
  
tmp_qq_plots <- list()
# plot Q-Q plots for each variable
for (i in 1:ncol(tmp_cor_envir)) {
  tmp_qq_plots[[i]] <- ggplot(tmp_cor_envir, aes(sample = .data[[colnames(tmp_cor_envir)[i]]])) +
  stat_qq()+
  stat_qq_line()+
  ggtitle(str_wrap(colnames(tmp_cor_envir)[i], width = 20))+
  theme(plot.title = element_text(size = 10))  
}

tmp_qq_plots[[1]]; tmp_qq_plots[[2]]; tmp_qq_plots[[3]]; tmp_qq_plots[[4]]; tmp_qq_plots[[5]]; tmp_qq_plots[[6]]; tmp_qq_plots[[7]]; tmp_qq_plots[[8]]; tmp_qq_plots[[9]];tmp_qq_plots[[10]];tmp_qq_plots[[11]];tmp_qq_plots[[12]]; tmp_qq_plots[[13]];tmp_qq_plots[[14]]
#;tmp_qq_plots[[15]];tmp_qq_plots[[16]];tmp_qq_plots[[17]

```

```{r correlation plot}
tmp_env_cor_results <- rcorr(as.matrix(tmp_cor_envir), type = "spearman") 

# extract correlation matrix
tmp_env_cor_matrix <- tmp_env_cor_results$r

# extract the p-values
tmp_env_p_matrix <- tmp_env_cor_results$P

# plot correlation matrix (only insignificant ones hidden)
tmp_corr_num <- corrplot::corrplot(tmp_env_cor_matrix, 
         type = "upper",
         method = "color",
         diag = F,                         # remove diagonal
         #addCoef.col = "black",           # add coefficient coeffs, not used 
         p.mat = tmp_env_p_matrix,         # add p-values matrix
         sig.level = c(0.001, 0.01, 0.05), # significance thresholds
         tl.col = "black",                 # color of variable labels
         cl.align.text = "l",              # alignment of color legend
         cl.offset = 0.3,                  # offset color legend text to the right
         number.cex = 0.8,                 # size of coefficient text
         tl.cex	= 0.8,                     # size of variable labels
         insig = "label_sig",              # add stars according to significance thresholds
         pch.cex = 0.8)                      # size of stars

# save the plot as a png
dev.copy(png, "C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/figures/correlation_plot_num.png", width = 1600, height = 1600, res = 300)
dev.off()
```

### 1.5. PCA of environmental variables

```{r PCA}
#PCA of the environmental data
tmp_cor_envir_pca <- tmp_cor_envir %>%
  #remove Na values
  na.omit() %>%
  prcomp(, scale = TRUE)

# plot the PCA
(tmp_cor_envir_pca_plot <- fviz_pca_biplot(tmp_cor_envir_pca, 
                                         geom = c("point", "text"), 
                                         col.var = "contrib", # color by contributions to axes
                                         gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), #this gradient indicates the contribution of each variable to the axis
                                         repel = TRUE, # avoid text overlapping
                                         title = "PCA of Environmental Data"))
```

```{r removing temporary envir data}
# remove all dataframes with tmp_ prefix
rm(list = ls(pattern = "^tmp_"))
#rm(top2, landscape_data, dwd_weather, field_weather, start_net)
```

## 2. Traditional methods - NETTING

### 2.1. Data preparation


```{r}
#change lowest_taxa to Coccinellidae any row that has Coccinellidae_
netting <- netting %>%
  mutate(lowest_taxa = ifelse(grepl("Coccinellidae_", lowest_taxa), "Coccinellidae", lowest_taxa))
```


## 3. Traditional methods - PAN TRAPS

### 3.1. Data preparation

```{r}
#the transect values for pan_family are not in the same format as in the envir_data. let's change that
#changing the str to character and then adding a T before the transect number
pan_family <- pan_family %>%
  mutate(Transect = as.character(Transect)) %>%
  mutate(Transect = paste0("T", Transect))

#combine envir_data with pan_family data
pan_family1 <- pan_family %>%
  
  #right date format
  mutate(Date = as.Date(Date, format = "%Y-%m-%d"))%>%
  
  #join the envir_data with pan_family
  left_join(envir_data, by = c("Site", "Transect", "Date", "Site_type"))%>%
  
  #remove extra columns
  dplyr::select(-minutes_since_9am, -Days_since_start)
```

### 3.2. Data exploration

```{r}
# scatterplot the number of taxa caught in the pan traps per transect depending on simpson index
pan_family1 %>%
  #remove 0 count values
  filter(Count > 0) %>%
  ggplot(aes(x = Floral_simpson_index_T, y = Count)) +
  geom_point(aes(color = Site), alpha = 5) +
  #geom_smooth(method = "lm", se = FALSE) +
  labs(title = "Number of individuals caught in pan traps per transect depending on simpson index",
       x = "Floral simpson index",
       y = "Number of individuals caught") +
  scale_color_manual(values = saturated_pal) +
  theme(legend.position = "left")

#stacked  barplot of the number of individuals caught in the pan traps per transect per site
pan_family1 %>%
  ggplot(aes(x = Site, y = Count, fill = Transect)) +
  geom_bar(stat = "identity") +
  labs(title = "Number of individuals caught in pan traps per transect per site",
       x = "Site",
       y = "Number of individuals caught") +
  #scale_fill_manual(values = saturated_pal) +
  theme(legend.position = "left")

#custom25 <- paletteer_c("grDevices::Hawaii", n = 25) # Extract first 25 colors

custom25 <- c(paletteer_d("khroma::light"),paletteer_d("ggprism::muted_rainbow"),paletteer_d("ggsci::default_flatui"))[1:25]  # Ensure exactly 25 colors


#barplot of the number of each taxon caught in the pan traps per site
pan_family1 %>%
  #group by site and taxa
  group_by(Site, Taxa) %>%
  #sum the count of each taxon
  summarise(Count = sum(Count)) %>%
  ggplot(aes(x = Site, y = Count, fill = Taxa)) +
  geom_bar(stat = "identity", color = "black") +
  labs(title = "Count of each taxon caught in pan traps per site",
       x = "Site",
       y = "Number of individuals caught") +
  #viridis  color palette for the taxa 
  #scale_fill_viridis_d(option = "rocket") +
  scale_fill_manual(values = custom25) +  # Apply manually
  theme(legend.position = "left")


#plot of count vs floral simpson index
pan_family1 %>%
  #remove 0 count values
  #filter(Count > 0) %>%
  ggplot(aes(x =Floral_simpson_index_T, y = Count)) +
  geom_point(aes(color = Site), alpha = 5) +
  #geom_smooth(method = "lm", se = FALSE) +
  labs(title = "Count vs Floral Simpson Index",
       x = "Floral Simpson Index",
       y = "Count") +
  scale_color_manual(values = saturated_pal) +
  theme(legend.position = "bottom")


pan_family1 %>%
  #remove 0 count values
  filter(Count > 0) %>%
  #remove count higher than 30
  #filter(Count < 30) %>%
  ggplot(aes(x = Site_type, y = Count)) +
  geom_boxplot(fill = "lightblue") +
  theme_minimal() +
  labs(y = "Total interactions", x = "Site Type")+
  theme(legend.position = "bottom")

```

### 3.3. Pan traps vs InsectDetect


```{r insectdetect more than 0.5}
#barplot of the number of each taxon caught with the platform camera per site
platform_camera %>%
  #filter out top1 that start with none_ as they are not real taxa
  filter(!grepl("none_", top1)) %>%
  #remove top1_prob_weighted that are below 0.5
  #filter(top1_prob_weighted > 0.5) %>%
  #group by site and taxa
  group_by(location, top1) %>%
  #count the number of each top1 caught
  summarise(Count = n()) %>%
  ggplot(aes(x = location, y = Count, fill = top1)) +
  geom_bar(stat = "identity", color = "black") +
  labs(title = "Count of each taxon caught on platforms per site",
       x = "Site",
       y = "Number of individuals caught") +
  #viridis  color palette for the taxa 
  #scale_fill_viridis_d(option = "rocket") +
  scale_fill_manual(values = custom25) +  # Apply manually
  theme(legend.position = "left")
```

```{r combining pan traps and insectdetect}
# unify the taxa names in both datasets
tmp_pan_family <- pan_family%>%
 # adapt taxa categories to the ones used in platform data (less precise)
  mutate(Category = case_when(
    Taxa %in% c("cantharidae", "carabidae", "curculionidae", "elateridae",
                "mordellidae", "staphylinidae") ~ "beetle",
    Taxa %in% c("coccinellidae") ~ "beetle_cocci",
    Taxa %in% c("hemiptera") ~ "bug",
    Taxa %in% c("diptera","calliphoridae","cecidomyiidae","tachinidae","calliphoridae",
                "sepsidae","ephydridae","muscidae","asilidae","stratiomyidae", "polleniidae","acalyptrate" ) ~ "fly",
    Taxa %in% c("dasypoda","apidae","colletidae") ~ "bee_apis",
    Taxa %in% c("bombus") ~ "bee_bombus",
    Taxa %in% c("sarcophagidae") ~ "fly_sarco",
    Taxa %in% c("symphyta","apocrita","proctotrupidae","tenthredinidae") ~ "wasp",
    Taxa %in% c("empididae") ~ "fly_empi",
    TRUE ~ Taxa
    ))%>%
    #remove all rows that have a 0 "count" value
  filter(Count != 0) %>%
  
  #select only the relevant columns for the comparison
  dplyr::select(Site, Transect, Site_type, Category, Count)

#select only the relevant columns fo platform_camera for the comparison
tmp_platform_camera <- platform_camera %>%
  
  mutate(transect = as.character(transect)) %>%
  mutate(transect = paste0("T", transect))%>%
  
  #filter out top1 that start with none_ as they are not real taxa
  filter(!grepl("none_", top1)) %>%
  
  #remove top1_prob_weighted that are below 0.5
  filter(top1_prob_weighted > 0.85) %>%
  
  #group by site and taxa
  group_by(location,transect, top1) %>%
  
  #count the number of each top1 caught
  summarise(Count = n()) %>%
  ungroup() %>%
  
  #add empty Site_Type column
  mutate(Site_type = NA)%>%
  
  #remove columns that not needed for comparison with pan_family, rename top1 to Category
  dplyr::select(Site=location, Site_type,Transect=transect, Category = top1, Count)


#add method column to both pan_family and platform_camera
tmp_pan_family$Method <- "bowl_trap"
tmp_platform_camera$Method <- "platform_camera"

#combine the two datasets
tmp_combined <- rbind(tmp_pan_family, tmp_platform_camera)%>%
  #adapt empty Site_type following the Site column
  mutate(Site_type = ifelse(Site %in% c("DES", "HLI", "JEP", "STP", "WUP"), "reference", "young_restored"))

tmp_combined %>%
  ggplot(aes(x = Site, y = Count, fill = Category)) +
  geom_bar(stat = "identity", position = "stack") +
  facet_wrap(~Method, ncol=1) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Comparison of the two sampling methods",
       x = "Site",
       y = "Count")+
    scale_fill_manual(values = custom25)
  # Add confidence threshold annotation
  #annotate("text", x = Inf, y = Inf, label = paste("Confidence threshold:", 0.85), hjust = 1.1, vjust = 1.1, size = 3)

sum(tmp_combined$Count[tmp_combined$Method == "bowl_trap"])
sum(tmp_combined$Count[tmp_combined$Method == "platform_camera"])
```

```{r interactive threshold adjustment}
library(shiny)
library(ggplot2)
library(dplyr)

# Define UI
ui <- fluidPage(
  titlePanel("Interactive Threshold Adjustment"),
  sidebarLayout(
    sidebarPanel(
      sliderInput("threshold", "Select top1_prob_weighted threshold:", 
                  min = 0.4, max = 1.0, value = 0.85, step = 0.01)
    ),
    mainPanel(
      plotOutput("barPlot"),
      verbatimTextOutput("counts")
    )
  )
)

# Define server logic
server <- function(input, output) {
  
  # Reactive dataset based on threshold
  filtered_data <- reactive({
    tmp_platform_camera <- platform_camera %>%
      mutate(transect = as.character(transect)) %>%
      mutate(transect = paste0("T", transect)) %>%
      filter(!grepl("none_", top1)) %>%
      filter(top1_prob_weighted > input$threshold) %>%
      group_by(location, transect, top1) %>%
      summarise(Count = n(), .groups = "drop") %>%
      mutate(Site_type = NA) %>%
      dplyr::select(Site = location, Site_type, Transect = transect, Category = top1, Count)
    
    tmp_pan_family$Method <- "bowl_trap"
    tmp_platform_camera$Method <- "platform_camera"
    
    tmp_combined <- rbind(tmp_pan_family, tmp_platform_camera) %>%
      mutate(Site_type = ifelse(Site %in% c("DES", "HLI", "JEP", "STP", "WUP"), 
                                "reference", "young_restored"))
    
    return(tmp_combined)
  })
  
  # Render plot
  output$barPlot <- renderPlot({
    ggplot(filtered_data(), aes(x = Site, y = Count, fill = Category)) +
      geom_bar(stat = "identity", position = "stack") +
      facet_wrap(~Method) +
      theme_minimal() +
      theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
      labs(title = "Comparison of the two sampling methods",
           x = "Site",
           y = "Count") +
      scale_fill_manual(values = custom25)
  })
  
  # Show sum of counts for each method
  output$counts <- renderText({
    data <- filtered_data()
    bowl_count <- sum(data$Count[data$Method == "bowl_trap"], na.rm = TRUE)
    platform_count <- sum(data$Count[data$Method == "platform_camera"], na.rm = TRUE)
    paste("Total Count (Bowl Trap):", bowl_count, "\nTotal Count (Platform Camera):", platform_count)
  })
}

# Run the application 
shinyApp(ui = ui, server = server)
```

```{r}
#remove all dataframes with tmp_ prefix
rm(list = ls(pattern = "^tmp_"))
```

## 4. Automated methods - PLATFORM CAMERAS

### 4.1. Data preparation

```{r}
str(platform_camera)

platform_camera <- platform_camera %>%
  #transect values from numbers 1-5 to T1-T5
  mutate(transect = as.character(transect)) %>%
  mutate(transect = paste0("T", transect))%>%
  #filter out top1 that start with none_ as they are not real taxa
  filter(!grepl("none_", top1))

#format date

platform_camera1 <- platform_camera %>%
  #right date format
  mutate(date = as.Date(date, format = "%Y-%m-%d"))%>%
  #join the envir_data with platform_camera
  left_join(envir_data, by = c("location"="Site","transect" ="Transect", "date"="Date"))%>%
  #remove extra columns
  dplyr::select(-minutes_since_9am)%>%
  
  #add column with recording time per transect from platform_logs_rec
  left_join(platform_logs_rec, by = c("location"="Site", "transect"="Transect", "cam_ID"))%>%
  
    #add minutes_since_9am column by mutating first_record_start_time from 2024-07-11T13:38:07Z to an hour (13) and minute (38) columns
  #mutate(first_record_start_time = gsub("T", " ", first_record_start_time)) %>%  # Replace 'T' with space
  #mutate(first_record_start_time = gsub("Z", "", first_record_start_time)) %>%  # Remove 'Z'
  #remove the seconds from the time
  #mutate(first_record_start_time = gsub(":(\\d{2})$", "", first_record_start_time)) %>%  # Remove seconds
  #remove the "yyyy-mm-dd " from the first_record_start_time
  #mutate(first_record_start_time = gsub(".* ", "", first_record_start_time)) %>%  # Remove date part
  #split the first_record_start_time into hour and minute columns
  mutate(Hour = as.integer(substr(first_record_start_time, 1, 2)),  # Extract hour
         Minute = as.integer(substr(first_record_start_time, 4, 5)))%>% # Extract minutes
  #add new column minutes since 9 am
  mutate(minutes_since_9am = (Hour - 9) * 60 + Minute)%>%
  #keep only first value of minutes_since_9am when site and transect are the same
  group_by(location, transect, date) %>%
  mutate(minutes_since_9am = first(minutes_since_9am)) %>%
  ungroup() %>%
  #remove unnecessary columns
  dplyr::select(-c("first_record_start_time", "Hour", "Minute"))#%>%

#barplot start time per site, colored by transect
platform_camera1 %>%
    ggplot(aes(x = location, y = minutes_since_9am, fill = transect)) +
  geom_bar(stat = "identity", position= "dodge") +
  labs(title = "Start time of netting per site",
       x = "Site",
       y = "Time (minutes since 9 am)") +
  theme(legend.position = "left")+
  #viridis
  scale_fill_viridis_d() 

platform_camera1 <- platform_camera1 %>%
 #scale these columns: "dm_wind_velocity" "dm_temperature" "agri" "grass" "snh" "forest" "urban" "water" "Pastinaca.sativa" "Daucus.carota" "top2_ratio" "Floral_simpson_index" "minutes_since_9am"  
  mutate(across(c("dm_wind_velocity", "dm_temperature", "agri", "grass", "snh", "forest", "urban", "water", "Pastinaca.sativa", "Daucus.carota", "top2_ratio", "Floral_simpson_index_T", "minutes_since_9am", "Days_since_start"), scale))

```


## 5. Automated methods - FLOWER CAMERAS

### 5.1. Data preparation

```{r structure}
#change format of "time" column from hh-mm-ss to hh:mm:ss
flower_camera <- flower_camera %>%
  mutate(time = gsub("\\-", ":", time)) %>%  # Replace '-' with ':'
  mutate(time = chron::times(time))%>%  # Convert to time-only format
  #change format of "date" 
  mutate(date = as.Date(date, format = "%Y-%m-%d"))

str(flower_camera)
```


```{r all data from flower cameras}
custom193 <- paletteer_c("ggthemes::Sunset-Sunrise Diverging", n = 193)

# Replace "other_families" with gray
custom193_named <- setNames(custom193, sort(unique(flower_camera$Classification_Category)))
custom193_named["other_families"] <- "gray50"  # Adjust shade if needed

#plot of the number of each taxon caught in the flower cameras per site
flower_camera %>%
  #summarise per site and count the number of each taxon caught
  group_by(site, Classification_Category) %>%
  summarise(Count = n(), .groups = "drop") %>%
  
  ggplot(aes(x = site, y = Count, fill = Classification_Category)) +
  geom_bar(stat = "identity") +
  labs(title = "Count of each taxon caught with flower cameras per site",
       x = "Site",
       y = "Number of detections") +
  theme(legend.position = "none") +
  scale_fill_manual(values = custom193_named)   # Apply manually
```

```{r threshold adjustment plotting}
#remove rows with Classification_Category "other_families"
flower_camera <- flower_camera %>%
 #filter out the rows where Classification_Category is "other_families"
  filter(Classification_Category != "other_families")
  
  
## Define THRESHOLD ----
TH <- 0.5

#histogram of the Family_Confidence
flower_camera %>%
  ggplot(aes(x = Family_Confidence)) +
  geom_histogram(binwidth = 0.05, fill = "lightblue", color = "black") +
  labs(title = "Histogram of Family Confidence",
       x = "Family Confidence",
       y = "Count")+
  #add a vertical line at the threshold
  geom_vline(xintercept = TH, color = "red", linetype = "dashed")+  
  # Add confidence threshold annotation
  annotate("text", x = Inf, y = Inf, label = paste("Confidence threshold:", TH), 
           hjust = 1.1, vjust = 1.1, size = 3, color = "red")

#new dataframe above TH
flower_camera_light <- flower_camera %>%
  #remove path column
  dplyr::select(-Image_Path) %>%
  #filter out the rows where Family_Confidence is below the threshold
  filter(Family_Confidence > TH) %>% 
  #fill Site_type column with reference or young_restored
  mutate(Site_type = ifelse(site %in% c("DES", "HLI", "JEP", "STP", "WUP"), "reference", "young_restored"))
  
#calculate the proportion of rows removed
diff <- nrow(flower_camera) - nrow(flower_camera_light)
prop <- diff / nrow(flower_camera) 

#print 
print(paste("By removing rows with a probality score below the threshold", TH, ", we remove", round(prop,2), "of the data."))
#remove 
rm(diff, prop)

#plot of the number of each taxon caught in the flower cameras per site
flower_camera_light %>%
  #summarise per site and count the number of each taxon caught
  group_by(site, Classification_Category) %>%
  summarise(Count = n(), .groups = "drop") %>%
  
  ggplot(aes(x = site, y = Count, fill = Classification_Category)) +
  geom_bar(stat = "identity") +
  labs(title = "Count of each taxon caught in flower cameras per site",
       x = "Site",
       y = "Number of individuals caught") +
  theme(legend.position = "none") +
  scale_fill_manual(values = custom193_named)  +  
  # Add confidence threshold annotation
  annotate("text", x = Inf, y = Inf, label = paste("Probability threshold:", TH), 
           hjust = 1.1, vjust = 1.1, size = 3)

#plot of the number of each taxon caught in per flower species 
flower_camera_light %>%
  #summarise per site and count the number of each taxon caught
  group_by(site, Classification_Category, flower_sp) %>%
  summarise(Count = n(), .groups = "drop") %>%
  
  ggplot(aes(x = flower_sp, y = Count, fill = Classification_Category)) +
  geom_bar(stat = "identity") +
  labs(title = "Count of each taxon caught in flower cameras per flower species",
       x = "Flower Species",
       y = "Number of detections") +
  theme(legend.position = "none") +
  #slant the x-axis labels
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_fill_manual(values = custom193_named) +  
  # Add confidence threshold annotation
  annotate("text", x = Inf, y = Inf, label = paste("Probability threshold:", TH), 
           hjust = 1.1, vjust = 1.1, size = 3)
```

### 5.2. Data exploration - Individuals vs time

```{r individuals vs time}
#plot of the number of individuals caught in the flower cameras over time
# Convert time to POSIXct by combining with the date
binned_data <- flower_camera_light %>%
  mutate(
    datetime = as.POSIXct(paste(date, time), format = "%Y-%m-%d %H:%M:%S"),  # Ensure proper datetime format
    time_bin = floor_date(datetime, "10 minutes"))%>%  # Bin into 5-minute chunks
  #remove date from the time_bin column
  mutate(time_bin = format(time_bin, "%H:%M:%S"))

# Summarize count of individuals per order per time bin
binned_data <- binned_data %>%
  group_by(date,site,time_bin, Order) %>%
  summarise(Count = n(), .groups = "drop")%>%
  #change time_bin to a character
  mutate(time_bin = as.character(time_bin))

# Plot the data
ggplot(binned_data, aes(x = time_bin, y = Count, fill = Order)) +
  geom_bar(stat = "identity")+
  labs(
    title = "Number of Individuals Per Family Over Time (10-min Bins)",
    x = "Time (10-minute bins)",
    y = "Count of Individuals"
  ) +
  facet_wrap(~site) +
  theme_minimal() +
  theme(legend.position = "right")+
  # format x-axis to show labels every hour
  scale_x_discrete(
      breaks = binned_data$time_bin[grepl("00:00$|30:00$", binned_data$time_bin)],
      labels = gsub(":00$", "", binned_data$time_bin[grepl("00:00$|30:00$", binned_data$time_bin)]))+
  #slant the x-axis labels
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) 
  #scale_color_manual(values = custom193_named)   # Apply manually

#rm(binned_data)
```



### 5.3. Data exploration - Daucus carota

Here, we'll focus on the Daucus carota species, as it is a common plant species in the study area and is known to attract a variety of pollinators. 

Since the cameras didn't have an ID tracking system, we'll have a look at taxonomic richness and relative abundance of pollinators attracted to Daucus carota.

```{r daucus carota both methods}
daucus_cam <- flower_camera_light %>%
  #filter out the rows where the flower species is Daucus.carota
  filter(flower_sp == "Daucus carota") %>%
  group_by(site) %>%
  summarise(unique_families = unique(Classification_Category),
            .groups = "drop")%>%
  #add Count column filled with 1 
  mutate(Count = 1)

#same thing with netting
daucus_net <- netting %>%
  #filter out the rows where the flower species is Daucus.carota
  filter(plant_species == "Daucus carota") %>%
  group_by(site) %>%
  summarise(unique_families = unique(family),
            .groups = "drop")%>%
  #add Count column filled with 1 
  mutate(Count = 1)

# Combine both datasets, adding a column to differentiate methods
daucus <- bind_rows(
  daucus_cam %>% mutate(method = "Camera"),
  daucus_net %>% mutate(method = "Net")
)

#combining all the unique families caught on Daucus with nets and cameras
fams <- sort(unique(daucus$unique_families));length(fams) # Get unique families sorted alphabetically
customfam <- paletteer_c("pals::kovesi.rainbow_bgyrm_35_85_c69", n = length(fams))
customfam <- setNames(customfam, fams)

# Create a single ggplot with faceting
final_plot1 <- ggplot(daucus, aes(x = site, y = Count, fill = unique_families)) +
  geom_bar(stat = "identity") +
  facet_wrap(~method, ncol = 1) +  # Separate plots
  labs(title = "Pollinator Family richness caught on Daucus carota",
       x = "Site",
       y = "Number of unique families caught") +
  theme(legend.position = "none") +  # Shared legend at bottom
  scale_fill_manual(values = customfam)  # Consistent colors

# Create a single ggplot with faceting
final_plot2 <- ggplot(daucus, aes(x = method, y = Count, fill = unique_families)) +
  geom_bar(stat = "identity") +
  labs(title = "Pollinator Family richness caught on Daucus carota",
       x = "Site",
       y = "Number of unique families caught") +
  theme(legend.position = "none") +  # Shared legend at bottom
  scale_fill_manual(values = customfam)  # Consistent colors

# Print the final plot
print(final_plot1); print(final_plot2)
```

```{r}
rm(daucus_cam, daucus_net, fams, customfam, final_plot1, final_plot2)
```

## 6. Modelling

*Key Metric	Meaning*    

- AICc (Akaike Information Criterion, corrected)	Measures model fit while penalizing complexity. Lower = better.
- BIC (Bayesian Information Criterion)	Similar to AIC but penalizes complexity more harshly. Lower = better.
- R² (Conditional & Marginal)	Measures variance explained by fixed & random effects. Higher = better.
- ICC (Intraclass Correlation Coefficient)	Proportion of variance explained by random effects. Higher = more site-level variation.
- RMSE (Root Mean Square Error)	Measures prediction error. Lower = better.

## 6.1. Flower survey data

For the flower survey data, we have data at the plot level, but we'll average them to transect level, as it is the same level as the netting, pan traps and platform data.

### 6.1.1. Flower survey - Linear mixed model with random effect - lmer 

```{r fig.width=8, fig.height=10}
scaled_envir_data <-envir_data %>%
  
  #z transform the numerical columns, except Floral_simpson_index
  mutate(across(where(is.numeric) & !contains("Floral_simpson_index"), scale))

#checking the values
scaled_envir_data%>%
  mutate(across(where(is.numeric)))%>%
  #summary()%>%
  sapply(sd)
  
scaled_envir_data%>%
  ggplot(aes(x=Floral_simpson_index_T))+
  geom_histogram(binwidth = 0.1, fill = "lightblue", color = "black")+
  labs(title = "Histogram of Floral Simpson Index",
       x = "Floral Simpson Index",
       y = "Count")

# is the floral simpson index normally distributed?
shapiro.test(scaled_envir_data$Floral_simpson_index_T) # p-value = 0.02828, so it is not normally distributed
datawizard::describe_distribution(scaled_envir_data$Floral_simpson_index_T)


# Create a linear model
# full model with Floral_simpson_index as response variable and structure around  the sites as explanatory variables, and site as random effect
plantsimp_mod1_full <- lmer(Floral_simpson_index_T
                            ~ Site_type
                            +majority_class 
                            +Plot_Cover_T
                            #+ agri + grass + snh + forest + urban + water
                            + (1|Site), data = scaled_envir_data)

summary(plantsimp_mod1_full)
parameters(plantsimp_mod1_full)

#checking the model
check_model(plantsimp_mod1_full)

#overdispersion
check_overdispersion(plantsimp_mod1_full)

#collinearity
check_collinearity(plantsimp_mod1_full)

# Compute fitted values and Pearson residuals
plantsimp_mod1_vals <- fitted(plantsimp_mod1_full)
plantsimp_mod1_residuals <- residuals(plantsimp_mod1_full, type = "pearson")
# Create binned residuals plot
arm::binnedplot(plantsimp_mod1_vals, plantsimp_mod1_residuals)

#DHARMa package - simulate residuals and check model assumptions
plantsimp_mod1_sim_res <- simulateResiduals(fittedModel = plantsimp_mod1_full)
plot(plantsimp_mod1_sim_res)
testDispersion(plantsimp_mod1_full) 
```

```{r plantsimp_mod1_beta, fig.width=8, fig.height=10}
plantsimp_mod1_beta <- glmmTMB(Floral_simpson_index_T 
                               ~ Site_type 
                               + majority_class #majority labndcover class in 1km buffer zone around the site
                               #+ agri + grass + snh + forest + urban + water
                               + Plot_Cover_T 
                               + top2_ratio
                               + (1|Site),
                    #ziformula = ~1,  # allows zero-inflation if needed
                    family = beta_family(),
                    data = scaled_envir_data)

summary(plantsimp_mod1_beta)
parameters(plantsimp_mod1_beta)

#checking the model
check_model(plantsimp_mod1_beta)
#overdispersion
check_overdispersion(plantsimp_mod1_beta)
#collinearity
check_collinearity(plantsimp_mod1_beta)
# Compute fitted values and Pearson residuals
plantsimp_mod1_beta_vals <- fitted(plantsimp_mod1_beta)
plantsimp_mod1_beta_residuals <- residuals(plantsimp_mod1_beta, type = "pearson")
# Create binned residuals plot
arm::binnedplot(plantsimp_mod1_beta_vals, plantsimp_mod1_beta_residuals)
#DHARMa package - simulate residuals and check model assumptions
plantsimp_mod1_beta_sim_res <- simulateResiduals(fittedModel = plantsimp_mod1_beta)
plot(plantsimp_mod1_beta_sim_res)
```


#### 6.1.2. Flower Survey Model Interpretation of Results

> Model Summary: `plantsimp_mod1_beta`

**Model type:** Beta regression with logit link  
**Response:** `Floral_simpson_index_T` (bounded between 0 and 1)  
**Predictors:** `Site_type`, `majority_class` (land cover), `Plot_Cover_T`  
**Random effect:** Intercept for `Site`

---

> Assumption Checks

- ✅ **Distributional appropriateness**: The response is continuous and bounded (0, 1), suitable for a beta distribution.
- ✅ **No overdispersion**: Dispersion ratio = 1.085, *p* = 0.664 (DHARMa).
- ✅ **No multicollinearity**: All VIF values < 2.3.
- ✅ **Residual diagnostics** (DHARMa):
  - No significant dispersion.
  - No zero-inflation.
  - No major residual structure.
- ⚠️ **Random effect warning**: The variance for `Site` is near zero. This suggests possible singularity (i.e., random intercept not contributing meaningfully).

---

> Interpretation of Results

- **Significant effect:**
  - `Plot_Cover_T` (scaled plot-level vegetation cover)  
    - Estimate = -0.64  
    - *p* < 0.001  
    - **Interpretation:** As local vegetation cover increases, floral Simpson diversity decreases.

- **Non-significant predictors:**
  - `Site_type` (*p* = 0.16)
  - `majority_class` (all levels *p* > 0.5)

---

> Conclusion

The best predictor of floral Simpson diversity in this model is **local-scale vegetation cover** (`Plot_Cover_T`), which has a **significant negative effect**. Broader site type and surrounding land cover context (`majority_class`) do not explain significant variation in flower diversity in this case.

--- 

```{r fig.width=8, fig.height=10}
plot_model(plantsimp_mod1_beta , type = "est", show.values = TRUE, value.offset = .3)
```


## A.6.2. Netting data

For the netting data, the predictor variables are:
- Floral Simpson Index
    + Simpson index captures dominant flowering species, aligning with the nested structure of plant–pollinator networks: many specialists rely on a few generalists. This skewed interaction pattern makes generalist flowers key to maintaining pollinator communities, justifying their emphasis in diversity modeling.
- Minutes since 9 am
    + Time since 9 am, to account for the time of day. Each netting session is made to be 30 minutes of active netting, so the sampling effort is the same for all transects. 
- Top 2 ratio
    + Relative abundance ratio of D. carota and P. sativa combined, used as a proxy for dominance shifts.
- Site type
    + Young restored sites (1 to 5 years ago) vs reference sites.
- Daily mean wind velocity
    + Daily mean wind velocity (m/s) measured at the nearest weather station to account for weather conditions.
- Daily mean temperature
    + Daily mean temperature (°C) measured at the nearest weather station to account for weather conditions.
- Days since start
    + Days since the start of the sampling to account for seasonal effects.
    
Majority class or land cover type (agri, grass, snh, forest, urban, water) were not included in the model.
Since we have only 5 transects per site (5x9= 45 units), we need to be careful with the number of predictors we include in the model. The following variables were not included in the model, because they were not significant for the floral simpson index, and because they are not very precise (100m resolution), and would not show a meaningful impact on our sites. (For example, for categories like agricultural areas, the type of crop cultivated is not known which could have a big impact on the floral diversity). 


## A.6.2.1. Netting data - INTERACTION COUNTS


```{r prepare data}
#scale the last envir_data - Floral simpson_index
scaled_envir_data <- envir_data %>%
  #z transform the numerical columns, exceptFloral_simpson_index_T
  mutate(across(where(is.numeric), scale))

netting1 <- netting %>%
  #right date format
  mutate(date = as.Date(date, format = "%Y-%m-%d"))%>%
  #summarize by site, transect
  group_by(site, transect) %>%
  summarise(total_interaction_T = sum(total_interaction), .groups = "drop")%>%
   #join the envir_data with netting
  left_join(scaled_envir_data, by = c("site"="Site", "transect"="Transect"))

#histogram of total_interaction_T
netting1 %>%
  ggplot(aes(x = total_interaction_T)) +
  geom_histogram(fill = "lightblue", color = "black") +
  labs(title = "Histogram of Netting Counts",
       x = "total interactions",
       y = "Count")
```

## A.6.2.1. INTERACTION Netting - POISSON GLMM


The first model has too many predictors and is over fitting the data. 
A lot of the predictors are significant, but the assumptions of the model are not met (overdispersion(p < 0.001), S-shape around qqplot, and the residuals appear to be heteroskedastic (residuals vs predicted plot)). 
We will be removing predictors one by one and checking the model assumptions after each step. 

The comparison of the models shows that the model with the lowest AICc and BIC is the third model (netting_mod3_full), which has the lowest AICc and BIC values. However, even in this model, the AICc and BIC values are quite high, indicating that the model is not the best fit for the data. In the next step, we will try to run a negative binomial model to see if it improves the fit of the model.

### Interpretation of results for POISSON GLMM
**netting_mod3_full**
netting_mod3_full <- glmer(total_interaction_T 
                           ~Floral_simpson_index_T 
                           + minutes_since_9am
                           + top2_ratio
                           + Site_type
                           + dm_wind_velocity
                           + (1|site), 
                           data = netting1, family = "poisson")
*Model summary:*
- has 5 predictors and one random effect
- has a significant effect of the floral simpson index (p < 0.001), time category (p < 0.001), top2_ratio (p < 0.001), has a significant effect of dm_wind_velocity (p = 0.014 )
- has a marginal effect of site type (p = 0.051)

*Model assumptions:*
- Over dispersion was detected (p < 0.001) with the performance package check_overdispersion()
    + another model could be used - *negative binomial*
    + the DHARMa qqplot showed the same pattern - dispersion is not normal (p < 0.001)
- the DHARMa qqplot also indicated significant outliers. 
- Correlation is low between predictors (VIF < 2) with the performance package check_collinearity()
- The binned residuals plot from the arm package shows no clear trend.

## A.6.2.2. INTERACTION Netting - NEGATIVE BINOMIAL GLMM

We start again with the full model, but this time we use a negative binomial distribution.

```{r netting_mod1_NB, fig.width=8, fig.height=10}
# full model with interaction counts as response variable and environmental, weather and plant diversity variables as explanatory variables, and site as random effect
# negative binomial distribution

netting_mod1_NB <- glmer.nb(total_interaction_T 
                            ~Floral_simpson_index_T 
                            + minutes_since_9am
                            + top2_ratio
                            + Site_type
                            + dm_wind_velocity
                            + dm_temperature
                            + Plot_Cover_T
                            #+  majority_class
                            #+ urban + agri + grass + snh + forest + water
                            + Days_since_start
                            + (1|site), 
                            data = netting1, 
                            family = nbinom2)

summary(netting_mod1_NB)
parameters(netting_mod1_NB)
  
#check the model
check_model(netting_mod1_NB, verbose = T)

#overdispersion
check_overdispersion(netting_mod1_NB)
#collinearity
check_collinearity(netting_mod1_NB)

# Compute fitted values and Pearson residuals
netting_mod1_NB_vals <- fitted(netting_mod1_NB)
netting_mod1_NB_residuals <- residuals(netting_mod1_NB, type = "pearson")

# Create binned residuals plot
arm::binnedplot(netting_mod1_NB_vals, netting_mod1_NB_residuals)

#DHARMa package - simulate residuals and check model assumptions
netting_mod1_NB_sim_res <- simulateResiduals(fittedModel = netting_mod1_NB)
plot(netting_mod1_NB_sim_res)

plot_model(netting_mod1_NB , type = "est", show.values = TRUE, value.offset = .3)

```

With this model, the assumptions are met (qqplot is normal, no overdispersion, and the residuals are homoscedastic). There are still too many predictors for the amount of data we have, so we will remove the predictors one by one and check the model assumptions after each step.

```{r netting_mod2_NB, fig.width=8, fig.height=10}

# full model with interaction counts as response variable and environmental, weather and plant diversity variables as explanatory variables, and site as random effect
# remove minutes_since_9am (p= 0.376 for netting_mod1_NB)

netting_mod2_NB <- glmer.nb(total_interaction_T 
                           ~Floral_simpson_index_T 
                           #+ minutes_since_9am
                           + top2_ratio
                           + Site_type
                           + dm_wind_velocity
                           + dm_temperature
                           + Plot_Cover_T
                           #+  majority_class
                           #+ urban + agri + grass + snh + forest + water
                           + Days_since_start
                           + (1|site), 
                           data = netting1,
                           family = nbinom2)

summary(netting_mod2_NB)
parameters(netting_mod2_NB)

#check the model
check_model(netting_mod2_NB, verbose = T)
#overdispersion
check_overdispersion(netting_mod2_NB)
#collinearity
check_collinearity(netting_mod2_NB)

# Compute fitted values and Pearson residuals
netting_mod2_NB_vals <- fitted(netting_mod2_NB)
netting_mod2_NB_residuals <- residuals(netting_mod2_NB, type = "pearson")

# Create binned residuals plot
arm::binnedplot(netting_mod2_NB_vals, netting_mod2_NB_residuals)
#DHARMa package - simulate residuals and check model assumptions
netting_mod2_NB_sim_res <- simulateResiduals(fittedModel = netting_mod2_NB)
plot(netting_mod2_NB_sim_res)

```

```{r netting_mod3_NB, fig.width=8, fig.height=10} 
# full model with interaction counts as response variable and environmental, weather and plant diversity variables as explanatory variables, and site as random effect
# remove days since start ( p= 0.441  for netting_mod2_NB)

netting_mod3_NB <- glmer.nb(total_interaction_T 
                           ~Floral_simpson_index_T 
                           #+ minutes_since_9am
                           + top2_ratio
                           + Site_type
                           + dm_wind_velocity
                           + dm_temperature
                           + Plot_Cover_T
                           #+  majority_class
                           #+ urban + agri + grass + snh + forest + water
                           #+ Days_since_start
                           + (1|site), 
                           data = netting1,
                           family = nbinom2)

summary(netting_mod3_NB)
parameters(netting_mod3_NB)

#check the model
check_model(netting_mod3_NB, verbose = T)
#overdispersion
check_overdispersion(netting_mod3_NB)
#collinearity
check_collinearity(netting_mod3_NB)

# Compute fitted values and Pearson residuals
netting_mod3_NB_vals <- fitted(netting_mod3_NB)
netting_mod3_NB_residuals <- residuals(netting_mod3_NB, type = "pearson")

# Create binned residuals plot
arm::binnedplot(netting_mod3_NB_vals, netting_mod3_NB_residuals)
#DHARMa package - simulate residuals and check model assumptions
netting_mod3_NB_sim_res <- simulateResiduals(fittedModel = netting_mod3_NB)
plot(netting_mod3_NB_sim_res)

```

```{r netting_mod4_NB, fig.width=8, fig.height=10}
#  model with interaction counts as response variable and environmental, weather and plant diversity variables as explanatory variables, and site as random effect
# remove dm temperature (p= 0.266  for netting_mod3_NB)
netting_mod4_NB <- glmer.nb(total_interaction_T 
                           ~Floral_simpson_index_T 
                           #+ minutes_since_9am
                           + top2_ratio
                           + Site_type
                           + dm_wind_velocity
                           + Plot_Cover_T
                           #+ dm_temperature
                           #+  majority_class
                           #+ urban + agri + grass + snh + forest + water
                           #+ Days_since_start
                           + (1|site), 
                           data = netting1, 
                           family = nbinom2)

summary(netting_mod4_NB)
parameters(netting_mod4_NB)

#check the model
check_model(netting_mod4_NB, verbose = T)

#overdispersion
check_overdispersion(netting_mod4_NB)
#collinearity
check_collinearity(netting_mod4_NB)

# Compute fitted values and Pearson residuals
netting_mod4_NB_vals <- fitted(netting_mod4_NB)
netting_mod4_NB_residuals <- residuals(netting_mod4_NB, type = "pearson")
# Create binned residuals plot
arm::binnedplot(netting_mod4_NB_vals, netting_mod4_NB_residuals)

#check singularity
isSingular(netting_mod4_NB)
#DHARMa package - simulate residuals and check model assumptions
netting_mod4_NB_sim_res <- simulateResiduals(fittedModel = netting_mod4_NB)
plot(netting_mod4_NB_sim_res)
```

```{r netting_mod5_NB, fig.width=8, fig.height=10}
#removing floral_simpson (p=0.1731 for netting_mod4_NB)
netting_mod5_NB <- glmer.nb(total_interaction_T 
                           #~Floral_simpson_index_T 
                           #+ minutes_since_9am
                           ~ top2_ratio
                           + Site_type
                           + dm_wind_velocity
                           + Plot_Cover_T
                           #+ dm_temperature
                           #+  majority_class
                           #+ urban + agri + grass + snh + forest + water
                           #+ Days_since_start
                           + (1|site), 
                           data = netting1, 
                           family = nbinom2)

summary(netting_mod5_NB)
parameters(netting_mod5_NB)
#check the model
check_model(netting_mod5_NB, verbose = T)
#overdispersion
check_overdispersion(netting_mod5_NB)
#collinearity
check_collinearity(netting_mod5_NB)

# Compute fitted values and Pearson residuals
netting_mod5_NB_vals <- fitted(netting_mod5_NB)
netting_mod5_NB_residuals <- residuals(netting_mod5_NB, type = "pearson")
# Create binned residuals plot
arm::binnedplot(netting_mod5_NB_vals, netting_mod5_NB_residuals)
#DHARMa package - simulate residuals and check model assumptions
netting_mod5_NB_sim_res <- simulateResiduals(fittedModel = netting_mod5_NB)
plot(netting_mod5_NB_sim_res)

```



#### Compare the NB models with the performance package

```{r netting_NB_comp1}
# Compare the models with the performance package
netting_NB_comp1 <- compare_performance(netting_mod1_NB, netting_mod2_NB, netting_mod3_NB, netting_mod4_NB, netting_mod5_NB,  
                                        metrics = c("AICc", "BIC", "R2", "ICC", "RMSE"))

# Print the comparison table
print(netting_NB_comp1)
```

The comparison of the models shows that the model with the lowest AICc and BIC is the fourth model (netting_mod4_NB), which has the lowest AICc and BIC values. 

To confirm this hypothesis we can run a likelihood ratio test to compare the model with and without the random effect. 

#### Likelihood Ratio Test
```{r}
#mod_with_random <- glmer.nb(total_interaction_T ~Floral_simpson_index_T + top2_ratio + Site_type + dm_wind_velocity + (1 | site), data = netting1)
#mod_without_random <- glm.nb(total_interaction_T ~Floral_simpson_index_T + top2_ratio + Site_type + dm_wind_velocity, data = netting1)
mod_without_random <- glm.nb(total_interaction_T 
                           ~Floral_simpson_index_T 
                           #+ minutes_since_9am
                           + top2_ratio
                           + Site_type
                           + dm_wind_velocity
                           + Plot_Cover_T,
                           #+ dm_temperature
                           #+  majority_class
                           #+ urban + agri + grass + snh + forest + water
                           #+ Days_since_start
                           #+ (1|site), 
                           data = netting1)
anova(netting_mod4_NB, mod_without_random)
``` 

We compared the model with random effect to one without a random intercept for site using a likelihood ratio test. The comparison revealed no difference in model fit (χ²(1) = 0.0302, p = 0.862), with almost identical log-likelihoods and deviance. AIC also slightly favored the simpler model. 

#### Visualize the model results

**netting_mod4_NB**
Parameter                  | Log-Mean |   SE |         95% CI |     z |      p
(Intercept)                |     4.04 | 0.07 | [ 3.90,  4.18] | 57.64 | < .001
Floral simpson index T     |    -0.31 | 0.08 | [-0.46, -0.16] | -4.01 | < .001
top2 ratio                 |     0.24 | 0.05 | [ 0.14,  0.34] |  4.67 | < .001
Site type [young_restored] |    -0.36 | 0.11 | [-0.58, -0.14] | -3.25 | 0.001 
dm wind velocity           |    -0.15 | 0.05 | [-0.26, -0.05] | -2.82 | 0.005 
Plot Cover T               |    -0.17 | 0.07 | [-0.31, -0.02] | -2.29 | 0.022 

```{r}
library(sjPlot)
plot_model(netting_mod4_NB, type = "est", show.values = TRUE, value.offset = 0.3)

plot(ggpredict(netting_mod4_NB, terms = "Site_type"))
```

```{r plot netting_mod4_NB predictions}

## wind netting_mod4_NB ---------
# Get the original mean and SD of wind velocity before scaling
wind_mean <- mean(envir_data$dm_wind_velocity, na.rm = TRUE)
wind_sd <- sd(envir_data$dm_wind_velocity, na.rm = TRUE)

# Get predictions on the scaled variable
pred_wind <- ggpredict(netting_mod4_NB , terms = "dm_wind_velocity")

# Unscale the x-axis
pred_wind$x_unscaled <- (pred_wind$x * wind_sd) + wind_mean

# Plot
ggplot(pred_wind, aes(x = x_unscaled, y = predicted)) +
  geom_line(size = 1.2, color = predictor_colors[["dm_wind_velocity"]]) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), 
              fill = alpha(predictor_colors[["dm_wind_velocity"]], 0.5)) +
  labs(
    title = "Netting: Predicted Insect Counts vs Wind Velocity",
    x = "Wind Velocity (km/hour)",
    y = "Predicted Count of insects caught with netting"
  ) +
  theme_minimal()

## top2_ratio netting_mod4_NB ---------
# Get the original mean and SD of top2_ratio before scaling
top2_mean <- mean(envir_data$top2_ratio, na.rm = TRUE)
top2_sd <- sd(envir_data$top2_ratio, na.rm = TRUE)

# Get predictions on the scaled variable
pred_top2 <- ggpredict(netting_mod4_NB , terms = "top2_ratio")

# Unscale the x-axis
pred_top2$x_unscaled <- (pred_top2$x * top2_sd) + top2_mean

# Plot
ggplot(pred_top2, aes(x = x_unscaled, y = predicted)) +
  geom_line(size = 1.2, color = predictor_colors[["top2_ratio"]]) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), 
              fill = alpha(predictor_colors[["top2_ratio"]], 0.5)) + 
  labs(
    title = "Netting: Predicted Insect Counts vs Top 2 Ratio",
    x = "Top 2 Ratio: relative ratio of D. carota and P. sativa",
    y = "Predicted Count of insects caught with netting"
  )

## Floral_simpson_index_T netting_mod4_NB ---------
# Get the original mean and SD of Floral_simpson_index_T before scaling
floral_mean <- mean(envir_data$Floral_simpson_index_T, na.rm = TRUE)
floral_sd <- sd(envir_data$Floral_simpson_index_T, na.rm = TRUE)

# Get predictions on the scaled variable
pred_floral <- ggpredict(netting_mod4_NB , terms = "Floral_simpson_index_T")

# Unscale the x-axis
pred_floral$x_unscaled <- (pred_floral$x * floral_sd) + floral_mean
# Plot
ggplot(pred_floral, aes(x = x_unscaled, y = predicted)) +
  geom_line(size = 1.2, color = predictor_colors[["Floral_simpson_index_T"]]) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), 
              fill = alpha(predictor_colors[["Floral_simpson_index_T"]], 0.5)) + 
  labs(
    title = "Netting: Predicted Insect Counts by Floral Simpson Index",
    x = "Floral Simpson Index",
    y = "Predicted Count of insects caught with netting"
  )

## Plot_Cover_T netting_mod4_NB ---------
# Get the original mean and SD of Plot_Cover_T before scaling
plot_cover_mean <- mean(envir_data$Plot_Cover_T, na.rm = TRUE)
plot_cover_sd <- sd(envir_data$Plot_Cover_T, na.rm = TRUE)

# Get predictions on the scaled variable
pred_plot_cover <- ggpredict(netting_mod4_NB , terms = "Plot_Cover_T")

# Unscale the x-axis
pred_plot_cover$x_unscaled <- (pred_plot_cover$x * plot_cover_sd) + plot_cover_mean
# Plot
ggplot(pred_plot_cover, aes(x = x_unscaled, y = predicted)) +
  geom_line(size = 1.2, color = predictor_colors[["Plot_Cover_T"]]) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), 
              fill = alpha(predictor_colors[["Plot_Cover_T"]],0.5)) +
  labs(
    title = "Netting: Predicted Insect Counts vs Floral Cover",
    x = "Floral Cover: average percentage of flower cover per transect",
    y = "Predicted Count of insects caught with netting"
  )

```


## A.6.2.3. INTERACTION Netting - NB without random effects

```{r netting_mod1_NB_noRE, fig.width=8, fig.height=10}
#  model with interaction counts as response variable and environmental, weather and plant diversity variables as explanatory variables, and site as random effect
# negative binomial distribution

netting_mod1_NB_noRE <- glm.nb(total_interaction_T 
                            ~Floral_simpson_index_T 
                            + minutes_since_9am
                            + top2_ratio
                            + Site_type
                            + dm_wind_velocity
                            + dm_temperature
                            + Plot_Cover_T
                            #+  majority_class
                            #+ urban + agri + grass + snh + forest + water
                            + Days_since_start,
                            data = netting1)

summary(netting_mod1_NB_noRE)
parameters(netting_mod1_NB_noRE)

#check the model
check_model(netting_mod1_NB_noRE, verbose = T)

#overdispersion
check_overdispersion(netting_mod1_NB_noRE)
#collinearity
check_collinearity(netting_mod1_NB_noRE)

# Compute fitted values and Pearson residuals
netting_mod1_NB_noRE_vals <- fitted(netting_mod1_NB_noRE)
netting_mod1_NB_noRE_residuals <- residuals(netting_mod1_NB_noRE, type = "pearson")
# Create binned residuals plot
arm::binnedplot(netting_mod1_NB_noRE_vals, netting_mod1_NB_noRE_residuals)

#DHARMa package - simulate residuals and check model assumptions
netting_mod1_NB_noRE_sim_res <- simulateResiduals(fittedModel = netting_mod1_NB_noRE)
plot(netting_mod1_NB_noRE_sim_res)
```

```{r netting_mod2_NB_noRE, fig.width=8, fig.height=10}
#removing minutes_since_9am (p= 0.370  for netting_mod1_NB_noRE)

netting_mod2_NB_noRE <- glm.nb(total_interaction_T 
                            ~Floral_simpson_index_T 
                            #+ minutes_since_9am
                            + top2_ratio
                            + Site_type
                            + dm_wind_velocity
                            + dm_temperature
                            + Plot_Cover_T
                            #+  majority_class
                            #+ urban + agri + grass + snh + forest + water
                            + Days_since_start,
                            data = netting1)

summary(netting_mod2_NB_noRE)
parameters(netting_mod2_NB_noRE)
```

```{r netting_mod3_NB_noRE, fig.width=8, fig.height=10}
#removing days since start ( p= 0.446  for netting_mod2_NB_noRE)

netting_mod3_NB_noRE <- glm.nb(total_interaction_T 
                            ~Floral_simpson_index_T 
                            #+ minutes_since_9am
                            + top2_ratio
                            + Site_type
                            + dm_wind_velocity
                            + dm_temperature
                            + Plot_Cover_T,
                            #+  majority_class
                            #+ urban + agri + grass + snh + forest + water
                            #+ Days_since_start,
                            data = netting1)

summary(netting_mod3_NB_noRE)
parameters(netting_mod3_NB_noRE)
```

```{r netting_mod4_NB_noRE, fig.width=8, fig.height=10}
#removing temperature (p= 0.258   for netting_mod3_NB_noRE)

netting_mod4_NB_noRE <- glm.nb(total_interaction_T 
                            ~Floral_simpson_index_T 
                            #+ minutes_since_9am
                            + top2_ratio
                            + Site_type
                            + dm_wind_velocity
                            + Plot_Cover_T,
                            #+ dm_temperature
                            #+  majority_class
                            #+ urban + agri + grass + snh + forest + water
                            #+ Days_since_start,
                            data = netting1)

summary(netting_mod4_NB_noRE)
parameters(netting_mod4_NB_noRE)

#check the model
check_model(netting_mod4_NB_noRE, verbose = T)
#overdispersion
check_overdispersion(netting_mod4_NB_noRE)
#collinearity
check_collinearity(netting_mod4_NB_noRE)

# Compute fitted values and Pearson residuals
netting_mod4_NB_noRE_vals <- fitted(netting_mod4_NB_noRE)
netting_mod4_NB_noRE_residuals <- residuals(netting_mod4_NB_noRE, type = "pearson")

# Create binned residuals plot
arm::binnedplot(netting_mod4_NB_noRE_vals, netting_mod4_NB_noRE_residuals)

#DHARMa package - simulate residuals and check model assumptions
netting_mod4_NB_noRE_sim_res <- simulateResiduals(fittedModel = netting_mod4_NB_noRE)
plot(netting_mod4_NB_noRE_sim_res)
```

#### Compare the models with the performance package
```{r netting_NB_noRE_comp1}
# Compare the models with the performance package
netting_NB_noRE_comp1 <- compare_performance(netting_mod1_NB_noRE, netting_mod2_NB_noRE, netting_mod3_NB_noRE, netting_mod4_NB_noRE,  
                                        metrics = c("AICc", "BIC", "R2", "ICC", "RMSE"))
# Print the comparison table
print(netting_NB_noRE_comp1)
```

### Interpretation of Interaction counts modelling

The best model to explain the interaction counts is a glm.nb - Generalized Linear Model with a negative binomial distribution, but without the random effect of site.
The model with the best fit had the following 4 predictors:

|predictor                  |estimate|p-value  |Interpretation                                                                                                   |
|:--------------------------|:-------|:--------|:----------------------------------------------------------------------------------------------------------------|
|top2_ratio                 |0.30    |*<0.001* |Strongly positive effect – Higher dominance of the two most visited flowers is associated with more interactions.|
|Site_type (young_restored) |-0.23   |*0.048*  |Marginally negative effect – Young restored sites have slightly fewer interactions than old/restored ones.       |
|daily wind velocity        |-0.13   |*0.020*  |Negative effect – Windier days are associated with fewer interactions.                                           |
|Floral_simpson_index       |-0.08   |0.159    |Not significant – Floral diversity may have a small negative effect, but it's not statistically clear.           |

The final AIC was 398.72 and the BIC was 409.6, which was relatively better than the other models. In this case, since the number of lines in the data frames corresponds to 9 sites x 5 transects = 45, we couldn't afford to have a model with many more predictors. 

```{r}
#removal of unnecessary objects - all starting with netting_
rm(list = ls(pattern = "^netting_"))
rm(list = ls(pattern = "^plantsimp_"))
```


## A.6.3. Netting data - Species richness

We don't actually have the insects ID to species level, only some groups, so we'll use the the lowest taxa available to do this step. 

```{r netting_richness}
# Create a new data frame with the number of unique families per site
netting_richness <- netting %>%
  group_by(site, transect) %>%
  summarise(unique_taxa = n_distinct(lowest_taxa), .groups = "drop")%>%
  #join the scaled_envir_data 
  left_join(scaled_envir_data, by = c("site"="Site", "transect"="Transect"))

#histogram of unique families, binwidth =1 
netting_richness %>%
  ggplot(aes(x = unique_taxa)) +
  geom_histogram(binwidth = 1, fill = "lightblue", color = "black") +
  labs(title = "Histogram of Unique Families",
       x = "Unique Taxa",
       y = "Count")
```

## A.6.3.1. RICHNESS Netting - POISSON glmer

```{r netting_rich_mod1_full, fig.width=8, fig.height=10}
# full model with family richness as response variable and environmental, weather and plant diversity variables as explanatory variables, and site as random effect
# Poisson distribution

netting_rich_mod1_poiss <- glmer(unique_taxa 
                                 ~Floral_simpson_index_T 
                                 + minutes_since_9am
                                 + top2_ratio
                                 + Site_type
                                 + dm_wind_velocity
                                 + dm_temperature
                                 + Days_since_start
                                 + (1|site), 
                                 data = netting_richness, family = "poisson")

summary(netting_rich_mod1_poiss)
parameters(netting_rich_mod1_poiss)

#check for singularity
performance::check_singularity(netting_rich_mod1_poiss)

#check the model
check_model(netting_rich_mod1_poiss, verbose = T)
#overdispersion
check_overdispersion(netting_rich_mod1_poiss)
#collinearity
check_collinearity(netting_rich_mod1_poiss)

# dharma package - simulate residuals and check model assumptions
netting_rich_mod1_poiss_sim_res <- simulateResiduals(fittedModel = netting_rich_mod1_poiss)
plot(netting_rich_mod1_poiss_sim_res)


```

```{r netting_rich_mod2_poiss, fig.width=8, fig.height=10}
# full model with family richness as response variable and environmental, weather and plant diversity variables as explanatory variables, and site as random effect
# removing site_type (p= 0.947   for netting_rich_mod1_poiss)

netting_rich_mod2_poiss <- glmer(unique_taxa 
                                 ~Floral_simpson_index_T 
                                 + minutes_since_9am
                                 + top2_ratio
                                 #+ Site_type
                                 + dm_wind_velocity
                                 + dm_temperature
                                 + Days_since_start
                                 + (1|site), 
                                 data = netting_richness, family = "poisson")

summary(netting_rich_mod2_poiss)
parameters(netting_rich_mod2_poiss)
#check the model
check_model(netting_rich_mod2_poiss, verbose = T)

#overdispersion
check_overdispersion(netting_rich_mod2_poiss)
#collinearity
check_collinearity(netting_rich_mod2_poiss)

# dharma package - simulate residuals and check model assumptions
netting_rich_mod2_poiss_sim_res <- simulateResiduals(fittedModel = netting_rich_mod2_poiss)
plot(netting_rich_mod2_poiss_sim_res)
```

```{r netting_rich_mod3_poiss, fig.width=8, fig.height=10}
#removing temperature (p= 0.722   for netting_rich_mod2_poiss)

netting_rich_mod3_poiss <- glmer(unique_taxa 
                                 ~Floral_simpson_index_T 
                                 + minutes_since_9am
                                 + top2_ratio
                                 #+ Site_type
                                 + dm_wind_velocity
                                 #+ dm_temperature
                                 + Days_since_start
                                 + (1|site), 
                                 data = netting_richness, family = "poisson")

summary(netting_rich_mod3_poiss)
parameters(netting_rich_mod3_poiss)

#check the model
check_model(netting_rich_mod3_poiss, verbose = T)

#overdispersion
check_overdispersion(netting_rich_mod3_poiss)
#collinearity
check_collinearity(netting_rich_mod3_poiss)
# dharma package - simulate residuals and check model assumptions
netting_rich_mod3_poiss_sim_res <- simulateResiduals(fittedModel = netting_rich_mod3_poiss)
plot(netting_rich_mod3_poiss_sim_res)
```

```{r netting_rich_mod4_poiss, fig.width=8, fig.height=10}
# removing wind velocity (p= 0.674  ,  for netting_rich_mod3_poiss)
netting_rich_mod4_poiss <- glmer(unique_taxa 
                                 ~Floral_simpson_index_T 
                                 + minutes_since_9am
                                 + top2_ratio
                                 #+ Site_type
                                 #+ dm_wind_velocity
                                 #+ dm_temperature
                                 + Days_since_start
                                 + (1|site), 
                                 data = netting_richness, family = "poisson")

summary(netting_rich_mod4_poiss)
parameters(netting_rich_mod4_poiss)

#check the model
check_model(netting_rich_mod4_poiss, verbose = T)
#overdispersion
check_overdispersion(netting_rich_mod4_poiss)
#collinearity
check_collinearity(netting_rich_mod4_poiss)

# dharma package - simulate residuals and check model assumptions
netting_rich_mod4_poiss_sim_res <- simulateResiduals(fittedModel = netting_rich_mod4_poiss)
plot(netting_rich_mod4_poiss_sim_res)

```

```{r netting_rich_mod5_poiss, fig.width=8, fig.height=10}
# removingFloral_simpson_index_T (p= 0.407 ,  for netting_rich_mod4_poiss)
netting_rich_mod5_poiss <- glmer(unique_taxa 
                                 #~Floral_simpson_index_T 
                                 ~ minutes_since_9am
                                 + top2_ratio
                                 #+ Site_type
                                 #+ dm_wind_velocity
                                 #+ dm_temperature
                                 + Days_since_start
                                 + (1|site), 
                                 data = netting_richness, family = "poisson")

summary(netting_rich_mod5_poiss)
parameters(netting_rich_mod5_poiss)

#check the model
check_model(netting_rich_mod5_poiss, verbose = T)
#overdispersion
check_overdispersion(netting_rich_mod5_poiss)
#collinearity
check_collinearity(netting_rich_mod5_poiss)
# dharma package - simulate residuals and check model assumptions
netting_rich_mod5_poiss_sim_res <- simulateResiduals(fittedModel = netting_rich_mod5_poiss)
plot(netting_rich_mod5_poiss_sim_res)
testDispersion(netting_rich_mod5_poiss_sim_res)
```
#### Compare the models with the performance package
```{r netting_rich_pois_comp1}
# Compare the models with the performance package
netting_rich_pois_comp1 <- compare_performance(netting_rich_mod1_poiss, netting_rich_mod2_poiss, netting_rich_mod3_poiss, netting_rich_mod4_poiss, netting_rich_mod5_poiss,  
                                        metrics = c("AICc", "BIC", "R2", "ICC", "RMSE"))

# Print the comparison table
print(netting_rich_pois_comp1)

```

#### Likelihood Ratio Test

Does including the random effect of site significantly improve model fit?

```{r}
mod_with_random <- glmer(unique_taxa 
                                 ~Floral_simpson_index_T 
                                 + minutes_since_9am
                                 + top2_ratio
                                 #+ Site_type
                                 #+ dm_wind_velocity
                                 #+ dm_temperature
                                 + Days_since_start
                                 + (1|site), data = netting_richness)
mod_without_random <- glm(unique_taxa ~ Floral_simpson_index_T 
                                 + minutes_since_9am
                                 + top2_ratio
                                 #+ Site_type
                                 #+ dm_wind_velocity
                                 #+ dm_temperature
                                 + Days_since_start, data = netting_richness)

anova(mod_with_random, mod_without_random)
``` 

A likelihood ratio test comparing models with and without a random intercept for site showed no significant improvement in fit (χ² = 0.98, p = 0.32), so the simpler model was retained.

## A.6.3.2. RICHNESS Netting - POISSON glm no random effects


```{r netting_rich_mod1_noRE_poiss, fig.width=8, fig.height=10}
#  model with family richness as response variable and environmental, weather and plant diversity variables as explanatory variables, and site as random effect

# Poisson distribution
netting_rich_mod1_noRE_poiss <- glm(unique_taxa 
                                     ~Floral_simpson_index_T 
                                     + minutes_since_9am
                                     + top2_ratio
                                     + Site_type
                                     + dm_wind_velocity
                                     + dm_temperature
                                     + Days_since_start,
                                     data = netting_richness, family = "poisson")

summary(netting_rich_mod1_noRE_poiss)
parameters(netting_rich_mod1_noRE_poiss)
#check for singularity
performance::check_singularity(netting_rich_mod1_noRE_poiss)
#check the model
check_model(netting_rich_mod1_noRE_poiss, verbose = T)

#overdispersion
check_overdispersion(netting_rich_mod1_noRE_poiss)
#collinearity
check_collinearity(netting_rich_mod1_noRE_poiss)

# dharma package - simulate residuals and check model assumptions
netting_rich_mod1_noRE_poiss_sim_res <- simulateResiduals(fittedModel = netting_rich_mod1_noRE_poiss)
plot(netting_rich_mod1_noRE_poiss_sim_res)

```

```{r netting_rich_mod2_noRE_poiss, fig.width=8, fig.height=10}
#remove site_type (p= 0.869  for netting_rich_mod1_noRE_poiss)
netting_rich_mod2_noRE_poiss <- glm(unique_taxa 
                                     ~Floral_simpson_index_T 
                                     + minutes_since_9am
                                     + top2_ratio
                                     #+ Site_type
                                     + dm_wind_velocity
                                     + dm_temperature
                                     + Days_since_start,
                                     data = netting_richness, family = "poisson")

summary(netting_rich_mod2_noRE_poiss)
parameters(netting_rich_mod2_noRE_poiss)
#check for singularity
performance::check_singularity(netting_rich_mod2_noRE_poiss)
#check the model
check_model(netting_rich_mod2_noRE_poiss, verbose = T)

#overdispersion
check_overdispersion(netting_rich_mod2_noRE_poiss)
#collinearity
check_collinearity(netting_rich_mod2_noRE_poiss)

# dharma package - simulate residuals and check model assumptions
netting_rich_mod2_noRE_poiss_sim_res <- simulateResiduals(fittedModel = netting_rich_mod2_noRE_poiss)
plot(netting_rich_mod2_noRE_poiss)
```

```{r netting_rich_mod3_noRE_poiss, fig.width=8, fig.height=10}
#removing temperature (p= 0.834   for netting_rich_mod2_noRE_poiss)

netting_rich_mod3_noRE_poiss <- glm(unique_taxa 
                                 ~Floral_simpson_index_T 
                                 + minutes_since_9am
                                 + top2_ratio
                                 #+ Site_type
                                 + dm_wind_velocity
                                 #+ dm_temperature
                                 + Days_since_start, 
                                 data = netting_richness, family = "poisson")

summary(netting_rich_mod3_noRE_poiss)
parameters(netting_rich_mod3_noRE_poiss)

#check the model
check_model(netting_rich_mod3_noRE_poiss, verbose = T)

#overdispersion
check_overdispersion(netting_rich_mod3_noRE_poiss)
#collinearity
check_collinearity(netting_rich_mod3_noRE_poiss)
# dharma package - simulate residuals and check model assumptions
netting_rich_mod3_poiss_sim_res <- simulateResiduals(fittedModel = netting_rich_mod3_noRE_poiss)
plot(netting_rich_mod3_poiss_sim_res)
```

```{r netting_rich_mod4_noRE_poiss, fig.width=8, fig.height=10}
# removing wind velocity (p= 0.674 ,  for netting_rich_mod3_noRE_poiss)
netting_rich_mod4_noRE_poiss <- glm(unique_taxa 
                                 ~Floral_simpson_index_T 
                                 + minutes_since_9am
                                 + top2_ratio
                                 #+ Site_type
                                 #+ dm_wind_velocity
                                 #+ dm_temperature
                                 + Days_since_start, 
                                 data = netting_richness, family = "poisson")
summary(netting_rich_mod4_noRE_poiss)
parameters(netting_rich_mod4_noRE_poiss)
#check the model
check_model(netting_rich_mod4_noRE_poiss, verbose = T)
#overdispersion
check_overdispersion(netting_rich_mod4_noRE_poiss)
#collinearity
check_collinearity(netting_rich_mod4_noRE_poiss)
# dharma package - simulate residuals and check model assumptions
netting_rich_mod4_noRE_poiss_sim_res <- simulateResiduals(fittedModel = netting_rich_mod4_noRE_poiss)
plot(netting_rich_mod4_noRE_poiss_sim_res)

```

```{r netting_rich_mod5_noRE_poiss, fig.width=8, fig.height=10}
# removingFloral_simpson_index_T (p= 0.407    ,  for netting_rich_mod4_noRE_poiss)
netting_rich_mod5_noRE_poiss <- glm(unique_taxa 
                                 #~Floral_simpson_index_T 
                                 ~ minutes_since_9am
                                 + top2_ratio
                                 #+ Site_type
                                 #+ dm_wind_velocity
                                 #+ dm_temperature
                                 + Days_since_start, 
                                 data = netting_richness, family = "poisson")
summary(netting_rich_mod5_noRE_poiss)
parameters(netting_rich_mod5_noRE_poiss)
#check the model
check_model(netting_rich_mod5_noRE_poiss, verbose = T)
#overdispersion
check_overdispersion(netting_rich_mod5_noRE_poiss)
#collinearity
check_collinearity(netting_rich_mod5_noRE_poiss)
# dharma package - simulate residuals and check model assumptions
netting_rich_mod5_noRE_poiss_sim_res <- simulateResiduals(fittedModel = netting_rich_mod5_noRE_poiss)
plot(netting_rich_mod5_noRE_poiss_sim_res)
```

#### Compare the models with the performance package
```{r netting_rich_pois_noRE_comp1}
# Compare the models with the performance package
netting_rich_pois_noRE_comp1 <- compare_performance(netting_rich_mod1_noRE_poiss, netting_rich_mod2_noRE_poiss, netting_rich_mod3_noRE_poiss, netting_rich_mod4_noRE_poiss, netting_rich_mod5_noRE_poiss, metrics = c("AICc", "BIC", "R2", "ICC", "RMSE"))

# Print the comparison table
print(netting_rich_pois_noRE_comp1)
```


## visualize the model results
```{r}

```

```{r}
#removal of unnecessary objects - all starting with netting_
rm(list = ls(pattern = "^netting_"))
```


## A.6.4. SHANNON INDEX - Netting

```{r netting_shannon}
# 1. First, let's aggregate by 'site' and 'transect' and calculate the counts per insect order
netting_agg <- netting %>%
  group_by(site, transect, lowest_taxa) %>%
  summarise(count = n(), .groups = 'drop')  # Count the occurrences of each order

# 2. Pivot the data into a wider format, where each column is an insect order and the values are counts
netting_wide <- netting_agg %>%
  pivot_wider(names_from = lowest_taxa, values_from = count, values_fill = list(count = 0))

# 3. Compute Shannon diversity index for each transect per site using the 'vegan::diversity()' function
# Apply the diversity function to each row, excluding the site and transect identifiers
netting_div <- netting_wide %>%
  rowwise() %>%
  mutate(shannon_diversity = diversity(c_across(3:106), index = "shannon"),
    simpson_diversity = diversity(c_across(3:106), index = "simpson")
    ) %>%
  ungroup()%>%
  #remove all the columns with the counts
  select(-c(3:106)) 

netting_diversity <- netting_div %>%
  #join the scaled_envir_data 
  left_join(scaled_envir_data, by = c("site"="Site", "transect"="Transect"))

netting_div_unscaled <- netting_div %>%
  #join the scaled_envir_data 
  left_join(envir_data, by = c("site"="Site", "transect"="Transect"))

# View the new data frame with Shannon diversity values
head(netting_diversity)
#remove intermediate data frames
rm(netting_agg, netting_wide, netting_div)

#histogram of shannon diversity, binwidth =0.1
netting_diversity %>%
  ggplot(aes(x = shannon_diversity)) +
  geom_histogram(binwidth = 0.05, fill = "lightblue", color = "black") +
  labs(title = "Histogram of Shannon Diversity Index",
       x = "Shannon Diversity Index",
       y = "Count")

#testing the normality of the shannon index
shapiro.test(netting_diversity$shannon_diversity) # p-value = 0.1578, shannon index is normally distributed

#testing skewness
datawizard::describe_distribution(netting_diversity$shannon_diversity)
```

The shannon index is normally distributed (shapiro test: p-value = 0.1578) and has a skewness of -0.23, indicating a slight left skew. The kurtosis is 2.4, indicating a platykurtic distribution (flatter than normal), but fairly normal. Since the shannon index is a continuous variable, we cannot use a poisson model that expects count based integers, but we can use a Gaussian distribution (aka normal distribution) that is better modeled with a linear mixed model (lmm).



## A.6.4.1. SHANNON INDEX Netting - GAUSSIAN glmer

```{r netting_shannon_mod1_gauss, fig.width=8, fig.height=10}
# full model with shannon index as response variable and environmental, weather and plant diversity variables as explanatory variables, and site as random effect
# Poisson distribution
netting_shannon_mod1_gauss <- lmer(shannon_diversity 
                                   ~Floral_simpson_index_T 
                                   + minutes_since_9am
                                   + top2_ratio
                                   + Site_type
                                   + dm_wind_velocity
                                   + dm_temperature
                                   + Days_since_start
                                   + (1 | site), 
                                   data = netting_diversity)
summary(netting_shannon_mod1_gauss)
parameters(netting_shannon_mod1_gauss)
#check for singularity
performance::check_singularity(netting_shannon_mod1_gauss)
#check the model
check_model(netting_shannon_mod1_gauss, verbose = T)

#overdispersion
check_overdispersion(netting_shannon_mod1_gauss)
#collinearity
check_collinearity(netting_shannon_mod1_gauss)

# dharma package - simulate residuals and check model assumptions
netting_shannon_mod1_gauss_sim_res <- simulateResiduals(fittedModel = netting_shannon_mod1_gauss)
plot(netting_shannon_mod1_gauss_sim_res)
```



```{r netting_shannon_mod2_gauss, fig.width=8, fig.height=10}
# full model with shannon index as response variable and environmental, weather and plant diversity variables as explanatory variables, and site as random effect
# removing top2_ratio (p= 0.959  for netting_shannon_mod1_gauss)

netting_shannon_mod2_gauss <- lmer(shannon_diversity 
                                   ~Floral_simpson_index_T 
                                   + minutes_since_9am
                                   #+ top2_ratio
                                   + Site_type
                                   + dm_wind_velocity
                                   + dm_temperature
                                   + Days_since_start
                                   + (1 | site), 
                                   data = netting_diversity)
summary(netting_shannon_mod2_gauss)
parameters(netting_shannon_mod2_gauss)

#check the model
check_model(netting_shannon_mod2_gauss, verbose = T)

#overdispersion
check_overdispersion(netting_shannon_mod2_gauss)
#collinearity
check_collinearity(netting_shannon_mod2_gauss)
# dharma package - simulate residuals and check model assumptions
netting_shannon_mod2_gauss_sim_res <- simulateResiduals(fittedModel = netting_shannon_mod2_gauss)
plot(netting_shannon_mod2_gauss_sim_res)


```

```{r netting_shannon_mod3_gauss, fig.width=8, fig.height=10}
#remove site_type (p= 0.875   for netting_shannon_mod2_gauss)
netting_shannon_mod3_gauss <- lmer(shannon_diversity 
                                   ~Floral_simpson_index_T 
                                   + minutes_since_9am
                                   #+ top2_ratio
                                   #+ Site_type
                                   + dm_wind_velocity
                                   + dm_temperature
                                   + Days_since_start
                                   + (1 | site), 
                                   data = netting_diversity)

summary(netting_shannon_mod3_gauss)
parameters(netting_shannon_mod3_gauss)
#check the model
check_model(netting_shannon_mod3_gauss, verbose = T)
#overdispersion
check_overdispersion(netting_shannon_mod3_gauss)
#collinearity
check_collinearity(netting_shannon_mod3_gauss)
# dharma package - simulate residuals and check model assumptions
netting_shannon_mod3_gauss_sim_res <- simulateResiduals(fittedModel = netting_shannon_mod3_gauss)
plot(netting_shannon_mod3_gauss_sim_res)
```

```{r netting_shannon_mod4_gauss, fig.width=8, fig.height=10}
#remove floral simpson index (p= 0.459    for netting_shannon_mod3_gauss)
netting_shannon_mod4_gauss <- lmer(shannon_diversity 
                                   #~Floral_simpson_index_T 
                                   ~ minutes_since_9am
                                   #+ top2_ratio
                                   #+ Site_type
                                   + dm_wind_velocity
                                   + dm_temperature
                                   + Days_since_start
                                   + (1 | site), 
                                   data = netting_diversity)
summary(netting_shannon_mod4_gauss)
parameters(netting_shannon_mod4_gauss)
#check the model
check_model(netting_shannon_mod4_gauss, verbose = T)
#overdispersion
check_overdispersion(netting_shannon_mod4_gauss)
#collinearity
check_collinearity(netting_shannon_mod4_gauss)
# dharma package - simulate residuals and check model assumptions
netting_shannon_mod4_gauss_sim_res <- simulateResiduals(fittedModel = netting_shannon_mod4_gauss)
plot(netting_shannon_mod4_gauss_sim_res)

```


```{r netting_shannon_mod5_gauss, fig.width=8, fig.height=10}
#remove temperature (p= dm temperature 0.344  for netting_shannon_mod4_gauss)
netting_shannon_mod5_gauss <- lmer(shannon_diversity 
                                   #~Floral_simpson_index_T 
                                   ~ minutes_since_9am
                                   #+ top2_ratio
                                   #+ Site_type
                                   + dm_wind_velocity
                                   #+ dm_temperature
                                   + Days_since_start
                                   + (1 | site), 
                                   data = netting_diversity)

summary(netting_shannon_mod5_gauss)
parameters(netting_shannon_mod5_gauss)
#check the model
check_model(netting_shannon_mod5_gauss, verbose = T)
#overdispersion
check_overdispersion(netting_shannon_mod5_gauss)
#collinearity
check_collinearity(netting_shannon_mod5_gauss)
# dharma package - simulate residuals and check model assumptions
netting_shannon_mod5_gauss_sim_res <- simulateResiduals(fittedModel = netting_shannon_mod5_gauss)
plot(netting_shannon_mod5_gauss_sim_res)
```


#### Compare the models with the performance package
```{r netting_shannon_gauss_comp1}
# Compare the models with the performance package
netting_shannon_gauss_comp1 <- compare_performance(netting_shannon_mod1_gauss, netting_shannon_mod2_gauss, netting_shannon_mod3_gauss, netting_shannon_mod4_gauss, netting_shannon_mod5_gauss,  
                                        metrics = c("AICc", "BIC", "R2", "ICC", "RMSE"))
# Print the comparison table
print(netting_shannon_gauss_comp1)
```
#### visualize the model results
```{r}
```

A linear mixed-effects model was used to investigate the effects of time of day, wind velocity, and seasonality on insect Shannon diversity across sites. Shannon diversity was significantly influenced by both time of day and sampling date. Specifically, diversity declined later in the day (β = -0.08, p = 0.042) and as the season progressed (β = -0.24, p < 0.001). Wind velocity showed a positive but non-significant relationship with diversity (β = 0.07, p = 0.221). Random effects revealed moderate variability in baseline diversity across sites (SD = 0.11). 

## A.6.5. SIMPSON INDEX - Netting

The simpson index per transect was calculated in the previous section and is stored in the netting_diversity data frame.

```{r netting_simpson}
#histogram of simpson diversity, binwidth =0.01
netting_diversity %>%
  ggplot(aes(x = simpson_diversity)) +
  geom_histogram(binwidth = 0.01, fill = "lightblue", color = "black") +
  labs(title = "Histogram of Simpson Diversity Index",
       x = "Simpson Diversity Index",
       y = "Count")

#testing the normality of the simpson index
shapiro.test(netting_diversity$simpson_diversity) # p-value = 0.0034, simpson index is not normally distributed

#testing skewness
datawizard::describe_distribution(netting_diversity$simpson_diversity)
```
The simpson index is not normally distributed (shapiro test: p-value = 0.0034) and has a skewness of -0.23, indicating a slight left skew. The kurtosis is 2.4, indicating a platykurtic distribution (flatter than normal), but fairly normal. In this case, where simpson index is bounded between 0 and 1, we can use a beta regression or a binomial regression with a logit link function. 

## A.6.5.1. SIMPSON INDEX Netting - BETA glmer

```{r netting_simpson_mod1_beta, fig.width=8, fig.height=10}
#library(brms)
library(betareg)

netting_simpson_mod1_beta <- glmmTMB(simpson_diversity 
                                     ~Floral_simpson_index_T 
                                     + minutes_since_9am 
                                     + dm_wind_velocity
                                     + top2_ratio
                                     + Site_type
                                     + dm_temperature
                                     + Days_since_start 
                                     + (1 | site),
                                     family = beta_family(),  
                                     data = netting_diversity)
summary(netting_simpson_mod1_beta)
parameters(netting_simpson_mod1_beta)
#check for singularity
performance::check_singularity(netting_simpson_mod1_beta)
#check the model
check_model(netting_simpson_mod1_beta, verbose = T)
#overdispersion
check_overdispersion(netting_simpson_mod1_beta)
#collinearity
check_collinearity(netting_simpson_mod1_beta)

# dharma package - simulate residuals and check model assumptions
netting_simpson_mod1_beta_sim_res <- simulateResiduals(fittedModel = netting_simpson_mod1_beta)
plot(netting_simpson_mod1_beta_sim_res)

```

```{r netting_simpson_mod2_beta, fig.width=8, fig.height=10}
# REMOVE top2_ratio (p= 0.922  for netting_simpson_mod1_beta)
netting_simpson_mod2_beta <- glmmTMB(simpson_diversity 
                                     ~Floral_simpson_index_T 
                                     + minutes_since_9am 
                                     + dm_wind_velocity
                                     #+ top2_ratio
                                     + Site_type
                                     + dm_temperature
                                     + Days_since_start 
                                     + (1 | site),
                                     family = beta_family(),  
                                     data = netting_diversity)

summary(netting_simpson_mod2_beta)
parameters(netting_simpson_mod2_beta)

#check for singularity
performance::check_singularity(netting_simpson_mod2_beta)
#check the model
check_model(netting_simpson_mod2_beta, verbose = T)

#overdispersion
check_overdispersion(netting_simpson_mod2_beta)
#collinearity
check_collinearity(netting_simpson_mod2_beta)
# dharma package - simulate residuals and check model assumptions
netting_simpson_mod2_beta_sim_res <- simulateResiduals(fittedModel = netting_simpson_mod2_beta)
plot(netting_simpson_mod2_beta_sim_res)
```

```{r netting_simpson_mod3_beta, fig.width=8, fig.height=10}
#remove temperature (p= 0.5915  for netting_simpson_mod2_beta)

netting_simpson_mod3_beta <- glmmTMB(simpson_diversity 
                                     ~Floral_simpson_index_T 
                                     + minutes_since_9am 
                                     + dm_wind_velocity
                                     #+ top2_ratio
                                     + Site_type
                                     #+ dm_temperature
                                     + Days_since_start 
                                     + (1 | site),
                                     family = beta_family(),  
                                     data = netting_diversity)
summary(netting_simpson_mod3_beta)
parameters(netting_simpson_mod3_beta)
#check for singularity
performance::check_singularity(netting_simpson_mod3_beta)
#check the model
check_model(netting_simpson_mod3_beta, verbose = T)
#overdispersion
check_overdispersion(netting_simpson_mod3_beta)
#collinearity
check_collinearity(netting_simpson_mod3_beta)
# dharma package - simulate residuals and check model assumptions
netting_simpson_mod3_beta_sim_res <- simulateResiduals(fittedModel = netting_simpson_mod3_beta)
plot(netting_simpson_mod3_beta_sim_res)
```

```{r netting_simpson_mod4_beta, fig.width=8, fig.height=10}
#remove floral simpson index (p= 0.556        for netting_simpson_mod3_beta)
netting_simpson_mod4_beta <- glmmTMB(simpson_diversity 
                                     #~Floral_simpson_index_T 
                                     ~ minutes_since_9am 
                                     + dm_wind_velocity
                                     #+ top2_ratio
                                     + Site_type
                                     #+ dm_temperature
                                     + Days_since_start 
                                     + (1 | site),
                                     family = beta_family(),  
                                     data = netting_diversity)
summary(netting_simpson_mod4_beta)
parameters(netting_simpson_mod4_beta)
#check for singularity
performance::check_singularity(netting_simpson_mod4_beta)
#check the model
check_model(netting_simpson_mod4_beta, verbose = T)
#overdispersion
check_overdispersion(netting_simpson_mod4_beta)
#collinearity
check_collinearity(netting_simpson_mod4_beta)
# dharma package - simulate residuals and check model assumptions
netting_simpson_mod4_beta_sim_res <- simulateResiduals(fittedModel = netting_simpson_mod4_beta)
plot(netting_simpson_mod4_beta_sim_res)

```

```{r netting_simpson_mod5_beta, fig.width=8, fig.height=10}
#REMOVE SITE TYPE (p= 0.1266 for netting_simpson_mod4_beta)

netting_simpson_mod5_beta <- glmmTMB(simpson_diversity 
                                     #~Floral_simpson_index_T 
                                     ~ minutes_since_9am 
                                     + dm_wind_velocity
                                     #+ top2_ratio
                                     #+ Site_type
                                     #+ dm_temperature
                                     + Days_since_start 
                                     + (1 | site),
                                     family = beta_family(),  
                                     data = netting_diversity)
summary(netting_simpson_mod5_beta)
parameters(netting_simpson_mod5_beta)
#check for singularity
performance::check_singularity(netting_simpson_mod5_beta)
#check the model
check_model(netting_simpson_mod5_beta, verbose = T)
#overdispersion
check_overdispersion(netting_simpson_mod5_beta)
#collinearity
check_collinearity(netting_simpson_mod5_beta)
# dharma package - simulate residuals and check model assumptions
netting_simpson_mod5_beta_sim_res <- simulateResiduals(fittedModel = netting_simpson_mod5_beta)
plot(netting_simpson_mod5_beta_sim_res)

```

#### Compare the models with the performance package
```{r netting_simpson_beta_comp1}
# Compare the models with the performance package
netting_simpson_beta_comp1 <- compare_performance(netting_simpson_mod1_beta, netting_simpson_mod2_beta, netting_simpson_mod3_beta, netting_simpson_mod4_beta, netting_simpson_mod5_beta, metrics = c("AICc", "BIC", "R2", "ICC", "RMSE"))

# Print the comparison table
print(netting_simpson_beta_comp1)
```
### Interpretation of the model results
The third model is the last one that meets the assumptions of the model (residuals vs fitted from the dharma package). The model is a beta regression with a logit link function, which is appropriate for bounded continuous data like the Simpson index. The model includes floral Simpson index (p=0.556), time of day (p=0.030), wind velocity (p=0.058), site type (p=0.139) and sampling date (p<.001) as fixed effects, and site as a random effect. 

|Parameter                  | Coefficient |   SE |         95% CI |   z   |  p    |
|---------------------------|-------------|------|----------------|-------|-------|
|(Intercept)                |        1.78 | 0.06 | [ 1.66,  1.91] | 28.63 | <.001 |
|Floral simpson index       |        0.03 | 0.04 | [-0.06,  0.11] |  0.59 | 0.556 |
|Time category              |       -0.11 | 0.05 | [-0.21, -0.01] | -2.17 | 0.030 |
|dm wind velocity           |        0.10 | 0.05 | [ 0.00,  0.20] |  1.89 | 0.058 |
|Site type [young_restored] |        0.14 | 0.10 | [-0.05,  0.34] |  1.48 | 0.139 |
|Days since start           |       -0.29 | 0.06 | [-0.40, -0.17] | -5.01 | <.001 |

Intercept	1.78	<0.001	The expected log-odds of Simpson diversity when all predictors are at their reference or zero values. Intercepts are usually not interpreted deeply in models like this unless all predictors are centered.
Floral simpson index	0.03	0.556	- Not significant. A weak, non-significant positive association with insect diversity. So floral diversity doesn’t predict insect diversity in this model.
Time category	-0.11	0.030	- significant negative effect. Insect Simpson diversity decreases throughout the day. For each half-hour increase, the log-odds of diversity decreases slightly.
dm wind velocity	0.10	0.058	- Marginally significant (p ≈ 0.06). Suggests that insect diversity might increase with wind speed, but evidence is weak. Might become clearer with more data.
Site type: young_restored	0.14	0.139	- not significant. Insect diversity tends to be slightly higher in young restored sites compared to the reference category, but this difference isn’t statistically supported.
Days since start	-0.29	<0.001	Strong negative effect. Simpson diversity significantly declines as the season progresses. Could suggest seasonal shifts in community structure or flowering phenology.

Insect diversity tends to decrease during the day – possibly due to heat, pollinator activity cycles, or environmental stress.
Insect diversity also declines later in the season – this is quite typical as certain species finish their active period or floral resources decline.
Site restoration status and floral diversity surprisingly didn't explain much variation here. It's possible that insect diversity is responding to other unmeasured variables (e.g. habitat structure, microclimate, nectar availability).

#### visualize the model results

```{r}
ggplot(netting_div_unscaled, aes(x = minutes_since_9am, y = simpson_diversity)) +
  geom_smooth(method = "lm", color = "#55804DFF", se = TRUE, fill="#A4B591FF") +
  geom_jitter(width = 0.2, height = 0, alpha = 0.6, color = "#D9565CFF", size = 2) +
  labs(
    title = "Observed Simpson Diversity across Time of Day",
    x = "Time (9am to 5pm)",
    y = "Simpson Diversity"
  ) +
  #facet with day since start
  #facet_wrap(~Days_since_start) +
  theme_minimal(base_size = 14)

ggplot(netting_div_unscaled, aes(x = Days_since_start, y = simpson_diversity)) +
  geom_smooth(method = "lm", color = "#EEB479FF", se = TRUE, fill="#EFEFCFFF") +
  geom_point(alpha = 0.7, color = "#D9565CFF", size = 2) +

  #change color of Confidence intervall around lm to #D55E00
  

  labs(
    title = "Observed Simpson Diversity over Time",
    x = "Days Since Start",
    y = "Simpson Diversity"
  ) +
  theme_minimal(base_size = 14)

ggplot(netting_div_unscaled, aes(x = dm_wind_velocity, y = simpson_diversity)) +
  geom_smooth(method = "lm", color = "#009B9EFF", se = TRUE,fill="#A7D3D4FF") +
  geom_point(alpha = 0.7, color = "#D9565CFF", size = 2) +
  labs(
    title = "Observed Simpson Diversity vs Wind Velocity",
    x = "Mean Wind Velocity (during transect)",
    y = "Simpson Diversity"
  ) +
  theme_minimal(base_size = 14)


```
```{r}  
#removal of unnecessary objects - all starting with netting_
rm(list = ls(pattern = "^netting_"))
```  

## B. PLATFORM CAMERAS

At first, I tried to also have the minutes_since_9am variable for platform cameras, only to realize that it is not relevant in this specific case. We will be able to look at the time at which each insect is captured since it is recorded in the filename of the image, and the starting time of the camera is not a ecologically relevant variable. 

### B.1. Counts - Platform cameras

```{r platform_counts}  
# count of insect per transect per site
platty <- platform_camera %>%
  group_by(location, transect) %>%
  summarise(count = n(), .groups = 'drop')  # Count the occurrence

#join the  specific envir_data already in platform_camera1
platform_counts <- platty %>%
  left_join(platform_camera1, by = c("location", "transect"))%>%
  #REMOVE EXTRA COLUMNS "ID" "Site_Tn" "det_conf_mean" "track_ID_imgs" "top1_imgs" "top1_prob_mean" "top1_prob_weighted"
  select(-c(start_time, top1,ID, Site_Tn, det_conf_mean, track_ID_imgs, top1_imgs, top1_prob_mean, top1_prob_weighted)) %>%
  #keep only unique rows
  distinct()
  #scale numerical

#histogram of counts, binwidth =0.01
platform_counts %>%
  ggplot(aes(x = count)) +
  geom_histogram(binwidth = 1, fill = "lightblue", color = "black") +
  labs(title = "Histogram of Insect Counts",
       x = "Insect Count",
       y = "Count")
rm(platty)
```

Since this is count data, it is going to be modeled with a Poisson distribution. However, if the data is overdispersed (variance > mean), we will use a negative binomial distribution instead. 


### B.1.1. Counts - Platform cameras - POISSON glmer (offset: recording time)

```{r platform_count_mod1_poiss, fig.width=8, fig.height=10}
# full model with insect counts as response variable and environmental, weather and plant diversity variables as explanatory variables, and site as random effect
# Poisson distribution
platform_count_mod1_poiss <- glmmTMB(count 
                                     ~ Floral_simpson_index_T
                                     #+ minutes_since_9am
                                     + top2_ratio
                                     + Site_type
                                     + dm_wind_velocity
                                     + dm_temperature
                                     + Days_since_start
                                     + (1 | location),
                                     offset = log(rec_time_min),
                                     family = poisson(),
                                     data = platform_counts)

summary(platform_count_mod1_poiss)
parameters(platform_count_mod1_poiss)
#check for singularity
performance::check_singularity(platform_count_mod1_poiss)
#check the model
check_model(platform_count_mod1_poiss, verbose = T)

#overdispersion
check_overdispersion(platform_count_mod1_poiss)
#collinearity
check_collinearity(platform_count_mod1_poiss)
# dharma package - simulate residuals and check model assumptions
platform_count_mod1_poiss_sim_res <- simulateResiduals(fittedModel = platform_count_mod1_poiss)
plot(platform_count_mod1_poiss_sim_res)

```

There is overdispersion in the model, so we will use a negative binomial distribution instead of poisson distribution. 

```{r platform_count_mod1_nb, fig.width=8, fig.height=10}
# full model with insect counts as response variable and environmental, weather and plant diversity variables as explanatory variables, and site as random effect
# Negative binomial distribution

platform_count_mod1_nb <- glmmTMB(count 
                                   ~ Floral_simpson_index_T 
                                   + top2_ratio
                                   + Site_type
                                   + dm_wind_velocity
                                   + dm_temperature
                                   + Days_since_start
                                   + (1 | location),
                                   offset = log(rec_time_min),
                                   family = nbinom2(),
                                   data = platform_counts)
summary(platform_count_mod1_nb)
parameters(platform_count_mod1_nb)
#check for singularity
performance::check_singularity(platform_count_mod1_nb)
#check the model
check_model(platform_count_mod1_nb, verbose = T)
#overdispersion
check_overdispersion(platform_count_mod1_nb)
#collinearity
check_collinearity(platform_count_mod1_nb)
# dharma package - simulate residuals and check model assumptions
platform_count_mod1_nb_sim_res <- simulateResiduals(fittedModel = platform_count_mod1_nb)
plot(platform_count_mod1_nb_sim_res)
```

```{r platform_count_mod2_nb, fig.width=8, fig.height=10}
# removing top2_ratio (p= 0.978    for platform_count_mod1_nb)

platform_count_mod2_nb <- glmmTMB(count 
                                   ~ Floral_simpson_index_T 
                                   #+ top2_ratio
                                   + Site_type
                                   + dm_wind_velocity
                                   + dm_temperature
                                   + Days_since_start
                                   + (1 | location),
                                   offset = log(rec_time_min),
                                   family = nbinom2(),
                                   data = platform_counts)
summary(platform_count_mod2_nb)
parameters(platform_count_mod2_nb)
#check for singularity
performance::check_singularity(platform_count_mod2_nb)
#check the model
check_model(platform_count_mod2_nb, verbose = T)
#overdispersion
check_overdispersion(platform_count_mod2_nb)
#collinearity
check_collinearity(platform_count_mod2_nb)
# dharma package - simulate residuals and check model assumptions
platform_count_mod2_nb_sim_res <- simulateResiduals(fittedModel = platform_count_mod2_nb)
plot(platform_count_mod2_nb_sim_res)
```

```{r platform_count_mod3_nb, fig.width=8, fig.height=10}
# removing site_type start (p= 0.915     for platform_count_mod2_nb)
platform_count_mod3_nb <- glmmTMB(count 
                                   ~ Floral_simpson_index_T 
                                   #+ top2_ratio
                                   #+ Site_type
                                   + dm_wind_velocity
                                   + dm_temperature
                                   + Days_since_start
                                   + (1 | location),
                                   offset = log(rec_time_min),
                                   family = nbinom2(),
                                   data = platform_counts)
summary(platform_count_mod3_nb)
parameters(platform_count_mod3_nb)
#check the model
check_model(platform_count_mod3_nb, verbose = T)
  
#overdispersion
check_overdispersion(platform_count_mod3_nb)
#collinearity
check_collinearity(platform_count_mod3_nb)
# dharma package - simulate residuals and check model assumptions
platform_count_mod3_nb_sim_res <- simulateResiduals(fittedModel = platform_count_mod3_nb)
plot(platform_count_mod3_nb_sim_res)
```

```{r platform_count_mod4_nb, fig.width=8, fig.height=10}
#removing floral simpson index (p= 0.822   for platform_count_mod3_nb)
platform_count_mod4_nb <- glmmTMB(count 
                                   #~ Floral_simpson_index_T 
                                   #+ top2_ratio
                                   #+ Site_type
                                   ~ dm_wind_velocity
                                   + dm_temperature
                                   + Days_since_start
                                   + (1 | location),
                                   offset = log(rec_time_min),
                                   family = nbinom2(),
                                   data = platform_counts)

summary(platform_count_mod4_nb)
parameters(platform_count_mod4_nb)
#check the model
check_model(platform_count_mod4_nb, verbose = T)
#overdispersion
check_overdispersion(platform_count_mod4_nb)
#collinearity
check_collinearity(platform_count_mod4_nb)
# dharma package - simulate residuals and check model assumptions
platform_count_mod4_nb_sim_res <- simulateResiduals(fittedModel = platform_count_mod4_nb)
plot(platform_count_mod4_nb_sim_res)

```

```{r platform_count_mod5_nb, fig.width=8, fig.height=10}
#removing days since start (p= 0.443   for platform_count_mod4_nb)
platform_count_mod5_nb <- glmmTMB(count 
                                   #~ Floral_simpson_index_T 
                                   #+ top2_ratio
                                   #+ Site_type
                                   ~ dm_wind_velocity
                                   + dm_temperature
                                   #+ Days_since_start
                                   + (1 | location),
                                   offset = log(rec_time_min),
                                   family = nbinom2(),
                                   data = platform_counts)

summary(platform_count_mod5_nb)
parameters(platform_count_mod5_nb)
#check the model
check_model(platform_count_mod5_nb, verbose = T)
#overdispersion
check_overdispersion(platform_count_mod5_nb)
#collinearity
check_collinearity(platform_count_mod5_nb)
# dharma package - simulate residuals and check model assumptions
platform_count_mod5_nb_sim_res <- simulateResiduals(fittedModel = platform_count_mod5_nb)
plot(platform_count_mod5_nb_sim_res)
```



##### Compare the models with the performance package
```{r platform_count_nb_comp1}
# Compare the models with the performance package
platform_count_nb_comp1 <- compare_performance(platform_count_mod1_nb, platform_count_mod2_nb, platform_count_mod3_nb, platform_count_mod4_nb,platform_count_mod5_nb, metrics = c("AICc", "BIC", "R2", "ICC", "RMSE"))
# Print the comparison table
print(platform_count_nb_comp1)
```
The fourth model is the best one because it has lower AICc and BIC values, but still reaches the model's assumptions (dharma plot of fitted vs residual looks ok, no overdispersion, etc). 

#### Interpretation of the model results

#### visualize the model results

```{r}
plot_model(platform_count_mod1_nb , type = "est", show.values = TRUE, value.offset = .3)
plot_model(platform_count_mod4_nb , type = "est", show.values = TRUE, value.offset = .3)

```


```{r platform count/temperature}
# Get the original mean and SD of wind velocity before scaling
temp_mean <- mean(envir_data$dm_temperature, na.rm = TRUE)
temp_sd <- sd(envir_data$dm_temperature, na.rm = TRUE)

# Get predictions on the scaled variable
pred_temp <- ggpredict(platform_count_mod5_nb , terms = "dm_temperature")

# Unscale the x-axis
pred_temp$x_unscaled <- (pred_temp$x * temp_sd) + temp_mean

# Plot
ggplot(pred_temp, aes(x = x_unscaled, y = predicted)) +
  geom_line(size = 1.2) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = 0.2) +
  labs(
    title = "Predicted Insect Count by mean daily Temperature",
    x = "Temperature (°C)",
    y = "Predicted Count on platform cameras"
  ) +
  theme_minimal()
```

```{r platform count/wind}
# Get the original mean and SD of wind velocity before scaling
wind_mean <- mean(envir_data$dm_wind_velocity, na.rm = TRUE)
wind_sd <- sd(envir_data$dm_wind_velocity, na.rm = TRUE)

# Get predictions on the scaled variable
pred_wind <- ggpredict(platform_count_mod5_nb , terms = "dm_wind_velocity")

# Unscale the x-axis
pred_wind$x_unscaled <- (pred_wind$x * wind_sd) + wind_mean

# Plot
ggplot(pred_wind, aes(x = x_unscaled, y = predicted)) +
  geom_line(size = 1.2) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = 0.2) +
  labs(
    title = "Predicted Insect Counts by Wind Velocity",
    x = "Wind Velocity (km/hour)",
    y = "Predicted Count on platform cameras"
  ) +
  theme_minimal()+
  #add original data points
  #geom_jitter(data = platform_counts_unscaled, aes(x = dm_wind_velocity, y = count), width = 0.2, height = 0, alpha = 0.6, color = "#D9565CFF", size = 2) +
  theme_minimal(base_size = 14)
```  

```{r}
#remove all objects starting with platform_count_
rm(list = ls(pattern = "^platform_count_"))
```


### B.2. RICHNESS - Platform cameras

```{r platform_richness}
# diversity of insects per transect per site
platty <- platform_camera %>%
  group_by(location, transect) %>%
  summarise(richness = n_distinct(top1), .groups = 'drop')  # Count the occurrences of each order

#join the scaled_envir_data
platform_richness <- platty %>%
  left_join(platform_camera1, by = c("location", "transect"))%>%
  #REMOVE EXTRA COLUMNS "ID" "Site_Tn" "det_conf_mean" "track_ID_imgs" "top1_imgs" "top1_prob_mean" "top1_prob_weighted"
  select(-c(top1,ID, Site_Tn, det_conf_mean, track_ID_imgs, top1_imgs, top1_prob_mean, top1_prob_weighted,start_time)) %>%
  #keep only unique rows
  distinct()

#histogram of richness
platform_richness %>%
  ggplot(aes(x = richness)) +
  geom_histogram(binwidth = 1, fill = "lightblue", color = "black") +
  labs(title = "Histogram of Insect Richness",
       x = "Insect Richness",
       y = "Count")

#testing the normality of the shannon index
shapiro.test(platform_richness$richness) # p-value = 0.4406, shannon index is normally distributed

#testing skewness
datawizard::describe_distribution(platform_richness$richness)
```

The data for richness captured with the platform cameras is normally distributed (shapiro test: p-value = 0.4406) and has a skewness of 0.12, indicating a slight right skew. The kurtosis is -0.67, indicating a platykurtic distribution (flatter than normal), but fairly normal.

## B.2.1. RICHNESS - Platform cameras - POISSON glmer 
```{r platform_richness_mod1_poiss, fig.width=8, fig.height=10}
# full model with insect richness as response variable and environmental, weather and plant diversity variables as explanatory variables, and site as random effect
# Poisson distribution

platform_richness_mod1_poiss <- glmmTMB(richness 
                                        ~ Floral_simpson_index_T 
                                        + rec_time_min
                                        + top2_ratio
                                        + Site_type
                                        + dm_wind_velocity
                                        + dm_temperature
                                        + Days_since_start
                                        + (1 | location),
                                        family = poisson(),
                                        data = platform_richness)
summary(platform_richness_mod1_poiss)
parameters(platform_richness_mod1_poiss)
#check for singularity
performance::check_singularity(platform_richness_mod1_poiss)
#check the model
check_model(platform_richness_mod1_poiss, verbose = T)
#overdispersion
check_overdispersion(platform_richness_mod1_poiss)
#collinearity
check_collinearity(platform_richness_mod1_poiss)
# dharma package - simulate residuals and check model assumptions
platform_richness_mod1_poiss_sim_res <- simulateResiduals(fittedModel = platform_richness_mod1_poiss)
plot(platform_richness_mod1_poiss_sim_res)
```

The Poisson model seems to fit this data well, there is no sign of overdispersion and the correlation between predictors is low. 

```{r platform_richness_mod2_poiss, fig.width=8, fig.height=10}
#remove top2 ratio (p= 0.652    for platform_richness_mod1_poiss)

platform_richness_mod2_poiss <- glmmTMB(richness 
                                        ~ Floral_simpson_index_T 
                                        # top2_ratio
                                        + rec_time_min
                                        + Site_type
                                        + dm_wind_velocity
                                        + dm_temperature
                                        + Days_since_start
                                        + (1 | location),
                                        family = poisson(),
                                        data = platform_richness)
summary(platform_richness_mod2_poiss)
parameters(platform_richness_mod2_poiss)
#check for singularity
performance::check_singularity(platform_richness_mod2_poiss)
#check the model
check_model(platform_richness_mod2_poiss, verbose = T)
#overdispersion
check_overdispersion(platform_richness_mod2_poiss)
#collinearity
check_collinearity(platform_richness_mod2_poiss)
# dharma package - simulate residuals and check model assumptions
platform_richness_mod2_poiss_sim_res <- simulateResiduals(fittedModel = platform_richness_mod2_poiss)
plot(platform_richness_mod2_poiss_sim_res)
```

```{r platform_richness_mod3_poiss, fig.width=8, fig.height=10}
#remove floral simpson (p= 0.624     for platform_richness_mod2_poiss)
platform_richness_mod3_poiss <- glmmTMB(richness 
                                        #~ Floral_simpson_index_T 
                                        #+ top2_ratio
                                        ~ Site_type
                                        + rec_time_min
                                        + dm_wind_velocity
                                        + dm_temperature
                                        + Days_since_start
                                        + (1 | location),
                                        family = poisson(),
                                        data = platform_richness)

summary(platform_richness_mod3_poiss)
parameters(platform_richness_mod3_poiss)
#check for singularity
performance::check_singularity(platform_richness_mod3_poiss)
#check the model
check_model(platform_richness_mod3_poiss, verbose = T)
#overdispersion
check_overdispersion(platform_richness_mod3_poiss)
#collinearity
check_collinearity(platform_richness_mod3_poiss)
# dharma package - simulate residuals and check model assumptions
platform_richness_mod3_poiss_sim_res <- simulateResiduals(fittedModel = platform_richness_mod3_poiss)
plot(platform_richness_mod3_poiss_sim_res)
```

```{r platform_richness_mod4_poiss, fig.width=8, fig.height=10}
#remove rec_time_min (p= 0.588  for platform_richness_mod3_poiss)
platform_richness_mod4_poiss <- glmmTMB(richness 
                                        #~ Floral_simpson_index_T 
                                        #+ top2_ratio
                                        #+ rec_time_min
                                        ~ dm_wind_velocity
                                        + Site_type
                                        + dm_temperature
                                        + Days_since_start
                                        + (1 | location),
                                        family = poisson(),
                                        data = platform_richness)
summary(platform_richness_mod4_poiss)
parameters(platform_richness_mod4_poiss)
#check for singularity
performance::check_singularity(platform_richness_mod4_poiss)
#check the model
check_model(platform_richness_mod4_poiss, verbose = T)
#overdispersion
check_overdispersion(platform_richness_mod4_poiss)
#collinearity
check_collinearity(platform_richness_mod4_poiss)
# dharma package - simulate residuals and check model assumptions
platform_richness_mod4_poiss_sim_res <- simulateResiduals(fittedModel = platform_richness_mod4_poiss)
plot(platform_richness_mod4_poiss_sim_res)
```

```{r platform_richness_mod5_poiss, fig.width=8, fig.height=10}
#remove site_type (p= 0.139    for platform_richness_mod4_poiss)
platform_richness_mod5_poiss <- glmmTMB(richness 
                                        #~ Floral_simpson_index_T 
                                        #+ top2_ratio
                                        #+ Site_type
                                        #+ rec_time_min
                                        ~ dm_wind_velocity
                                        + dm_temperature
                                        + Days_since_start
                                        + (1 | location),
                                        family = poisson(),
                                        data = platform_richness)
summary(platform_richness_mod5_poiss)
parameters(platform_richness_mod5_poiss)
#check for singularity
performance::check_singularity(platform_richness_mod5_poiss)
#check the model
check_model(platform_richness_mod5_poiss, verbose = T)
#overdispersion
check_overdispersion(platform_richness_mod5_poiss)
#collinearity
check_collinearity(platform_richness_mod5_poiss)
# dharma package - simulate residuals and check model assumptions
platform_richness_mod5_poiss_sim_res <- simulateResiduals(fittedModel = platform_richness_mod5_poiss)
plot(platform_richness_mod5_poiss_sim_res)
```

```{r platform_richness_mod6_poiss, fig.width=8, fig.height=10}
#remove days since start (p= 0.1763   for platform_richness_mod5_poiss)
platform_richness_mod6_poiss <- glmmTMB(richness 
                                        #~ Floral_simpson_index_T 
                                        #+ top2_ratio
                                        #+ Site_type
                                        #+ rec_time_min
                                        ~ dm_wind_velocity
                                        + dm_temperature
                                        + (1 | location),
                                        family = poisson(),
                                        data = platform_richness)
summary(platform_richness_mod6_poiss)
parameters(platform_richness_mod6_poiss)
#check for singularity
performance::check_singularity(platform_richness_mod6_poiss)
#check the model
check_model(platform_richness_mod6_poiss, verbose = T)
#overdispersion
check_overdispersion(platform_richness_mod6_poiss)
#collinearity
check_collinearity(platform_richness_mod6_poiss)
# dharma package - simulate residuals and check model assumptions
platform_richness_mod6_poiss_sim_res <- simulateResiduals(fittedModel = platform_richness_mod6_poiss)
plot(platform_richness_mod6_poiss_sim_res)

```

#### Compare the models with the performance package
```{r platform_richness_poiss_comp1}
# Compare the models with the performance package
platform_richness_poiss_comp1 <- compare_performance(platform_richness_mod1_poiss, platform_richness_mod2_poiss, platform_richness_mod3_poiss, platform_richness_mod4_poiss, platform_richness_mod5_poiss,platform_richness_mod6_poiss, metrics = c("AICc", "BIC", "R2", "ICC", "RMSE"))

# Print the comparison table
print(platform_richness_poiss_comp1)
```

#### Visualize the model results
```{r}
plot_model(platform_richness_mod1_poiss , type = "est", show.values = TRUE, value.offset = .3)
plot_model(platform_richness_mod6_poiss , type = "est", show.values = TRUE, value.offset = .3)


#wind
# Get the original mean and SD of wind velocity before scaling

# Get predictions on the scaled variable
pred_wind <- ggpredict(platform_richness_mod4_poiss , terms = "dm_wind_velocity")

#unscale the x-axis
pred_wind$x_unscaled <- (pred_wind$x * wind_sd) + wind_mean
# Plot
ggplot(pred_wind, aes(x = x_unscaled, y = predicted)) +
  geom_line(size = 1.2) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = 0.2) +
  labs(
    title = "Predicted Insect Richness by Wind Velocity",
    x = "Wind Velocity (km/hour)",
    y = "Predicted Richness per minute of\n
     recording on platform cameras"
  ) +
  theme_minimal()+
  #add original data points
  #geom_jitter(data = platform_counts_unscaled, aes(x = dm_wind_velocity, y = count), width = 0.2, height = 0, alpha = 0.6, color = "#D9565CFF", size = 2) +
  theme_minimal(base_size = 14)

#temperature
pred_temp <- ggpredict(platform_richness_mod4_poiss , terms = "dm_temperature")
#unscale the x-axis
pred_temp$x_unscaled <- (pred_temp$x * temp_sd) + temp_mean
# Plot
ggplot(pred_temp, aes(x = x_unscaled, y = predicted)) +
  geom_line(size = 1.2) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = 0.2) +
  labs(
    title = "Predicted Insect Richness by Temperature",
    x = "Temperature (C)",
    y = "Predicted Richness per minute of\n
     recording on platform cameras"
  ) +
  theme_minimal()+
  #add original data points
  #geom_jitter(data = platform_counts_unscaled, aes(x = dm_temperature, y = count), width = 0.2, height = 0, alpha = 0.6, color = "#D9565CFF", size = 2) +
  theme_minimal(base_size = 14)

```

#### interpretation of the model results

This model has a Poisson distribution with a log-link, and an offset for the recording time per transect. We can see that the model is a good fit for the data, with no overdispersion and low correlation. The most parsimonious model is the one with the lowest AICc and BIC values, which is the model with only wind velocity and temperature as fixed effects. This model shows that with increasing wind velocity and temperature, the insect richness captured by the camera each minute decreases The previous models also show that the floral Simpson index, time of day, site type and days since start are not significant predictors of insect richness.

Fourth model also has the one of the lowest AICc and BIC values, but still meets the model's assumptions (dharma plot of fitted vs residual looks ok, no overdispersion, etc).


```{r}
#remove all objects starting with platform_richness_
rm(list = ls(pattern = "^platform_richness_"))
```


## B.3. SHANNON - Platform cameras

```{r platform_diversity}
# diversity of insects per transect per site
platform_diversity <- platform_camera %>%
  #create new column with counts = 1
  mutate(count = 1) %>%
  #wide format filled with counts, fill empty cells with 0
  pivot_wider(names_from = top1, values_from = count, values_fill = 0) %>%
  #remove irrelevant columns
  select(-c(ID, Site_Tn, det_conf_mean, track_ID_imgs, top1_imgs, top1_prob_mean, top1_prob_weighted, cam_ID, start_time))%>%
  #sum up rows that have same transect and site
  group_by(location, transect,date) %>%
  summarise(across(fly_sarco:fly_empi, sum), .groups = 'drop') %>%
  #calculate shannon index and simpson index
  mutate(shannon_diversity = diversity(across(fly_sarco:fly_empi), index = "shannon"),
         simpson_diversity = diversity(across(fly_sarco:fly_empi), index = "simpson"))%>%
  #remove irrelevant columns
  select(-c(fly_sarco:fly_empi), -date) %>%
  #join the scaled_envir_data
  left_join(platform_camera1, by = c("location", "transect"))%>%
  #REMOVE EXTRA COLUMNS "ID" "Site_Tn" "det_conf_mean" "track_ID_imgs" "top1_imgs" "top1_prob_mean" "top1_prob_weighted"
  select(-c(ID, Site_Tn, det_conf_mean, track_ID_imgs, top1, top1_imgs, top1_prob_mean, top1_prob_weighted, date,cam_ID, start_time)) %>%
  #keep only unique rows
  distinct()
```

```{r platform_shannon}
#histogram of shannon index
platform_diversity %>%
  ggplot(aes(x = shannon_diversity)) +
  geom_histogram(binwidth = 0.1, fill = "lightblue", color = "black") +
  labs(title = "Histogram of Insect Shannon Diversity",
       x = "Insect Shannon Diversity",
       y = "Count")

#testing the normality of the shannon index
shapiro.test(platform_diversity$shannon_diversity) # p-value = 0.1193, shannon index is normally distributed

datawizard::describe_distribution(platform_diversity$shannon_diversity)
```

The data for shannon diversity captured with the platform cameras is normally distributed (shapiro test: p-value = 0.1193) and has a skewness of -0.28, indicating a slight left skew. The kurtosis is -0.28, indicating a platykurtic distribution (flatter than normal), but fairly normal.

Since a normal distribution is assumed, we will use a gaussian distribution for the model. However, Gaussian models cannot include an offset parameter. Here, there are two options: either add the rec_time_min as a predictor, or divide the diversity index by the recording time, in order to have as a response variable the diversity index per minute of recording.  

Let's try a rate first: 
```{r shannon rate per minute}
#diversity index per minute of recording
platform_diversity <- platform_diversity %>%
  mutate(shannon_diversity_rate = shannon_diversity/rec_time_min,
         simpson_diversity_rate = simpson_diversity/rec_time_min)

#histogram of shannon_diversity_rate
platform_diversity %>%
  ggplot(aes(x = shannon_diversity_rate)) +
  geom_histogram(fill = "lightblue", color = "black") +
  labs(title = "Histogram of Insect Shannon Diversity per minute",
       x = "Insect Shannon Diversity per minute",
       y = "Count")

#testing the normality of the shannon index
shapiro.test(platform_diversity$shannon_diversity_rate) # p-value = 0.1193, shannon index is normally distributed
datawizard::describe_distribution(platform_diversity$shannon_diversity_rate)

# add a very small number to all values
platform_diversity <- platform_diversity %>%
  mutate(shannon_diversity_rate= shannon_diversity_rate + 0.000001)
```

The shannon rate per minute is not normally distributed (Shapiro-Wilk test, p=0.04), that means we shouldn't use a gaussian distribution. We will go for a gamma distribution instead, as it is a continuous distribution that is often used for positive, skewed data and rates. We do have to change the full 0 values to an infinitesimal value, as the gamma distribution cannot handle 0 values. To do that, we added 0.000001 to all values. 


```{r platform_shannonrate_mod1_gamma, fig.width=8, fig.height=10}
# full model with insect shannon diversity as response variable and environmental, weather and plant diversity variables as explanatory variables, and site as random effect, and recording time is included to account for sampling effort differences
platform_shannon_mod1_gamma <- glmer(shannon_diversity_rate
                                     ~ Floral_simpson_index_T
                                     + top2_ratio
                                     + Site_type
                                     + Days_since_start
                                     + dm_wind_velocity 
                                     + dm_temperature 
                                     + (1 | location), 
                           family = Gamma(link = "log"), 
                           data = platform_diversity)
summary(platform_shannon_mod1_gamma)
parameters(platform_shannon_mod1_gamma)
#check for singularity
performance::check_singularity(platform_shannon_mod1_gamma)
#check the model
check_model(platform_shannon_mod1_gamma, verbose = T)
#overdispersion
check_overdispersion(platform_shannon_mod1_gamma)
#collinearity
check_collinearity(platform_shannon_mod1_gamma)
# dharma package - simulate residuals and check model assumptions
platform_shannon_mod1_gamma_sim_res <- simulateResiduals(fittedModel = platform_shannon_mod1_gamma)
plot(platform_shannon_mod1_gamma_sim_res)
# Compute fitted values and Pearson residuals
platform_shannon_mod1_gamma_vals <- fitted(platform_shannon_mod1_gamma)
platform_shannon_mod1_gamma_res <- residuals(platform_shannon_mod1_gamma, type = "pearson")
plot(platform_shannon_mod1_gamma_vals, platform_shannon_mod1_gamma_res)  # Residuals vs Fitted values plot
abline(h = 0, col = "red")  # Add a horizontal line at 0 for reference
# Create binned residuals plot
arm::binnedplot(platform_shannon_mod1_gamma_vals, platform_shannon_mod1_gamma_res)
```

We see here that the assumptions are not met. And after some thought, using an index rate doesn't seem to make a lot of sense, so we decided to use a gaussian distribution with the rec_time_min as a predictor. 

#### B.3.1. SHANNON - Platform cameras - GAUSSIAN glmer (rec_time_min as predictor)

```{r platform_shannon_mod1_gauss, fig.width=8, fig.height=10}
# full model with insect shannon diversity as response variable and environmental, weather and plant diversity variables as explanatory variables, and site as random effect, and recording time is included to account for sampling effort differences

#scale rec_time_min
platform_diversity <- platform_diversity %>%
  mutate(rec_time_min_scaled = scale(rec_time_min))

platform_shannon_mod1_gauss <- lmer(shannon_diversity 
                                   ~ Floral_simpson_index_T 
                                   + rec_time_min_scaled
                                   + top2_ratio
                                   + Site_type
                                   + Days_since_start
                                   + dm_wind_velocity
                                   + dm_temperature
                                   + (1 | location), 
                                   data = platform_diversity)
summary(platform_shannon_mod1_gauss)
parameters(platform_shannon_mod1_gauss)
#check for singularity
performance::check_singularity(platform_shannon_mod1_gauss)
#check the model
check_model(platform_shannon_mod1_gauss, verbose = T)
#overdispersion
check_overdispersion(platform_shannon_mod1_gauss)
#collinearity
check_collinearity(platform_shannon_mod1_gauss)
# dharma package - simulate residuals and check model assumptions
platform_shannon_mod1_gauss_sim_res <- simulateResiduals(fittedModel = platform_shannon_mod1_gauss)
plot(platform_shannon_mod1_gauss_sim_res)

```


```{r platform_shannon_mod2_gauss, fig.width=8, fig.height=10}
#remove site_type (p= 0.361 for platform_shannon_mod1_gauss)
platform_shannon_mod2_gauss <- lmer(shannon_diversity 
                                   ~ Floral_simpson_index_T 
                                   + rec_time_min_scaled
                                   + top2_ratio
                                   #+ Site_type
                                   + Days_since_start
                                   + dm_wind_velocity
                                   + dm_temperature
                                   + (1 | location), 
                                   data = platform_diversity)

summary(platform_shannon_mod2_gauss)
parameters(platform_shannon_mod2_gauss)
#check for singularity
performance::check_singularity(platform_shannon_mod2_gauss)
#check the model
check_model(platform_shannon_mod2_gauss, verbose = T)
#overdispersion
check_overdispersion(platform_shannon_mod2_gauss)
#collinearity
check_collinearity(platform_shannon_mod2_gauss)
# dharma package - simulate residuals and check model assumptions
platform_shannon_mod2_gauss_sim_res <- simulateResiduals(fittedModel = platform_shannon_mod2_gauss)
plot(platform_shannon_mod2_gauss_sim_res)

```

```{r platform_shannon_mod3_gauss, fig.width=8, fig.height=10}
# remove wind velocity (p= 0.334  for platform_shannon_mod2_gauss)
platform_shannon_mod3_gauss <- lmer(shannon_diversity 
                                   ~ Floral_simpson_index_T 
                                   + rec_time_min_scaled
                                   + top2_ratio
                                   #+ Site_type
                                   #+ dm_wind_velocity
                                   + Days_since_start
                                   + dm_temperature
                                   + (1 | location), 
                                   data = platform_diversity)

summary(platform_shannon_mod3_gauss)
parameters(platform_shannon_mod3_gauss)
#check for singularity
performance::check_singularity(platform_shannon_mod3_gauss)
#check the model
  
check_model(platform_shannon_mod3_gauss, verbose = T)
#overdispersion
check_overdispersion(platform_shannon_mod3_gauss)
#collinearity
check_collinearity(platform_shannon_mod3_gauss)
# dharma package - simulate residuals and check model assumptions
platform_shannon_mod3_gauss_sim_res <- simulateResiduals(fittedModel = platform_shannon_mod3_gauss)
plot(platform_shannon_mod3_gauss_sim_res)

```
```{r platform_shannon_mod4_gauss, fig.width=8, fig.height=10}
#remove floral index (p= 0.281  for platform_shannon_mod3_gauss)
platform_shannon_mod4_gauss <- lmer(shannon_diversity 
                                   #~ Floral_simpson_index_T 
                                   ~ rec_time_min_scaled
                                   + top2_ratio
                                   #+ Site_type
                                   #+ dm_wind_velocity
                                   + Days_since_start
                                   + dm_temperature
                                   + (1 | location), 
                                   data = platform_diversity)
summary(platform_shannon_mod4_gauss)
parameters(platform_shannon_mod4_gauss)
#check for singularity
performance::check_singularity(platform_shannon_mod4_gauss)
#check the model
check_model(platform_shannon_mod4_gauss, verbose = T)
#overdispersion
check_overdispersion(platform_shannon_mod4_gauss)
#collinearity
check_collinearity(platform_shannon_mod4_gauss)
# dharma package - simulate residuals and check model assumptions
platform_shannon_mod4_gauss_sim_res <- simulateResiduals(fittedModel = platform_shannon_mod4_gauss)
plot(platform_shannon_mod4_gauss_sim_res)
```

```{r platform_shannon_mod5_gauss, fig.width=8, fig.height=10}
#remove top2_ratio (p= 0.133  for platform_shannon_mod4_gauss)
platform_shannon_mod5_gauss <- lmer(shannon_diversity 
                                   #~ Floral_simpson_index_T 
                                   ~ rec_time_min_scaled
                                   #+ top2_ratio
                                   #+ Site_type
                                   #+ dm_wind_velocity
                                   + Days_since_start
                                   + dm_temperature
                                   + (1 | location), 
                                   data = platform_diversity)
summary(platform_shannon_mod5_gauss)
parameters(platform_shannon_mod5_gauss)
#check for singularity
performance::check_singularity(platform_shannon_mod5_gauss)
#check the model
check_model(platform_shannon_mod5_gauss, verbose = T)
#overdispersion
check_overdispersion(platform_shannon_mod5_gauss)
#collinearity
check_collinearity(platform_shannon_mod5_gauss)
# dharma package - simulate residuals and check model assumptions
platform_shannon_mod5_gauss_sim_res <- simulateResiduals(fittedModel = platform_shannon_mod5_gauss)
plot(platform_shannon_mod5_gauss_sim_res)
```

#### compare the models with the performance package
```{r platform_shannon_gauss_comp1}
# Compare the models with the performance package
platform_shannon_gauss_comp1 <- compare_performance(platform_shannon_mod1_gauss, platform_shannon_mod2_gauss, platform_shannon_mod3_gauss, platform_shannon_mod4_gauss, platform_shannon_mod5_gauss, metrics = c("AICc", "BIC", "R2", "ICC", "RMSE"))
# Print the comparison table
print(platform_shannon_gauss_comp1)
```

#### visualize the model results
```{r}
plot_model(platform_shannon_mod1_gauss , type = "est", show.values = TRUE, value.offset = .3);
plot_model(platform_shannon_mod4_gauss , type = "est", show.values = TRUE, value.offset = .3)


#temperature
# Get the original mean and SD of wind velocity before scaling
temp_mean <- mean(envir_data$dm_temperature, na.rm = TRUE)
temp_sd <- sd(envir_data$dm_temperature, na.rm = TRUE)
# Get predictions on the scaled variable
pred_temp <- ggpredict(platform_shannon_mod4_gauss , terms = "dm_temperature")
# Unscale the x-axis
pred_temp$x_unscaled <- (pred_temp$x * temp_sd) + temp_mean
# Plot
ggplot(pred_temp, aes(x = x_unscaled, y = predicted)) +
  geom_line(size = 1.2) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = 0.2) +
  labs(
    title = "Predicted Insect Shannon Diversity by Temperature",
    x = "Temperature (C)",
    y = "Predicted Shannon Diversity recording on platform cameras"
  ) +
  theme_minimal()+
  #add original data points
  #geom_jitter(data = platform_counts_unscaled, aes(x = dm_temperature, y = count), width = 0.2, height = 0, alpha = 0.6, color = "#D9565CFF", size = 2) +
  theme_minimal(base_size = 14)

#days since start
# Get the original mean and SD of days before scaling
days_mean <- mean(envir_data$Days_since_start, na.rm = TRUE)
days_sd <- sd(envir_data$Days_since_start, na.rm = TRUE)
# Get predictions on the scaled variable
pred_days <- ggpredict(platform_shannon_mod4_gauss , terms = "Days_since_start")
# Unscale the x-axis
pred_days$x_unscaled <- (pred_days$x * days_sd) + days_mean
# Plot
ggplot(pred_days, aes(x = x_unscaled, y = predicted)) +
  geom_line(size = 1.2) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = 0.2) +
  labs(
    title = "Predicted Insect Shannon Diversity by Days Since Start",
    x = "Days Since Start",
    y = "Predicted Shannon Diversity recording on platform cameras"
  ) +
  theme_minimal()+
  #add original data points
  #geom_jitter(data = platform_counts_unscaled, aes(x = dm_temperature, y = count), width = 0.2, height = 0, alpha = 0.6, color = "#D9565CFF", size = 2) +
  theme_minimal(base_size = 14)


```

```{r}
#remove all objects starting with platform_shannon_
rm(list = ls(pattern = "^platform_shannon_"))
```


## B.4. SIMPSON - Platform cameras

```{r platform_simpson}
#histogram of simpson index
platform_diversity %>%
  ggplot(aes(x = simpson_diversity)) +
  geom_histogram(binwidth = 0.1, fill = "lightblue", color = "black") +
  labs(title = "Histogram of Insect Simpson Diversity",
       x = "Insect Simpson Diversity",
       y = "Count")

#testing the normality of the simpson index
shapiro.test(platform_diversity$simpson_diversity) # p-value = 0.001222, simpson index is not normally distributed
datawizard::describe_distribution(platform_diversity$simpson_diversity)

#adding a small number to all simpson index values
platform_diversity <- platform_diversity %>%
  mutate(simpson_diversity = simpson_diversity + 0.0001)

#histogram of rec_time_min
platform_diversity %>%
  ggplot(aes(x = rec_time_min)) +
  geom_histogram(fill = "lightblue", color = "black") +
  labs(title = "Histogram of Recording Time",
       x = "Recording Time (minutes)",
       y = "Count")

#testing the normality of the rec_time_min
shapiro.test(platform_diversity$rec_time_min) # p-value = , rec_time_min is not normally distributed
datawizard::describe_distribution(platform_diversity$rec_time_min)
summary(platform_diversity$rec_time_min)
```

The data for simpson diversity captured with the platform cameras is not normally distributed (shapiro test: p-value = 0.001222) and has a skewness of -1.13, indicating a  left skew. The kurtosis is 0.35, slightly peaked. Since the values are between 0 and 1, we'll use a beta distribution. However, we need to add a small number to all values to avoid 0 and 1 values, as the beta distribution cannot handle them. We will add 0.000001 to all values. 

```{r platform_simpson_mod1_beta, fig.width=8, fig.height=10}
# full model with insect simpson diversity as response variable and environmental, weather and plant diversity variables as explanatory variables, and site as random effect, and recording time is included to account for sampling effort differences

platform_simpson_mod1_beta <- glmmTMB(simpson_diversity 
                                       ~ Floral_simpson_index_T 
                                       + rec_time_min
                                       + top2_ratio
                                       + Site_type
                                       + Days_since_start
                                       + dm_wind_velocity 
                                       + dm_temperature 
                                       + (1 | location), 
                                     family = beta_family(link = "logit"), 
                                     data = platform_diversity)

summary(platform_simpson_mod1_beta)
parameters(platform_simpson_mod1_beta)
#check for singularity
performance::check_singularity(platform_simpson_mod1_beta)
#check the model
check_model(platform_simpson_mod1_beta, verbose = T)
#overdispersion
check_overdispersion(platform_simpson_mod1_beta)
#collinearity
check_collinearity(platform_simpson_mod1_beta)
# dharma package - simulate residuals and check model assumptions
platform_simpson_mod1_beta_sim_res <- simulateResiduals(fittedModel = platform_simpson_mod1_beta)
plot(platform_simpson_mod1_beta_sim_res)
```

```{r platform_simpson_mod2_beta, fig.width=8, fig.height=10}
#remove floral simpson index (p= 0.319    for platform_simpson_mod1_beta)
platform_simpson_mod2_beta <- glmmTMB(simpson_diversity 
                                       #~ Floral_simpson_index_T 
                                       ~ top2_ratio
                                       + rec_time_min
                                       + Site_type
                                       + Days_since_start
                                       + dm_wind_velocity 
                                       + dm_temperature 
                                       + (1 | location), 
                                     family = beta_family(link = "logit"), 
                                     data = platform_diversity)
summary(platform_simpson_mod2_beta)
parameters(platform_simpson_mod2_beta)
#check for singularity
performance::check_singularity(platform_simpson_mod2_beta)
#check the model
check_model(platform_simpson_mod2_beta, verbose = T)
#overdispersion
check_overdispersion(platform_simpson_mod2_beta)
#collinearity
check_collinearity(platform_simpson_mod2_beta)
# dharma package - simulate residuals and check model assumptions
platform_simpson_mod2_beta_sim_res <- simulateResiduals(fittedModel = platform_simpson_mod2_beta)
plot(platform_simpson_mod2_beta_sim_res)

```

```{r platform_simpson_mod3_beta, fig.width=8, fig.height=10}
#remove site type (p= 0.138   for platform_simpson_mod2_beta)
platform_simpson_mod3_beta <- glmmTMB(simpson_diversity 
                                       #~ Floral_simpson_index_T 
                                       ~ top2_ratio
                                       #+ Site_type
                                       + rec_time_min
                                       + Days_since_start
                                       + dm_wind_velocity 
                                       + dm_temperature
                                       + (1 | location), 
                                     family = beta_family(link = "logit"), 
                                     data = platform_diversity)

summary(platform_simpson_mod3_beta)
parameters(platform_simpson_mod3_beta)
#check for singularity
performance::check_singularity(platform_simpson_mod3_beta)
#check the model
check_model(platform_simpson_mod3_beta, verbose = T)
#overdispersion
check_overdispersion(platform_simpson_mod3_beta)
#collinearity
check_collinearity(platform_simpson_mod3_beta)
# dharma package - simulate residuals and check model assumptions
platform_simpson_mod3_beta_sim_res <- simulateResiduals(fittedModel = platform_simpson_mod3_beta)
plot(platform_simpson_mod3_beta_sim_res)

```

```{r platform_simpson_mod4_beta, fig.width=8, fig.height=10}
#remove dm_wind_velocity  (p= 0.071 for platform_simpson_mod3_beta)

platform_simpson_mod4_beta <- glmmTMB(simpson_diversity 
                                       #~ Floral_simpson_index_T 
                                       ~ top2_ratio
                                      + rec_time_min
                                       #+ Site_type
                                       + Days_since_start
                                       #+ dm_wind_velocity 
                                       + dm_temperature 
                                       + (1 | location), 
                                     family = beta_family(link = "logit"), 
                                     data = platform_diversity)

summary(platform_simpson_mod4_beta)
parameters(platform_simpson_mod4_beta)
#check for singularity
performance::check_singularity(platform_simpson_mod4_beta)
#check the model
check_model(platform_simpson_mod4_beta, verbose = T)
#overdispersion
check_overdispersion(platform_simpson_mod4_beta)
#collinearity
check_collinearity(platform_simpson_mod4_beta)
# dharma package - simulate residuals and check model assumptions
platform_simpson_mod4_beta_sim_res <- simulateResiduals(fittedModel = platform_simpson_mod4_beta)
plot(platform_simpson_mod4_beta_sim_res)

```

```{r platform_simpson_mod5_beta, fig.width=8, fig.height=10}
#remove top 2  (p= 0.075  for platform_simpson_mod4_beta)
platform_simpson_mod5_beta <- glmmTMB(simpson_diversity 
                                       #~ Floral_simpson_index_T 
                                       # top2_ratio
                                       #+ Site_type
                                       #+ dm_wind_velocity 
                                       ~ dm_temperature 
                                       + rec_time_min
                                       + Days_since_start
                                       + (1 | location), 
                                     family = beta_family(link = "logit"), 
                                     data = platform_diversity)
summary(platform_simpson_mod5_beta)
parameters(platform_simpson_mod5_beta)
#check for singularity
performance::check_singularity(platform_simpson_mod5_beta)
#check the model
check_model(platform_simpson_mod5_beta, verbose = T)
#overdispersion
check_overdispersion(platform_simpson_mod5_beta)
#collinearity
check_collinearity(platform_simpson_mod5_beta)
  
# dharma package - simulate residuals and check model assumptions
platform_simpson_mod5_beta_sim_res <- simulateResiduals(fittedModel = platform_simpson_mod5_beta)
plot(platform_simpson_mod5_beta_sim_res)

```


#### compare the models with the performance package
```{r platform_simpson_beta_comp1}
# Compare the models with the performance package
platform_simpson_beta_comp1 <- compare_performance(platform_simpson_mod1_beta, platform_simpson_mod2_beta, platform_simpson_mod3_beta, platform_simpson_mod4_beta, platform_simpson_mod5_beta, metrics = c("AICc", "BIC", "R2", "ICC", "RMSE"))
# Print the comparison table
print(platform_simpson_beta_comp1)
``` 

#### visualize the model results
```{r}
plot_model(platform_simpson_mod1_beta , type = "est", show.values = TRUE, value.offset = .3)

plot_model(platform_simpson_mod3_beta , type = "est", show.values = TRUE, value.offset = .3)

```

```{r}
#remove all objects starting with platform_simpson_
rm(list = ls(pattern = "^platform_simpson_"))
```


## C. Flower cameras

The flower cameras images were taken every 5 seconds, so to account for some of the repeats in the images, we will group together the images taken in the same minute and classified as the same family. We will also remove the images that are not classified as a family, and those that are classified as other families. 
For now, we put the family confidence at a threshold of 0.5, but we can change that later if needed. 


The flower cameras were not placed on specific transects, but on individual flowers that were representative of the most abundant flower species in the area. We need to calculate the average flower cover per site instead of per transect, as well as the average floral Simpson index per site. 



```{r}
# flower camera data
flower_camera_modelling <- flower_camera %>%
  #remove all rows in calssification categroy that are other_families
  filter(Classification_Category != "other_families") %>%
  #remove all rows that are below 0.5 in Family_Confidence
  filter(Family_Confidence >= 0.5) %>%
  #transform time as character 
  mutate(time = as.character(time)) %>%
  #transform specific row 08:59:13 to 09:01:00
  mutate(time = ifelse(time == "08:59:13", "09:01:00", time)) %>%
  #remove the last 3 characters of the time column
  mutate(time = substr(time, 1, nchar(time) - 3)) %>%
  #split the time column into two columns: hours and minutes
  separate(time, into = c("hours", "minutes"), sep = ":") %>%
  #convert the hours and minutes columns to numeric
  mutate(hours = as.numeric(hours),
         minutes = as.numeric(minutes)) %>%
  # transfrom time into minutes since 9am
  mutate(minutes_since_9am = (hours - 9) * 60 + minutes)
  
  

  
flower_camera_famcount <- flower_camera_modelling %>%
  #keep only first occurrence of a row where site, flower_sp, family and minutes since 9am are the same
  #this will remove the duplicates in the same minute
  distinct(site, date, cam, flower_sp, minutes_since_9am, Family, .keep_all = TRUE) %>%
  
  #group by site, flower_sp, family and minutes since 9am
  group_by(site, date , cam, flower_sp, Family) %>%
  #count the number of images per minute per family
  summarise(count = n(), .groups = 'drop')


#final count dataframe
flower_cam_count_full <- flower_camera_modelling %>%
  #summarize the number of images per site per flower_sp
  group_by(site, date , cam, flower_sp) %>%
  summarise(count = n(), .groups = 'drop')

#plant survey data
planty <- relative_flower %>%
  select(Site, Transect, average_flower_cover, Floral_simpson_index)%>%
  #average of Floral  simpson index per site
  group_by(Site,average_flower_cover) %>%
  summarise(Floral_simpson_index_site = mean(Floral_simpson_index), .groups = 'drop')
  

flower_cam_count_full <- envir_data %>%
  #remove data irrelevant for flower camera, such as transect, minutes since 9am, floral simpson index
  select(-c(Transect, minutes_since_9am,Floral_simpson_index_T, Pastinaca.sativa, Daucus.carota, top2_ratio)) %>%
  #join the flower camera data
  left_join(flower_cam_count_full, by = c("Site"= "site","Date"= "date"))%>%
  distinct()%>%
  #join the plant survey data
  left_join(planty, by = c("Site"= "Site"))%>%
  #scale the environmental data
  mutate(across(c(dm_wind_velocity, dm_temperature, average_flower_cover,agri,grass,snh,forest,urban,water,Days_since_start,average_flower_cover,Floral_simpson_index_site), scale))

flower_cam_count_reduced <- flower_camera_famcount %>%
  #summarize the number of images per site per flower_sp
  group_by(site, date , cam, flower_sp) %>%
  summarise(count = n(), .groups = 'drop')%>%
  #join the plant survey data
  left_join(planty, by = c("site"= "Site"))%>%
  #join environmental data
  left_join(envir_data, by = c("site"= "Site","date"= "Date"))%>%
  #scale the environmental data
  mutate(across(c(dm_wind_velocity, dm_temperature, average_flower_cover,agri,grass,snh,forest,urban,water,Days_since_start,average_flower_cover, Floral_simpson_index_site), scale))%>%
  distinct()
  
  
sum(flower_cam_count_full$count);sum(flower_cam_count_reduced$count)
sum(flower_cam_count_reduced$count)/sum(flower_cam_count_full$count)

#histogram of the number of images per flower camera
flower_cam_count_full %>%
  ggplot(aes(x = count)) +
  geom_histogram(binwidth=0.5,fill = "lightblue", color = "black") +
  labs(title = "Histogram of Number of Images per Flower Camera",
       x = "Number of Images",
       y = "Count")

#testin normality of the number of images per flower camera
shapiro.test(flower_cam_count_full$count) # p-value = 3.35e-07, number of images per flower camera is not normally distributed
datawizard::describe_distribution(flower_cam_count_full$count)

flower_cam_count_reduced %>%
  ggplot(aes(x = count)) +
  geom_histogram(binwidth = 1, fill = "lightblue", color = "black") +
  labs(title = "Histogram of Number of Images per Flower Camera",
       x = "Number of Images",
       y = "Count")

#testin normality of the number of images per flower camera
shapiro.test(flower_cam_count_reduced$count) # p-value = 0.0007664, number of images per flower camera is not normally distributed
datawizard::describe_distribution(flower_cam_count_reduced$count)
```

flower_cam_count1$count:
W = 0.73, p-value = 3.35e-07 → Strong evidence against normality.
Very right-skewed (Skewness = 1.91) and heavy-tailed (Kurtosis = 3.17).
Wide range: from 2 to 1503, high variance (SD = 388.98).

flower_cam_count2$count:
W = 0.89, p-value = 0.00077 → Also not normal.
Still skewed (Skewness = 0.90), but much more manageable.
Lower range: 2 to 57, smaller variance (SD = 15.20).

## C.1. Flower cameras - abundance count full

Since it is a count response variable, we will use a Poisson distribution.
```{r flower_abundance_mod1_nb, fig.width=8, fig.height=10}
# full model with insect abundance as response variable and environmental, weather and plant diversity variables as explanatory variables, and site as random effect, and recording time is included to account for sampling effort differences
flower_abundance_mod1_nb <- glmer.nb(count 
                                     ~ Site_type
                                     #+ flower_sp
                                     + average_flower_cover
                                     + Floral_simpson_index_site
                                     + Days_since_start
                                     + dm_wind_velocity 
                                     + dm_temperature 
                                     + (1 | Site), 
                                     #negative binomial distribution model
                                     family = nbinom2,
                                   data = flower_cam_count_full)
summary(flower_abundance_mod1_nb)
parameters(flower_abundance_mod1_nb)
#check for singularity
performance::check_singularity(flower_abundance_mod1_nb)
#check the model
check_model(flower_abundance_mod1_nb, verbose = T)
#overdispersion
check_overdispersion(flower_abundance_mod1_nb)
#collinearity
check_collinearity(flower_abundance_mod1_nb)
# dharma package - simulate residuals and check model assumptions
flower_abundance_mod1_nb_sim_res <- simulateResiduals(fittedModel = flower_abundance_mod1_nb)
plot(flower_abundance_mod1_nb_sim_res)

```

```{r flower_abundance_mod2_nb, fig.width=8, fig.height=10}
#remove site type (p= 0.917  for flower_abundance_mod1_nb)
flower_abundance_mod2_nb <- glmer.nb(count 
                                     #~ Site_type
                                     ~ average_flower_cover
                                     #+ flower_sp
                                     + Floral_simpson_index_site
                                     + Days_since_start
                                     + dm_wind_velocity 
                                     + dm_temperature 
                                     + (1 | Site), 
                                   #negative binomial distribution model
                                   family = nbinom2,
                                   data = flower_cam_count_full)

summary(flower_abundance_mod2_nb)
parameters(flower_abundance_mod2_nb)
#check for singularity
performance::check_singularity(flower_abundance_mod2_nb)
#check the model
check_model(flower_abundance_mod2_nb, verbose = T)
#overdispersion
check_overdispersion(flower_abundance_mod2_nb)
#collinearity
check_collinearity(flower_abundance_mod2_nb)
# dharma package - simulate residuals and check model assumptions
flower_abundance_mod2_nb_sim_res <- simulateResiduals(fittedModel = flower_abundance_mod2_nb)
plot(flower_abundance_mod2_nb_sim_res)

```

```{r flower_abundance_mod3_nb, fig.width=8, fig.height=10}
#remove days since start (p= 0.262   for flower_abundance_mod2_nb)
flower_abundance_mod3_nb <- glmer.nb(count 
                                     #~ Site_type
                                     #+ flower_sp
                                     ~ average_flower_cover
                                     + Floral_simpson_index_site
                                     #+ Days_since_start
                                     + dm_wind_velocity 
                                     + dm_temperature 
                                     + (1 | Site), 
                                   #negative binomial distribution model
                                   family = nbinom2,
                                   data = flower_cam_count_full)

summary(flower_abundance_mod3_nb)
parameters(flower_abundance_mod3_nb)
#check for singularity
performance::check_singularity(flower_abundance_mod3_nb)
#check the model
check_model(flower_abundance_mod3_nb, verbose = T)
#overdispersion
check_overdispersion(flower_abundance_mod3_nb)
#collinearity
check_collinearity(flower_abundance_mod3_nb)
# dharma package - simulate residuals and check model assumptions
flower_abundance_mod3_nb_sim_res <- simulateResiduals(fittedModel = flower_abundance_mod3_nb)
plot(flower_abundance_mod3_nb_sim_res)


```

```{r flower_abundance_mod4_nb, fig.width=8, fig.height=10}
#remove floral simpson index (p= 0.169       for flower_abundance_mod3_nb)
flower_abundance_mod4_nb <- glmer.nb(count 
                                     #~ Site_type
                                     #+ flower_sp
                                     #+ average_flower_cover
                                     ~ Floral_simpson_index_site
                                     #+ Days_since_start
                                     + dm_wind_velocity 
                                     + dm_temperature 
                                     + (1 | Site), 
                                   #negative binomial distribution model
                                   family = nbinom2,
                                   data = flower_cam_count_full)
summary(flower_abundance_mod4_nb)
parameters(flower_abundance_mod4_nb)
#check for singularity
performance::check_singularity(flower_abundance_mod4_nb)
#check the model
check_model(flower_abundance_mod4_nb, verbose = T)
#overdispersion
check_overdispersion(flower_abundance_mod4_nb)
#collinearity
check_collinearity(flower_abundance_mod4_nb)
# dharma package - simulate residuals and check model assumptions
flower_abundance_mod4_nb_sim_res <- simulateResiduals(fittedModel = flower_abundance_mod4_nb)
plot(flower_abundance_mod4_nb_sim_res)

```

####  Compare the models with the performance package
```{r flower_abundance_nb_comp1}
# Compare the models with the performance package
flower_abundance_nb_comp1 <- compare_performance(flower_abundance_mod1_nb, flower_abundance_mod2_nb, flower_abundance_mod3_nb, flower_abundance_mod4_nb, metrics = c("AICc", "BIC", "R2", "ICC", "RMSE"))
# Print the comparison table
print(flower_abundance_nb_comp1)
```

```{r}
plot_model(flower_abundance_mod2_nb , type = "est", show.values = TRUE, value.offset = .3)

```

