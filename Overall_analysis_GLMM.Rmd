---
title: "Overall_analysis_GLMM"
author: "Alma Steireif"
date: "`r Sys.Date()`"
output: 
  html_document:
      toc: TRUE
---

# I. Description of project
## I.A. Hypotheses

**Q1: Do reference and restored sites exhibit differences in pollinator biodiversity?**

  **H0:**    
  • no significant difference between reference and restored sites in pollinator biodiversity
  → pollinators are highly mobile and can easily colonize restored habitats, thereby achieving similar biodiversity and composition to reference sites.
  
  **H1:**    
  • pollinator diversity is higher in reference sites compared to young restored sites
  → habitat complexity, trophic levels, vegetation structure, and resource availability, all take time to develop in restored sites


**Q2: Do traditional and automated methods yield different compositions of pollinators?**    

  **H0:**      
  • no significant differences in pollinator composition detected by traditional and automated methods
  → because all methods aim to capture a representative sample of the pollinator community.
  
  **H1:**      
  • Traditional and automated methods yield different compositions of pollinators
  → due to inherent biases in sampling efficiency, taxonomy resolution, and target taxa, leading to discrepancies in the detection of certain pollinators.
  
**Q3: Can automated methods effectively detect biodiversity changes between reference and restored sites?**

  **H0:**      
  • Automated methods do not effectively detect biodiversity changes between reference and restored sites
  → due to limitations in capturing the full spectrum of pollinator abundance and species richness, as well as potential challenges in achieving high taxonomic resolution.
  
  **H1:**     
  • Automated methods can effectively detect biodiversity differences between reference and restored sites
  → machine learning algorithms can offer improved sensitivity and accuracy in detecting shifts in pollinator communities over time.



# II. Setup    
## II.A. libraries    

```{r setup, include=FALSE}

library(vegan)  # For diversity indices
library(paletteer)  # For color palettes
library(RColorBrewer)  # For color palettes

#library(reshape2)
library(patchwork) #for wrapping plots
library(cowplot) #for wrapping plots
#library(chron)  # for time data
library(lubridate)  # for date data

library(Hmisc)  # correlation matrix
library(corrplot)  # plotting
library(factoextra) #install library for fviz_pca

library(easystats)#library(parameters) #library(performance)
library(lme4)
library(ggeffects)
library(glmmTMB) #for glmmTMB models
library(arm) #for residual plots of binomial models
library(DHARMa) #for residual plots
library(datawizard) #chek documentation
library(sjPlot)
library(shiny)
#library(pscl) #for zero inflation test
#library(mgcv) #tweedie models

library(tidyverse) 

sessionInfo()

```

## II.B. aesthetics

```{r custom colors}
#define custom colors for plotting

#custom_colors <- c("Young Restored" = "#9BB655FF", "Reference" = "#1F78B4")

#saturated_pal <- c(
  #reference site "DES" = "#7F3B19FF",    "HLI" = "#FDB863FF",    "JEP" = "#E08214FF",    "STP" = "#B35806FF",  "WUP" = "#FEE0B6FF",  
  # restored sites  "BUH" = "#93C6E1FF",   "KOT" = "#5F93ACFF",    "WDG" = "#2E627AFF",    "WED" = "#00344AFF"  )

saturated_pal <- c(
  #reference sites
  "DES" = "#93C6E1FF",  
  "HLI" = "#5F93ACFF",  
  "JEP" = "#2E627AFF",  
  "STP" = "#00344AFF",  
  "WUP" = "#1F78B4",
  # restored sites
  "BUH" = "#5C7424",  
  "KOT" = "#C3D69B",  
  "WDG" = "#9BB655",  
  "WED" = "#6D8F3C"  
)

# bicolor palette
bicolor_pal <- c(
  "DES" = "#1F78B4",  
  "HLI" = "#1F78B4",  
  "JEP" = "#1F78B4",  
  "STP" = "#1F78B4",
  "WUP" = "#1F78B4",
  "BUH" = "#9BB655FF",  
  "KOT" = "#9BB655FF",  
  "WDG" = "#9BB655FF",  
  "WED" = "#9BB655FF" 
)

bicolor_bg <- c(
  "DES" = "lightblue",  
  "HLI" = "lightblue",  
  "JEP" = "lightblue",  
  "STP" = "lightblue",
  "WUP" = "lightblue",
  "BUH" = "#D3D5AEFF",  
  "KOT" = "#D3D5AEFF",  
  "WDG" = "#D3D5AEFF",  
  "WED" = "#D3D5AEFF" 
)

theme_new <- theme_classic(base_size = 12) +
  theme(axis.line = element_blank(),
        axis.text = element_text(colour = "black"),
        axis.ticks = element_line(linewidth = 0.4, colour = "black"),
        legend.key.size = unit(0.5, "cm"),
        legend.margin = margin(t = 0),
        legend.text = element_text(size = 8),
        legend.title = element_text(size = 9),
        panel.border = element_rect(linewidth = 0.4, colour = "black", fill = NA),
        panel.grid.major.y = element_line(colour = "grey90", linewidth = 0.2),
        plot.margin = margin(2, 2, 2, 2, "pt"),
        plot.title = element_text(size = 12))
theme_set(theme_new)
```

#### Predictor colors

Setting predictor colors allows us to make unified plots with the same colors for the same variables in the modelling steps. 
Now in order to call one of the colors, we can do as follows:  `predictor_colors["Floral_simpson_index_T"]`.
RColorBrewer::Spectral
```{r}
# Select 7 colors from the a palette
predictor_colors <- paletteer::paletteer_d("RColorBrewer::Spectral")[1:9]

# Assign colors to the predictor variables
predictor_colors <- c(
  "dm_temperature"= "#F8A02EFF",
  "Floral_simpson_index_T"= "#4F3855FF",
  "Floral_simpson_index_site"= "#3F3955FF",
  "minutes_since_9am" ="black",
  "top2_ratio"= "#254100FF",
  "Plot_Cover_T" = "#9D3A5EFF",
  "Days_since_start" = "#808080FF",
  "dm_wind_velocity" ="#4987A0FF", 
  "rec_time_min" = "#263D5DFF",
  "average_flower_cover" ="#9D3A5EFF")

# View the named color mapping
print(predictor_colors)

barplot(
  rep(1, length(predictor_colors)),
  col = predictor_colors,
  names.arg = names(predictor_colors),
  las = 2,  # rotate labels
  cex.names = 0.8,
  main = "Predictor Color Preview"
)


```
**One option: MetBrewer::Derain**

predictor_colors <- paletteer::paletteer_d("MetBrewer::Derain")[1:7]

Assign colors to the predictor variables
predictor_colors <- setNames(predictor_colors, c(
  "dm_temperature", 
  "top2_ratio",
  "Plot_Cover_T",
  "Floral_simpson_index_T",
  "minutes_since_9am",
  "Days_since_start",
  "dm_wind_velocity"
))

**One option: MetBrewer::Nattier**
predictor_colors <- paletteer::paletteer_d("MetBrewer::Nattier")[1:8]

Assign colors to the predictor variables
predictor_colors <- setNames(predictor_colors, c(
  "dm_temperature", 
  "Floral_simpson_index_T",
  "minutes_since_9am",
  "top2_ratio",
  "Plot_Cover_T",
  "Days_since_start",
  "dm_wind_velocity", 
  "rec_time_min"
))

## II.C. data loading   
 
```{r loading all needed csv files}
### Environmental data ------------

## landscape data from "C:\Users\Almas\Desktop\UNI_LEIPSI\Thesis\Thesis_Rproject\data\landscape_data.csv"
landscape_data <- read.csv("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/data/corine_data.csv")

## weather data from the Deutscher Wetterdienst (DWD)
dwd_weather <- read.csv("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/data/dwd_weather_data.csv")

## weather data from the field
field_weather <- read.csv("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/data/field_weather_data.csv")

## plant data
plants <- read.csv("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/data/plants3.csv")
relative_flower <- read.csv("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/data/relative_flower.csv")
top2 <- read.csv("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/data/top2.csv")

## extrapolated plant data
#inext_plants <- read.csv("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/data/iNext_AsyEst_plants.csv")

### Traditional methods ------------

## netting data 
netting <- read.csv("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/data/net_data_long.csv")

## pan trap data for families
pan_family <- read.csv("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/data/bowltrap_clean.csv")

### Cameras ------------

## flower camera data
flower_camera <- read.csv("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/data/bioclip_flower_cams.csv")

## platfrom camera data 
platform_camera <- read.csv("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/data/InsectDetect_platform_cams.csv")
platform_logs_rec <- read.csv("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/data/platform_recording_logs.csv")
```





# III. EDA & data cleaning

## III.A. Enivronmental variables
### III.A.1. Dwd weather data

```{r dwd weather}
#change dwd_weather date format from 20240724 to 2024-07-24 by adding a "-" after the year and month
dwd_weather <- dwd_weather %>%
  #adding a "-" after the year and month
  mutate(Date = gsub("(\\d{4})(\\d{2})", "\\1-\\2", MESS_DATUM))%>%
  #adding - after the month
  mutate(Date = gsub("(\\d{4}-\\d{2})(\\d{2})", "\\1-\\2", Date))

#select the relevant columns for out analysis: Date, SITE, FM, TMK and rename them properly dm= daily mean
dwd_weather <- dwd_weather %>%
  dplyr::select("Date"="Date",
         "Site"="SITE",
         "dm_wind_velocity"="FM",
         "dm_temperature"="TMK")
```


We will not keep the weather data written down by hand in the field, as it is not as reliable as the data from the DWD weather station. However, an interesting variable to keep is the start time of walking the transect for the netting method. This could be an important factor in the number of pollinators caught, as some species are more active in the morning or evening.

### III.A.2. Field weather data - Start time of netting

```{r field weather start time}
#transform field_weather into start_net dataframe
start_net <- field_weather %>%
  dplyr::select(
         "Date"="date",
         "Site"="SITE",
         "Transect"="transect",
         "Start_time"="start_time")

start_net <- start_net %>%
  mutate(
    Start_time = gsub("\\.", ":", Start_time),  # Replace "." with ":"
    Start_time = ifelse(Start_time == "9:25", "09:25", Start_time),  # Fix specific case
    Start_time = ifelse(nchar(Start_time) == 4, paste0(Start_time, "0"), Start_time),  # Ensure "14:0" -> "14:00"
    Start_time = ifelse(nchar(Start_time) == 2, paste0(Start_time, ":00"), Start_time),  # Ensure "14" -> "14:00"
    Hour = as.integer(substr(Start_time, 1, 2)),  # Extract hour
    Minute = as.integer(substr(Start_time, 4, 5)))%>%  # Extract minutes
    #add new column minutes since 9 am
    mutate(minutes_since_9am = (Hour - 9) * 60 + Minute)%>%
  #remove unnecessary columns
  dplyr::select(-c("Hour", "Minute", "Start_time"))
    
     

#barplot start time per site, colored by transect
start_net %>%
    ggplot(aes(x = Site, y = minutes_since_9am, fill = Transect)) +
  geom_bar(stat = "identity", position= "dodge") +
  labs(title = "Start time of transect walk per site",
       x = "Site",
       y = "Time (minutes since 9 am)") +
  theme(legend.position = "left")+
  #viridis
  scale_fill_viridis_d() 

write.csv(start_net, "C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/data/start_net.csv", row.names = FALSE)

```

### III.A.3. Landscape data & combining 

```{r landscape and top2}
Floral_simpson_index_T <- relative_flower %>%
  dplyr::select("Site"="Site",
         "Transect"="Transect",
         "Site_type"="Site_type",
         "Floral_simpson_index"="Floral_simpson_index")%>%
  distinct()%>%
  #new column with average simpson per transect
  group_by(Site, Transect, Site_type) %>%
  summarise(Floral_simpson_index_T = sum(Floral_simpson_index)/3)%>%
  ungroup()


planty <- relative_flower %>%
  dplyr::select(Site, Plot_Cover, Transect, average_flower_cover)%>%
  #average the cover per transect
  group_by(Site, Transect,average_flower_cover) %>%
  summarise(Plot_Cover_T = mean(Plot_Cover, na.rm = TRUE))
  

envir_data <- start_net %>%
  #select the relevant columns
  #dplyr::select(-c("Start_time", "Time_Bin"))%>%
  
  #join the dwd weather data
  full_join(dwd_weather, by = c("Date" = "Date", "Site"))%>%
  
  #join the landscape data
  full_join(landscape_data, by = c("Site" = "Site"))%>%
  
  #join the top2 data
  full_join(top2, by = c("Site" = "Site", "Transect")) %>%
  dplyr::select(-c( "Site_type", "average_flower_cover"))%>% #site_type and average_flower_cover from the top2 is lacking some rows, we'll get this variable from another dataframe 

  
  #join the plant data
  full_join(planty, by = c("Site" = "Site", "Transect"))%>%
  
  #remove extra columns
  #dplyr::select( -c("top2_ratio", "Site_type"))%>%
  #dplyr::select( -c("top2_ratio", "Floral_shannon_index"   , "Floral_species_richness"))%>%
  
  #add only simpson index from relative_flower 
  full_join(Floral_simpson_index_T, by= c("Site", "Transect"))%>%

  
  #fill in NA with 0 in the Pastinaca.sativa"   "Daucus.carota"   "top2_ratio" columns   
  mutate(across(c("Pastinaca.sativa", "Daucus.carota"), ~replace_na(., 0)))%>%
  mutate(across(c("top2_ratio"), ~replace_na(., 0)))%>%

  
  #change the date to a date format
  mutate(Date = as.Date(Date, format = "%Y-%m-%d"))%>%
  
  #create Days_since_start variable
  mutate(Days_since_start = as.numeric(Date - min(Date)+1))%>%
  
  #rename rows in Site_type column 1-5y to young_restored and Reference to reference
  mutate(Site_type = ifelse(Site_type == "1-5 y", "young_restored", "reference"))%>%
  
  distinct()

```

### III.A.4. Correlation matrix of environmental variables

At a transect level. 

```{r correlation matrix}
#correlation matrix of all the numerical environmental variables
tmp_cor_envir <- envir_data %>%
  select_if(is.numeric) %>%
  na.omit() %>%
  #remove minutes_since_9am column
  #select(-c("minutes_since_9am")) %>%
  mutate(across(everything(), scale))%>% # scale the data - Z-score standardization
  distinct()
  
tmp_qq_plots <- list()
# plot Q-Q plots for each variable
for (i in 1:ncol(tmp_cor_envir)) {
  tmp_qq_plots[[i]] <- ggplot(tmp_cor_envir, aes(sample = .data[[colnames(tmp_cor_envir)[i]]])) +
  stat_qq()+
  stat_qq_line()+
  ggtitle(str_wrap(colnames(tmp_cor_envir)[i], width = 20))+
  theme(plot.title = element_text(size = 10))  
}

tmp_qq_plots[[1]]; tmp_qq_plots[[2]]; tmp_qq_plots[[3]]; tmp_qq_plots[[4]]; tmp_qq_plots[[5]]; tmp_qq_plots[[6]]; tmp_qq_plots[[7]]; tmp_qq_plots[[8]]; tmp_qq_plots[[9]];tmp_qq_plots[[10]];tmp_qq_plots[[11]];tmp_qq_plots[[12]]; tmp_qq_plots[[13]];tmp_qq_plots[[14]]
#;tmp_qq_plots[[15]];tmp_qq_plots[[16]];tmp_qq_plots[[17]

```

```{r correlation plot}
tmp_env_cor_results <- rcorr(as.matrix(tmp_cor_envir), type = "spearman") 

# extract correlation matrix
tmp_env_cor_matrix <- tmp_env_cor_results$r

# extract the p-values
tmp_env_p_matrix <- tmp_env_cor_results$P

# plot correlation matrix (only insignificant ones hidden)
tmp_corr_num <- corrplot::corrplot(tmp_env_cor_matrix, 
         type = "upper",
         method = "color",
         diag = F,                         # remove diagonal
         #addCoef.col = "black",           # add coefficient coeffs, not used 
         p.mat = tmp_env_p_matrix,         # add p-values matrix
         sig.level = c(0.001, 0.01, 0.05), # significance thresholds
         tl.col = "black",                 # color of variable labels
         cl.align.text = "l",              # alignment of color legend
         cl.offset = 0.3,                  # offset color legend text to the right
         number.cex = 0.8,                 # size of coefficient text
         tl.cex	= 0.8,                     # size of variable labels
         insig = "label_sig",              # add stars according to significance thresholds
         pch.cex = 0.8)                      # size of stars

# save the plot as a png
dev.copy(png, "C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/figures/correlation_plot_num.png", width = 1600, height = 1600, res = 300)
dev.off()
```

### III.A.5. PCA of environmental variables

```{r PCA}
#PCA of the environmental data
tmp_cor_envir_pca <- tmp_cor_envir %>%
  #remove Na values
  na.omit() %>%
  prcomp(, scale = TRUE)

# plot the PCA
(tmp_cor_envir_pca_plot <- fviz_pca_biplot(tmp_cor_envir_pca, 
                                         geom = c("point", "text"), 
                                         col.var = "contrib", # color by contributions to axes
                                         gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"), #this gradient indicates the contribution of each variable to the axis
                                         repel = TRUE, # avoid text overlapping
                                         title = "PCA of Environmental Data"))
```

```{r removing temporary envir data}
# remove all dataframes with tmp_ prefix
rm(list = ls(pattern = "^tmp_"))
#rm(top2, landscape_data, dwd_weather, field_weather, start_net)
```

### III.A.6. Landcover class vs Site Type

We are going to create barplots comparing the environmental variables between the two site types. First we'll average the variables per site_type, then we'll plot the average values per site type.

 scale_fill_manual(values = c("agri" = "#D6CFB7FF", "grass" = "#6D8325FF", "snh" = "#647D4BFF", "forest" = "#121510FF", "urban" = "#FA6900FF", "water" = "#7FC7AFFF"))

```{r}
#average per site type
envir_data_avg <- envir_data %>%
  group_by(Site_type) %>%
  #summarize across all numerical variables
  summarise(across(where(is.numeric), mean, na.rm = TRUE)) %>%
  ungroup()%>%
  #remove irrelevant columns
  dplyr::select(-c("Days_since_start", "minutes_since_9am", "dm_wind_velocity", "dm_temperature"))

#barplot of the average snh  per site type
(snh <- 
  envir_data_avg %>%
  ggplot(aes(x = Site_type, y = snh)) +
  geom_bar(stat = "identity", fill = "#4B644BFF") +
  labs(title = "Average Surrounding Semi Natural Habitat Surface per Site Type",
       x = "Site type",
       y = "Average SNH") +
  theme(legend.position = "left"))+
  #y limit
  ylim(0, 60)

#barplot of the average water per site type
(water <- 
  envir_data_avg %>%
  ggplot(aes(x = Site_type, y = water)) +
  geom_bar(stat = "identity", fill = "#A9CCE3") +
  labs(title = "Average Surrounding Water Surface per Site Type",
       x = "Site type",
       y = "Average Water") +
  theme(legend.position = "left"))+
  #y limit
  ylim(0, 60)

#barplot of the average agri per site type
(agri <- 
  envir_data_avg %>%
  ggplot(aes(x = Site_type, y = agri)) +
  geom_bar(stat = "identity", fill = "#DABD61FF") +
  labs(title = "Average Surrounding Agricultural Surface per Site Type",
       x = "Site type",
       y = "Average Agri") +
  theme(legend.position = "left"))+
  #y limit
  ylim(0, 60)

#barplot of the average urban per site type
(urban <- 
  envir_data_avg %>%
  ggplot(aes(x = Site_type, y = urban)) +
  geom_bar(stat = "identity", fill = "#803342FF") +
  labs(title = "Average Surrounding Urban Surface per Site Type",
       x = "Site type",
       y = "Average Urban") +
  theme(legend.position = "left"))+
  #y limit
  ylim(0, 60)

#barplot of the average forest per site type
(forest <- 
  envir_data_avg %>%
  ggplot(aes(x = Site_type, y = forest)) +
  geom_bar(stat = "identity", fill = "#121510FF") +
  labs(title = "Average Surrounding Forest Surface per Site Type",
       x = "Site type",
       y = "Average Forest") +
  theme(legend.position = "left"))+
  #y limit
  ylim(0, 60)

#barplot of the average grassland per site type
(grassland <- 
  envir_data_avg %>%
  ggplot(aes(x = Site_type, y = grass)) +
  geom_bar(stat = "identity", fill = "#6D8325FF") +
  labs(title = "Average Surrounding Grassland Surface per Site Type",
       x = "Site type",
       y = "Average Grassland") +
  theme(legend.position = "left"))+
  #y limit
  ylim(0, 60)


envir_data_avg_long <- envir_data_avg %>%
  #keep only columns 1:7
  dplyr::select(1:7) %>%
  #long format to have stacked barplot
  pivot_longer(cols = c("agri", "grass", "snh", "forest", "urban", "water"), 
               names_to = "Landcover_class", 
               values_to = "Area_m2")

#stacked barplot of the average landcover per site type
(stack_land <- envir_data_avg_long %>%
  ggplot(aes(x = Site_type, y = Area_m2, fill = Landcover_class)) +
  geom_bar(stat = "identity", color="black", size= 0.2) +
  labs(title = "Average % per Landcover Class (1km Radius)",
       x = "Site type",
       y = "Average Area (m2)") +
  theme(legend.position = "right")+
  scale_fill_manual(
    values = c("agri" = "#DABD61FF", "grass" = "#A3A380", "snh" = "#4B644BFF", "forest" = "#121510FF", "urban" = "#803342FF", "water" = "#A9CCE3"),
    labels = c("agri" = "Agriculture", "grass" = "Grassland", "snh" = "Semi Natural Habitat", "forest" = "Forest", "urban" = "Urban", "water" = "Water"))+
    #legend title
  labs(fill = "Land cover class") +
  scale_x_discrete(labels = c(
  "young_restored" = "Young Restored",
  "reference" = "Reference")))

#save stacked barplot
ggsave("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/figures/stacked_barplot_landcover.png", 
       plot = stack_land, 
       width = 8, height = 4, dpi = 600)

    
  
#plot the data in a pie chart, facet per Site_type
(pie_land <- envir_data_avg_long %>%
  ggplot(aes(x = "", y = Area_m2, fill = Landcover_class)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar(theta = "y") +
  labs(title = "Average % per Landcover Class (1km Radius)",
       x = "",
       y = "") +
  theme_void() +
  facet_wrap(~ Site_type) +
  theme(legend.position = "right") +
  scale_fill_manual(values = c("agri" = "#DABD61FF", "grass" = "#A3A380", "snh" = "#4B644BFF", "forest" = "#121510FF", "urban" = "#803342FF", "water" = "#A9CCE3")))

```

### III.A.7. Flower survey vs site type

```{r}
#transform the plants dataframe into wide format to include all species at all sites with a 0 percentage 
# this is needed to have accurate percentage values for the average flower cover % per flower species per site type.  
avg_flower_long <- plants%>%
  dplyr::select(-BB)%>%
  #wide format, fill with 0
  pivot_wider(names_from = Plant_sp, values_from = Cover_percentage, values_fill = 0)%>%
  #long format
  pivot_longer(cols = 5:74, 
               names_to = "Plant_sp", 
               values_to = "Cover_percentage")


daucus <- avg_flower_long%>%
  #filter only daucus rows
  filter(grepl("Daucus", Plant_sp))%>%
  #average cover_percentage of daucus carota per site type 
  group_by(Site_type) %>%
  summarise(Cover_daucar_st = mean(Cover_percentage, na.rm = TRUE)) %>%
  ungroup()

#barplot of the average daucus cover per site type
(daucus_plot <- daucus %>%
  ggplot(aes(x = Site_type, y = Cover_daucar_st)) +
  geom_bar(stat = "identity", fill = "#A9CCE3") +
  labs(title = "Average Daucus Carota Cover % per Site Type",
       x = "Site type",
       y = "Average Daucus Carota Cover") +
  theme(legend.position = "left")+
  #y limit
  ylim(0, 100))

pastinaca <- avg_flower_long%>%
  #filter only daucus rows
  filter(grepl("Pastinaca sativa", Plant_sp))%>%
  #average cover_percentage of Pastinaca sativa per site type 
  group_by(Site_type) %>%
  summarise(Cover_passat_st = mean(Cover_percentage, na.rm = TRUE)) %>%
  ungroup()

#barplot of the average pastinaca cover per site type
(pastinaca_plot <- pastinaca%>%
  ggplot(aes(x = Site_type, y = Cover_passat_st)) +
  geom_bar(stat = "identity", fill = "#F5C542") +
  labs(title = "Average Pastinaca sativa Cover % per Site Type",
       x = "Site type",
       y = "Average Pastinaca sativa Cover") +
  theme(legend.position = "left")+
  #y limit
  ylim(0, 100))

#excluding passat and daucar
exc <- avg_flower_long%>%
  #filter everything but daucus and pastinaca
  filter(!grepl("Daucus|Pastinaca", Plant_sp))%>%
  #average cover_percentage of Pastinaca sativa per site type 
  group_by(Site_type, Plant_sp) %>%
  summarise(Cover_exc_st = mean(Cover_percentage, na.rm = TRUE)) %>%
  ungroup()%>%
  #sum up per site type
  group_by(Site_type) %>%
  summarise(Cover_exc_st = sum(Cover_exc_st, na.rm = TRUE)) %>%
  ungroup()

avg1 <- exc %>%
  #join daucus
  full_join(daucus, by = "Site_type") %>%
  #join pastinaca
  full_join(pastinaca, by = "Site_type")%>%
  #long format for stacked barplot
  pivot_longer(cols = c("Cover_daucar_st", "Cover_passat_st", "Cover_exc_st"), 
               names_to = "Plant_sp", 
               values_to = "Cover_percentage")

#stacked bar plot 
(avg2 <- avg1 %>%
  ggplot(aes(x = Site_type, y = Cover_percentage, fill = factor(Plant_sp, levels= c("Cover_exc_st", "Cover_passat_st","Cover_daucar_st")))) +
  geom_bar(stat = "identity", position = "stack",  color = "black", size = 0.2) +
  labs(title = "Average Flower Cover Percentage",
       x = "Site type",
       y = "Average Flower Cover %") +
  theme(legend.position = "bottom") +
      # Stacked legend items
  guides(fill = guide_legend(ncol = 1)) + # Set number of columns to 1 to stack vertically
  scale_fill_manual(
  values = c(
    "Cover_exc_st" = "#A3A380",
    "Cover_daucar_st" = "#A9CCE3",
    "Cover_passat_st" = "#DABD61FF"
  ),
  labels = c(
    "Cover_exc_st" = "Cover % all other flower species",
    "Cover_passat_st" = "Cover % Pastinaca sativa",
    "Cover_daucar_st" = "Cover % Daucus carota"
  )) +
    #legend title
  labs(fill = "") +
  scale_x_discrete(labels = c(
  "1-5 y" = "Young Restored",
  "Reference" = "Reference"
))+
  #y limit
  ylim(0, 15))

#average flower cover % with all flower speceis to compare to the previous plot
avg_full <- avg_flower_long%>%
  #keep all flower species
  #average cover_percentage per species per site type 
  group_by(Site_type, Plant_sp) %>%
  summarise(Cover_full = mean(Cover_percentage, na.rm = TRUE)) %>%
  ungroup()%>%
  #sum up per site type
  group_by(Site_type) %>%
  summarise(Cover_full = sum(Cover_full, na.rm = TRUE)) %>%
  ungroup()

# Do the total averages match ? Yes
sum(avg1$Cover_percentage[avg1$Site_type == "1-5 y"])==avg_full$Cover_full[avg_full$Site_type == "1-5 y"]
sum(avg1$Cover_percentage[avg1$Site_type == "Reference"])==avg_full$Cover_full[avg_full$Site_type == "Reference"]

```
    





## III.B. Traditional methods - NETTING
### III.B.1. Data preparation


```{r}
#change lowest_taxa to Coccinellidae any row that has Coccinellidae_
netting <- netting %>%
  mutate(lowest_taxa = ifelse(grepl("Coccinellidae_", lowest_taxa), "Coccinellidae", lowest_taxa))
```


### III.B.2. Data exploration

```{r}
#barplot of the number of each taxon caught in the netting per site
netting %>%
  #group by site and taxa
  group_by(site_type, lowest_taxa) %>%
  #count the number of each taxon caught
  summarise(Count = n()) %>%
  ggplot(aes(x = site_type, y = Count, fill = lowest_taxa)) +
  geom_bar(stat = "identity", color = "black") +
  labs(title = "Count of each taxon caught during transect walk",
       x = "Site",
       y = "Number of individuals caught") +
  #viridis  color palette for the taxa 
  #scale_fill_viridis_d(option = "rocket") +
  #scale_fill_manual(values = custom25) +  # Apply manually
  theme(legend.position = "none")


```
### III.B.2. Most visited flower species

```{r}
# find out which plant species are the most visited by pollinators
top_plants <- netting %>%
  group_by(plant_species) %>%
  summarise(total_interactions = sum(total_interaction, na.rm = TRUE)) %>%
  arrange(desc(total_interactions)) %>%
  head(10)
  
# Add a column to define the color category
top_plants$fill_color <- ifelse(top_plants$plant_species == "Daucus carota", "#A9CCE3",
                          ifelse(top_plants$plant_species == "Pastinaca sativa", "#DABD61FF", "#A3A380"))

#Plot the top 10 plant species
(top_plants_plot <- ggplot(top_plants, aes(x = reorder(plant_species, total_interactions), 
                       y = total_interactions, 
                       fill = fill_color)) +
  geom_bar(stat = "identity", width = 1, color ="black", size= 0.2) +
  scale_fill_identity() +
  labs(title = "Transect walk: 10 Most Visited Flower Species",
       x = "Plant Species",
       y = "Total flower/pollinator interactions") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, face = "italic")))
```
```{r}
#combine avg2 and top_plants_plot into one plot with a,b
library(cowplot)
(flower_visits <- cowplot::plot_grid(avg2 , top_plants_plot, labels = c("A", "B"),align = "h", axis = "tb", 
          rel_widths = c(1, 1), ncol = 2))

#save the plot 
# Save the plot with A4 dimensions (in cm) 
ggsave("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/figures/flower_visits_A4_cm.png", plot = flower_visits, 
       width = 21, height = 15, units = "cm", 
       dpi = 600, device = "png")

```


## III.C. Traditional methods - PAN TRAPS
### III.C.1. Data preparation

```{r}
#the transect values for pan_family are not in the same format as in the envir_data. let's change that
#changing the str to character and then adding a T before the transect number
pan_family <- pan_family %>%
  mutate(Transect = as.character(Transect)) %>%
  mutate(Transect = paste0("T", Transect))

#combine envir_data with pan_family data
pan_family1 <- pan_family %>%
  
  #right date format
  mutate(Date = as.Date(Date, format = "%Y-%m-%d"))%>%
  
  #join the envir_data with pan_family
  left_join(envir_data, by = c("Site", "Transect", "Date", "Site_type"))%>%
  
  #remove extra columns
  dplyr::select(-minutes_since_9am, -Days_since_start)
```

### III.C.2. Data exploration

```{r}
# scatterplot the number of taxa caught in the pan traps per transect depending on simpson index
pan_family1 %>%
  #remove 0 count values
  filter(Count > 0) %>%
  ggplot(aes(x = Floral_simpson_index_T, y = Count)) +
  geom_point(aes(color = Site), alpha = 5) +
  #geom_smooth(method = "lm", se = FALSE) +
  labs(title = "Number of individuals caught in pan traps per transect depending on simpson index",
       x = "Floral simpson index",
       y = "Number of individuals caught") +
  scale_color_manual(values = saturated_pal) +
  theme(legend.position = "left")

#stacked  barplot of the number of individuals caught in the pan traps per transect per site
pan_family1 %>%
  ggplot(aes(x = Site, y = Count, fill = Transect)) +
  geom_bar(stat = "identity") +
  labs(title = "Number of individuals caught in pan traps per transect per site",
       x = "Site",
       y = "Number of individuals caught") +
  #scale_fill_manual(values = saturated_pal) +
  theme(legend.position = "left")

custom25 <- paletteer_c("grDevices::Hawaii", n = 25) # Extract first 25 colors

#custom25 <- c(paletteer_d("khroma::light"),paletteer_d("ggprism::muted_rainbow"),paletteer_d("ggsci::default_flatui"))[1:25]  # Ensure exactly 25 colors


#barplot of the number of each taxon caught in the pan traps per site type
pan_family1 %>%
  #group by site and taxa
  group_by(Site, Site_type,Taxa) %>%
  #sum the count of each taxon
  summarise(Count = sum(Count)) %>%
  ggplot(aes(x = Site_type, y = Count, fill = Taxa)) +
  geom_bar(stat = "identity", color = "black") +
  labs(title = "Count of each taxon caught in pan traps per site",
       x = "Site",
       y = "Number of individuals caught") +
  #facet_wrap(~ Site_type) +
  #viridis  color palette for the taxa 
  #scale_fill_viridis_d(option = "rocket") +
  scale_fill_manual(values = custom25) +  # Apply manually
  theme(legend.position = "right")

#barplot of the number of each taxon caught in the pan traps per site
pan_family1 %>%
  #group by site and taxa
  group_by(Site, Site_type,Taxa) %>%
  #sum the count of each taxon
  summarise(Count = sum(Count)) %>%
  ggplot(aes(x = Site, y = Count, fill = Taxa)) +
  geom_bar(stat = "identity", color = "black") +
  labs(title = "Count of each taxon caught in pan traps per site",
       x = "Site",
       y = "Number of individuals caught") +
  #facet_wrap(~ Site_type) +
  #viridis  color palette for the taxa 
  #scale_fill_viridis_d(option = "rocket") +
  scale_fill_manual(values = custom25) +  # Apply manually
  theme(legend.position = "right")


#plot of count vs floral simpson index
pan_family1 %>%
  #remove 0 count values
  #filter(Count > 0) %>%
  ggplot(aes(x =Floral_simpson_index_T, y = Count)) +
  geom_point(aes(color = Site), alpha = 5) +
  #geom_smooth(method = "lm", se = FALSE) +
  labs(title = "Count vs Floral Simpson Index",
       x = "Floral Simpson Index",
       y = "Count") +
  scale_color_manual(values = saturated_pal) +
  theme(legend.position = "bottom")


pan_family1 %>%
  #remove 0 count values
  filter(Count > 0) %>%
  #remove count higher than 30
  #filter(Count < 30) %>%
  ggplot(aes(x = Site_type, y = Count)) +
  geom_boxplot(fill = "lightblue") +
  theme_minimal() +
  labs(y = "Total interactions", x = "Site Type")+
  theme(legend.position = "bottom")

```

### III.C.3. Pan traps vs InsectDetect
```{r insectdetect more than 0.5}
#barplot of the number of each taxon caught with the platform camera per site
platform_camera %>%
  #filter out top1 that start with none_ as they are not real taxa
  filter(!grepl("none_", top1)) %>%
  #remove top1_prob_weighted that are below 0.5
  #filter(top1_prob_weighted > 0.5) %>%
  #group by site and taxa
  group_by(location, top1) %>%
  #count the number of each top1 caught
  summarise(Count = n()) %>%
  ggplot(aes(x = location, y = Count, fill = top1)) +
  geom_bar(stat = "identity", color = "black") +
  labs(title = "Count of each taxon caught on platforms per site",
       x = "Site",
       y = "Number of individuals caught") +
  #viridis  color palette for the taxa 
  #scale_fill_viridis_d(option = "rocket") +
  scale_fill_manual(values = custom25) +  # Apply manually
  theme(legend.position = "left")
```

```{r combining pan traps and insectdetect}
# unify the taxa names in both datasets
tmp_pan_family <- pan_family%>%
 # adapt taxa categories to the ones used in platform data (less precise)
  mutate(Category = case_when(
    Taxa %in% c("cantharidae", "carabidae", "curculionidae", "elateridae",
                "mordellidae", "staphylinidae") ~ "beetle",
    Taxa %in% c("coccinellidae") ~ "beetle_cocci",
    Taxa %in% c("hemiptera") ~ "bug",
    Taxa %in% c("diptera","calliphoridae","cecidomyiidae","tachinidae","calliphoridae",
                "sepsidae","ephydridae","muscidae","asilidae","stratiomyidae", "polleniidae","acalyptrate" ) ~ "fly",
    Taxa %in% c("dasypoda","apidae","colletidae") ~ "bee_apis",
    Taxa %in% c("bombus") ~ "bee_bombus",
    Taxa %in% c("sarcophagidae") ~ "fly_sarco",
    Taxa %in% c("symphyta","apocrita","proctotrupidae","tenthredinidae") ~ "wasp",
    Taxa %in% c("empididae") ~ "fly_empi",
    TRUE ~ Taxa
    ))%>%
    #remove all rows that have a 0 "count" value
  filter(Count != 0) %>%
  
  #select only the relevant columns for the comparison
  dplyr::select(Site, Transect, Site_type, Category, Count)

#select only the relevant columns fo platform_camera for the comparison
tmp_platform_camera <- platform_camera %>%
  
  mutate(transect = as.character(transect)) %>%
  mutate(transect = paste0("T", transect))%>%
  
  #filter out top1 that start with none_ as they are not real taxa
  filter(!grepl("none_", top1)) %>%
  
  #remove top1_prob_weighted that are below 0.5
  filter(top1_prob_weighted > 0.5) %>%
  
  #group by site and taxa
  group_by(location,transect, top1) %>%
  
  #count the number of each top1 caught
  summarise(Count = n()) %>%
  ungroup() %>%
  
  #add empty Site_Type column
  mutate(Site_type = NA)%>%
  
  #remove columns that not needed for comparison with pan_family, rename top1 to Category
  dplyr::select(Site=location, Site_type,Transect=transect, Category = top1, Count)


#add method column to both pan_family and platform_camera
tmp_pan_family$Method <- "bowl_trap"
tmp_platform_camera$Method <- "platform_camera"

#combine the two datasets
tmp_combined <- rbind(tmp_pan_family, tmp_platform_camera)%>%
  #adapt empty Site_type following the Site column
  mutate(Site_type = ifelse(Site %in% c("DES", "HLI", "JEP", "STP", "WUP"), "reference", "young_restored"))

tmp_combined %>%
  mutate(
    Method = fct_recode(Method,
                        "Pan Trap" = "bowl_trap",
                        "Platform Camera" = "platform_camera"),
    Site_type = fct_recode(Site_type,
                           "Reference Site" = "reference",
                           "Young Restored Site" = "young_restored")
  ) %>%
  ggplot(aes(x = Site, y = Count, fill = Category)) +
  geom_bar(stat = "identity", position = "stack", color = "black", size= 0.2) +
  facet_wrap(~Method + Site_type, ncol = 2, scales = "free_x") +  # free_x allows each facet to drop empty Site slots 
  scale_x_discrete(drop = TRUE) +  # ensure unused levels are dropped
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Comparison of the two sampling methods",
       x = "Site",
       y = "Count")+
    scale_fill_manual(values = custom25)
  # Add confidence threshold annotation
  #annotate("text", x = Inf, y = Inf, label = paste("Confidence threshold:", 0.85), hjust = 1.1, vjust = 1.1, size = 3)

tmp_combined %>%
  mutate(
    Method = fct_recode(Method,
                        "Pan Trap" = "bowl_trap",
                        "Platform Camera" = "platform_camera"),
    Site_type = fct_recode(Site_type,
                           "Reference Site" = "reference",
                           "Young Restored Site" = "young_restored")
  ) %>%
  filter(Count > 0) %>%
  ggplot(aes(x = Site, y = Count, fill = Category)) +
  geom_bar(stat = "identity", position = "stack", color = "black", size= 0.2) +
  facet_grid(Method ~ Site_type,scales = "free_x", space = "free_x") +  # grid layout!
  scale_x_discrete(drop = TRUE) +
  #theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(#title = "Comparison of the Two Sampling Methods",
       x = "Site",
       y = "Count") +
  scale_fill_manual(values = custom25)

#save the plot
ggsave("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/figures/comparison_pan_platform.png", 
       plot = last_plot(), 
       width = 8, height = 6, dpi = 600)

sum(tmp_combined$Count[tmp_combined$Method == "bowl_trap"])
sum(tmp_combined$Count[tmp_combined$Method == "platform_camera"])
```

```{r}
library(ggplot2)
library(dplyr)
library(forcats)
library(patchwork)




# Common data prep
tmp_combined2 <- tmp_combined %>%
  mutate(
    Method = fct_recode(Method,
                        "Pan Trap" = "bowl_trap",
                        "Platform Camera" = "platform_camera"),
    Site_type = fct_recode(Site_type,
                           "Reference Site" = "reference",
                           "Young Restored Site" = "young_restored")
  ) %>%
  filter(Count > 0)

#color palette
categories <-  sort(unique(tmp_combined2$Category))

# Get 18 colors from your palette (same length as categories)
custom18 <- paletteer::paletteer_c("grDevices::Viridis", n = length(categories))

# Create the named color vector
custom18 <- setNames(custom18, categories)

# Base theme with horizontal site labels
base_theme <- theme(
  axis.text.x = element_text(angle = 0, hjust = 0.5),
  legend.position = "right"  # legend stays at bottom for each plot
)

# Plot 1: Pan Trap with y limit
p1 <- tmp_combined2 %>%
  filter(Method == "Pan Trap") %>%
  ggplot(aes(x = Site, y = Count, fill = Category)) +
  geom_bar(stat = "identity", position = "stack", color = "black", size = 0.2) +
  facet_grid(. ~ Site_type, scales = "free_x", space = "free_x") +
  scale_x_discrete(drop = TRUE) +
  labs(
    title = "Pan Trap",
    x = "Site",
    y = "Count"
  ) +
  scale_fill_manual(values = custom18) +
  ylim(0, 45) +
  guides(fill = guide_legend(ncol = 2))+
  base_theme

# Plot 2: Platform Camera (free y scale)
p2 <- tmp_combined2 %>%
  filter(Method == "Platform Camera") %>%
  ggplot(aes(x = Site, y = Count, fill = Category)) +
  geom_bar(stat = "identity", position = "stack", color = "black", size = 0.2) +
  facet_grid(. ~ Site_type, scales = "free_x", space = "free_x") +
  scale_x_discrete(drop = TRUE) +
  labs(
    title = "Platform Camera",
    x = "Site",
    y = "Count"
  ) +
  scale_fill_manual(values = custom18) +
  guides(fill = guide_legend(ncol = 2))+
  base_theme

# Combine plots (each with its own legend)
p1 / p2  # ⬅️ No "collect" = separate legends!

# Save the combined plot
ggsave("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/figures/comparison_pan_platform_TH0.5.png", 
       plot = last_plot(), 
       width = 8, height = 6, dpi = 600)
```



```{r interactive threshold adjustment}
library(shiny)
library(ggplot2)
library(dplyr)

# Define UI
ui <- fluidPage(
  titlePanel("Interactive Threshold Adjustment"),
  sidebarLayout(
    sidebarPanel(
      sliderInput("threshold", "Select top1_prob_weighted threshold:", 
                  min = 0.4, max = 1.0, value = 0.85, step = 0.01)
    ),
    mainPanel(
      plotOutput("barPlot"),
      verbatimTextOutput("counts")
    )
  )
)

# Define server logic
server <- function(input, output) {
  
  # Reactive dataset based on threshold
  filtered_data <- reactive({
    tmp_platform_camera <- platform_camera %>%
      mutate(transect = as.character(transect)) %>%
      mutate(transect = paste0("T", transect)) %>%
      filter(!grepl("none_", top1)) %>%
      filter(top1_prob_weighted > input$threshold) %>%
      group_by(location, transect, top1) %>%
      summarise(Count = n(), .groups = "drop") %>%
      mutate(Site_type = NA) %>%
      dplyr::select(Site = location, Site_type, Transect = transect, Category = top1, Count)
    
    tmp_pan_family$Method <- "bowl_trap"
    tmp_platform_camera$Method <- "platform_camera"
    
    tmp_combined <- rbind(tmp_pan_family, tmp_platform_camera) %>%
      mutate(Site_type = ifelse(Site %in% c("DES", "HLI", "JEP", "STP", "WUP"), 
                                "reference", "young_restored"))
    
    return(tmp_combined)
  })
  
  # Render plot
  output$barPlot <- renderPlot({
    ggplot(filtered_data(), aes(x = Site, y = Count, fill = Category)) +
      geom_bar(stat = "identity", position = "stack") +
      facet_wrap(~Method) +
      theme_minimal() +
      theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
      labs(title = "Comparison of the two sampling methods",
           x = "Site",
           y = "Count") +
      scale_fill_manual(values = custom25)
  })
  
  # Show sum of counts for each method
  output$counts <- renderText({
    data <- filtered_data()
    bowl_count <- sum(data$Count[data$Method == "bowl_trap"], na.rm = TRUE)
    platform_count <- sum(data$Count[data$Method == "platform_camera"], na.rm = TRUE)
    paste("Total Count (Bowl Trap):", bowl_count, "\nTotal Count (Platform Camera):", platform_count)
  })
}

# Run the application 
shinyApp(ui = ui, server = server)
```

```{r}
#remove all dataframes with tmp_ prefix
rm(list = ls(pattern = "^tmp_"))
```



## III.D. Automated methods - PLATFORM CAMERAS
### III.D.1. Data preparation

```{r}
str(platform_camera)

platform_camera <- platform_camera %>%
  #transect values from numbers 1-5 to T1-T5
  mutate(transect = as.character(transect)) %>%
  mutate(transect = paste0("T", transect))%>%
  #filter out top1 that start with none_ as they are not real taxa
  filter(!grepl("none_", top1))

#format date

platform_camera1 <- platform_camera %>%
  #right date format
  mutate(date = as.Date(date, format = "%Y-%m-%d"))%>%
  #join the envir_data with platform_camera
  left_join(envir_data, by = c("location"="Site","transect" ="Transect", "date"="Date"))%>%
  #remove extra columns
  dplyr::select(-minutes_since_9am)%>%
  
  #add column with recording time per transect from platform_logs_rec
  left_join(platform_logs_rec, by = c("location"="Site", "transect"="Transect", "cam_ID"))%>%
  
    #add minutes_since_9am column by mutating first_record_start_time from 2024-07-11T13:38:07Z to an hour (13) and minute (38) columns
  #mutate(first_record_start_time = gsub("T", " ", first_record_start_time)) %>%  # Replace 'T' with space
  #mutate(first_record_start_time = gsub("Z", "", first_record_start_time)) %>%  # Remove 'Z'
  #remove the seconds from the time
  #mutate(first_record_start_time = gsub(":(\\d{2})$", "", first_record_start_time)) %>%  # Remove seconds
  #remove the "yyyy-mm-dd " from the first_record_start_time
  #mutate(first_record_start_time = gsub(".* ", "", first_record_start_time)) %>%  # Remove date part
  #split the first_record_start_time into hour and minute columns
  mutate(Hour = as.integer(substr(first_record_start_time, 1, 2)),  # Extract hour
         Minute = as.integer(substr(first_record_start_time, 4, 5)))%>% # Extract minutes
  #add new column minutes since 9 am
  mutate(minutes_since_9am = (Hour - 9) * 60 + Minute)%>%
  #keep only first value of minutes_since_9am when site and transect are the same
  group_by(location, transect, date) %>%
  mutate(minutes_since_9am = first(minutes_since_9am)) %>%
  ungroup() %>%
  #remove unnecessary columns
  dplyr::select(-c("first_record_start_time", "Hour", "Minute"))#%>%

#barplot start time per site, colored by transect
platform_camera1 %>%
    ggplot(aes(x = location, y = minutes_since_9am, fill = transect)) +
  geom_bar(stat = "identity", position= "dodge") +
  labs(title = "Start time of transect walk per site",
       x = "Site",
       y = "Time (minutes since 9 am)") +
  theme(legend.position = "left")+
  #viridis
  scale_fill_viridis_d() 

platform_camera1 <- platform_camera1 %>%
 #scale these columns: "dm_wind_velocity" "dm_temperature" "agri" "grass" "snh" "forest" "urban" "water" "Pastinaca.sativa" "Daucus.carota" "top2_ratio" "Floral_simpson_index" "minutes_since_9am"  
  mutate(across(c("dm_wind_velocity", "dm_temperature", "agri", "grass", "snh", "forest", "urban", "water", "Pastinaca.sativa", "Daucus.carota", "top2_ratio", "Floral_simpson_index_T", "minutes_since_9am", "Days_since_start"), scale))

```

### III.D.2. Data exploration

```{r}
#barplot of the number of each taxon caught with the platform camera per site
platform_camera1 %>%
  #filter out top1 that start with none_ as they are not real taxa
  filter(!grepl("none_", top1)) %>%
  #remove top1_prob_weighted that are below 0.5
  filter(top1_prob_weighted > 0.5) %>%
  #group by site and taxa
  group_by(location, Site_type, top1) %>%
  #count the number of each top1 caught
  summarise(Count = n()) %>%
  ggplot(aes(x = location, y = Count, fill = top1)) +
  geom_bar(stat = "identity", color = "black") +
  labs(title = "Count of each taxon caught on platforms per site",
       x = "Site",
       y = "Number of individuals caught") +
  #viridis  color palette for the taxa 
  #scale_fill_viridis_d(option = "rocket") +
  scale_fill_manual(values = custom25) +  # Apply manually
  theme(legend.position = "right")

#barplot of the number of each taxon caught with the platform camera per site_type
platform_camera1 %>%
  #filter out top1 that start with none_ as they are not real taxa
  filter(!grepl("none_", top1)) %>%
  #remove top1_prob_weighted that are below 0.5
  filter(top1_prob_weighted > 0.5) %>%
  #group by site and taxa
  group_by(location, Site_type, top1) %>%
  #count the number of each top1 caught, and divide by 5 if it's a reference site, and by 4 if it's a young restored site
  
  summarise(Count = n()) %>%
  ggplot(aes(x = Site_type, y = Count, fill = top1)) +
  geom_bar(stat = "identity", color = "black") +
  labs(title = "Count of each taxon caught on platforms per site type",
       x = "Site type",
       y = "Number of individuals caught") +
  #viridis  color palette for the taxa 
  #scale_fill_viridis_d(option = "rocket") +
  scale_fill_manual(values = custom25, name= "Taxa") +  # Apply manually
  theme(legend.position = "right")
```



## III.E. Automated methods - FLOWER CAMERAS
### III.E.1. Data preparation

```{r structure}
#change format of "time" column from hh-mm-ss to hh:mm:ss
flower_camera <- flower_camera %>%
  mutate(time = gsub("\\-", ":", time)) %>%  # Replace '-' with ':'
  mutate(time = chron::times(time))%>%  # Convert to time-only format
  #change format of "date" 
  mutate(date = as.Date(date, format = "%Y-%m-%d"))

str(flower_camera)
```


```{r all data from flower cameras}
custom193 <- paletteer_c("ggthemes::Sunset-Sunrise Diverging", n = 193)

# Replace "other_families" with gray
custom193_named <- setNames(custom193, sort(unique(flower_camera$Classification_Category)))
custom193_named["other_families"] <- "gray50"  # Adjust shade if needed

#plot of the number of each taxon caught in the flower cameras per site
flower_camera %>%
  #summarise per site and count the number of each taxon caught
  group_by(site, Classification_Category) %>%
  summarise(Count = n(), .groups = "drop") %>%
  
  ggplot(aes(x = site, y = Count, fill = Classification_Category)) +
  geom_bar(stat = "identity") +
  labs(title = "Count of each taxon caught with flower cameras per site",
       x = "Site",
       y = "Number of detections") +
  theme(legend.position = "none") +
  scale_fill_manual(values = custom193_named)   # Apply manually
```

```{r threshold adjustment plotting}
#remove rows with Classification_Category "other_families"
flower_camera <- flower_camera %>%
 #filter out the rows where Classification_Category is "other_families"
  filter(Classification_Category != "other_families")
  
  
## Define THRESHOLD ----
TH <- 0.5

#histogram of the Family_Confidence
flower_camera %>%
  ggplot(aes(x = Family_Confidence)) +
  geom_histogram(binwidth = 0.05, fill = "lightblue", color = "black") +
  labs(title = "Histogram of Family Confidence",
       x = "Family Confidence",
       y = "Count")+
  #add a vertical line at the threshold
  geom_vline(xintercept = TH, color = "red", linetype = "dashed")+  
  # Add confidence threshold annotation
  annotate("text", x = Inf, y = Inf, label = paste("Confidence threshold:", TH), 
           hjust = 1.1, vjust = 1.1, size = 3, color = "red")

#new dataframe above TH
flower_camera_light <- flower_camera %>%
  #remove path column
  dplyr::select(-Image_Path) %>%
  #filter out the rows where Family_Confidence is below the threshold
  filter(Family_Confidence > TH) %>% 
  #fill Site_type column with reference or young_restored
  mutate(Site_type = ifelse(site %in% c("DES", "HLI", "JEP", "STP", "WUP"), "reference", "young_restored"))
  
#calculate the proportion of rows removed
diff <- nrow(flower_camera) - nrow(flower_camera_light)
prop <- diff / nrow(flower_camera) 

#print 
print(paste("By removing rows with a probality score below the threshold", TH, ", we remove", round(prop,2), "of the data."))
#remove 
rm(diff, prop)

#plot of the number of each taxon caught in the flower cameras per site
flower_camera_light %>%
  #summarise per site and count the number of each taxon caught
  group_by(site, Classification_Category) %>%
  summarise(Count = n(), .groups = "drop") %>%
  
  ggplot(aes(x = site, y = Count, fill = Classification_Category)) +
  geom_bar(stat = "identity") +
  labs(title = "Count of each taxon caught in flower cameras per site",
       x = "Site",
       y = "Number of individuals caught") +
  theme(legend.position = "none") +
  scale_fill_manual(values = custom193_named)  +  
  # Add confidence threshold annotation
  annotate("text", x = Inf, y = Inf, label = paste("Probability threshold:", TH), 
           hjust = 1.1, vjust = 1.1, size = 3)

#plot of the number of each taxon caught in per flower species 
flower_camera_light %>%
  #summarise per site and count the number of each taxon caught
  group_by(site, Classification_Category, flower_sp) %>%
  summarise(Count = n(), .groups = "drop") %>%
  
  ggplot(aes(x = flower_sp, y = Count, fill = Classification_Category)) +
  geom_bar(stat = "identity") +
  labs(title = "Count of each taxon caught in flower cameras per flower species",
       x = "Flower Species",
       y = "Number of detections") +
  theme(legend.position = "none") +
  #slant the x-axis labels
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_fill_manual(values = custom193_named) +  
  # Add confidence threshold annotation
  annotate("text", x = Inf, y = Inf, label = paste("Probability threshold:", TH), 
           hjust = 1.1, vjust = 1.1, size = 3)
```

### III.E.2. Data exploration - Individuals vs time

```{r individuals vs time}
#plot of the number of individuals caught in the flower cameras over time
# Convert time to POSIXct by combining with the date
binned_data <- flower_camera_light %>%
  mutate(
    datetime = as.POSIXct(paste(date, time), format = "%Y-%m-%d %H:%M:%S"),  # Ensure proper datetime format
    time_bin = floor_date(datetime, "10 minutes"))%>%  # Bin into 5-minute chunks
  #remove date from the time_bin column
  mutate(time_bin = format(time_bin, "%H:%M:%S"))

# Summarize count of individuals per order per time bin
binned_data <- binned_data %>%
  group_by(date,site,time_bin, Family) %>%
  summarise(Count = n(), .groups = "drop")%>%
  #change time_bin to a character
  mutate(time_bin = as.character(time_bin))

# Plot the data
ggplot(binned_data, aes(x = time_bin, y = Count, fill = Family)) +
  geom_bar(stat = "identity")+
  labs(
    title = "Number of Individuals Per Family Over Time (10-min Bins)",
    x = "Time (10-minute bins)",
    y = "Count of Individuals"
  ) +
  facet_wrap(~site) +
  theme_minimal() +
  theme(legend.position = "none")+
  # format x-axis to show labels every hour
  scale_x_discrete(
      breaks = binned_data$time_bin[grepl("00:00$|30:00$", binned_data$time_bin)],
      labels = gsub(":00$", "", binned_data$time_bin[grepl("00:00$|30:00$", binned_data$time_bin)]))+
  #slant the x-axis labels
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) 
  #scale_color_manual(values = custom193_named)   # Apply manually

#rm(binned_data)

#linear model of the number of individuals caught in the flower cameras over time
```



### III.E.3. Data exploration - Daucus carota

Here, we'll focus on the Daucus carota species, as it is a common plant species in the study area and is known to attract a variety of pollinators. 

Since the cameras didn't have an ID tracking system, we'll have a look at taxonomic richness and relative abundance of pollinators attracted to Daucus carota.

```{r daucus carota both methods}
daucus_cam <- flower_camera_light %>%
  #filter out the rows where the flower species is Daucus.carota
  filter(flower_sp == "Daucus carota") %>%
  group_by(site) %>%
  summarise(unique_families = unique(Classification_Category),
            .groups = "drop")%>%
  #add Count column filled with 1 
  mutate(Count = 1)

#same thing with netting
daucus_net <- netting %>%
  #filter out the rows where the flower species is Daucus.carota
  filter(plant_species == "Daucus carota") %>%
  group_by(site) %>%
  summarise(unique_families = unique(family),
            .groups = "drop")%>%
  #add Count column filled with 1 
  mutate(Count = 1)

# Combine both datasets, adding a column to differentiate methods
daucus <- bind_rows(
  daucus_cam %>% mutate(method = "Camera"),
  daucus_net %>% mutate(method = "Net")
)

#combining all the unique families caught on Daucus with nets and cameras
fams <- sort(unique(daucus$unique_families));length(fams) # Get unique families sorted alphabetically
customfam <- paletteer_c("pals::kovesi.rainbow_bgyrm_35_85_c69", n = length(fams))
customfam <- setNames(customfam, fams)

# Create a single ggplot with faceting
final_plot1 <- ggplot(daucus, aes(x = site, y = Count, fill = unique_families)) +
  geom_bar(stat = "identity") +
  facet_wrap(~method, ncol = 1) +  # Separate plots
  labs(title = "Pollinator Family richness caught on Daucus carota",
       x = "Site",
       y = "Number of unique families caught") +
  theme(legend.position = "none") +  # Shared legend at bottom
  scale_fill_manual(values = customfam)  # Consistent colors

# Create a single ggplot with faceting
final_plot2 <- ggplot(daucus, aes(x = method, y = Count, fill = unique_families)) +
  geom_bar(stat = "identity") +
  labs(title = "Pollinator Family richness caught on Daucus carota",
       x = "Site",
       y = "Number of unique families caught") +
  theme(legend.position = "none") +  # Shared legend at bottom
  scale_fill_manual(values = customfam)  # Consistent colors

# Print the final plot
print(final_plot1); print(final_plot2)
```

```{r}
rm(daucus_cam, daucus_net, fams, customfam, final_plot1, final_plot2)
```






# IV. Modelling

*Key Metric	Meaning*    

- AICc (Akaike Information Criterion, corrected)	Measures model fit while penalizing complexity. Lower = better.
- BIC (Bayesian Information Criterion)	Similar to AIC but penalizes complexity more harshly. Lower = better.
- R² (Conditional & Marginal)	Measures variance explained by fixed & random effects. Higher = better.
- ICC (Intraclass Correlation Coefficient)	Proportion of variance explained by random effects. Higher = more site-level variation.
- RMSE (Root Mean Square Error)	Measures prediction error. Lower = better.


## IV.A. Flower survey data

For the flower survey data, we have data at the plot level, but we'll average them to transect level, as it is the same level as the netting, pan traps and platform data.

### IV.A.1. Flower survey - Linear mixed model with random effect - lmer 

```{r fig.width=6, fig.height=6}
scaled_envir_data <-envir_data %>%
  
  #z transform the numerical columns, except Floral_simpson_index
  mutate(across(where(is.numeric) & !contains("Floral_simpson_index"), scale))

#checking the values
scaled_envir_data%>%
  mutate(across(where(is.numeric)))%>%
  #summary()%>%
  sapply(sd)
  
scaled_envir_data%>%
  ggplot(aes(x=Floral_simpson_index_T))+
  geom_histogram(binwidth = 0.1, fill = "lightblue", color = "black")+
  labs(title = "Histogram of Floral Simpson Index",
       x = "Floral Simpson Index",
       y = "Count")

# is the floral simpson index normally distributed?
shapiro.test(scaled_envir_data$Floral_simpson_index_T) # p-value = 0.02828, so it is not normally distributed
datawizard::describe_distribution(scaled_envir_data$Floral_simpson_index_T)

# Create a linear model
# full model with Floral_simpson_index as response variable and structure around  the sites as explanatory variables, and site as random effect
plantsimp_mod1_full <- lmer(Floral_simpson_index_T
                            ~ Site_type
                            + majority_class 
                            + Plot_Cover_T
                            #+ agri + grass + snh + forest + urban + water
                            + (1|Site), data = scaled_envir_data)

summary(plantsimp_mod1_full)
parameters(plantsimp_mod1_full)
#checking the model
check_model(plantsimp_mod1_full)
#overdispersion
check_overdispersion(plantsimp_mod1_full)
#collinearity
check_collinearity(plantsimp_mod1_full)
# Compute fitted values and Pearson residuals
plantsimp_mod1_vals <- fitted(plantsimp_mod1_full)
plantsimp_mod1_residuals <- residuals(plantsimp_mod1_full, type = "pearson")
# Create binned residuals plot
arm::binnedplot(plantsimp_mod1_vals, plantsimp_mod1_residuals)
#DHARMa package - simulate residuals and check model assumptions
plantsimp_mod1_sim_res <- simulateResiduals(fittedModel = plantsimp_mod1_full)
plot(plantsimp_mod1_sim_res)
testDispersion(plantsimp_mod1_full) 
```

```{r plantsimp_mod1_beta, fig.width=6, fig.height=6}
plantsimp_mod1_beta <- glmmTMB(Floral_simpson_index_T 
                               ~ Site_type 
                               + majority_class #majority labndcover class in 1km buffer zone around the site
                               #+ agri + grass + snh + forest + urban + water
                               + Plot_Cover_T 
                               + top2_ratio
                               + (1|Site),
                    #ziformula = ~1,  # allows zero-inflation if needed
                    family = beta_family(),
                    data = scaled_envir_data)

summary(plantsimp_mod1_beta)
parameters(plantsimp_mod1_beta)

#checking the model
check_model(plantsimp_mod1_beta)
#overdispersion
check_overdispersion(plantsimp_mod1_beta)
#collinearity
check_collinearity(plantsimp_mod1_beta)
# Compute fitted values and Pearson residuals
plantsimp_mod1_beta_vals <- fitted(plantsimp_mod1_beta)
plantsimp_mod1_beta_residuals <- residuals(plantsimp_mod1_beta, type = "pearson")
# Create binned residuals plot
arm::binnedplot(plantsimp_mod1_beta_vals, plantsimp_mod1_beta_residuals)
#DHARMa package - simulate residuals and check model assumptions
plantsimp_mod1_beta_sim_res <- simulateResiduals(fittedModel = plantsimp_mod1_beta)
plot(plantsimp_mod1_beta_sim_res)
```

#### IV.A.1.a. Visualize the model

```{r }
#plot_model(plantsimp_mod1_beta , type = "est", show.values = TRUE, value.offset = .3, title = "Flower survey: Floral Simpson Index") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(
    title = "Flower survey: Floral Simpson Index",
    x = "Predictor",
    y = "Estimate")


(flower_survey_est <- plot_model(plantsimp_mod1_beta, 
           type = "est", 
           show.values = TRUE, 
           value.offset = 0.3,
           #sort.est = TRUE,
           axis.labels = c("Top 2 Flower Ratio",
                           "Flower Cover % per transect",  
                           "Urban (1km Buffer)",  
                           "Grassland (1km Buffer)",  
                           "Forest (1km Buffer)", 
                           "Young Restored Site")) +
    labs(title = "Floral Simpson Index", x = "Predictors",y = "Estimate") + 
    theme(axis.text.y = element_text(hjust = 0)))  # 0 = left, 1 = right
```

```{r plot plantsimp_mod1_full prediction}
## plot cover plantsimp_mod1_full ---------
# Get the original mean and SD of Plot_Cover_T before scaling
plot_cover_mean <- mean(envir_data$Plot_Cover_T, na.rm = TRUE)
plot_cover_sd <- sd(envir_data$Plot_Cover_T, na.rm = TRUE)
# Get predictions on the scaled variable
pred_plot_cover <- ggpredict(plantsimp_mod1_beta , terms = "Plot_Cover_T")
# Unscale the x-axis
pred_plot_cover$x_unscaled <- (pred_plot_cover$x * plot_cover_sd) + plot_cover_mean
# Plot

(coverperc <- ggplot(pred_plot_cover, aes(x = x_unscaled, y = predicted)) +
  geom_line(size = 1.2, color = predictor_colors[["Plot_Cover_T"]]) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), 
              fill = alpha(predictor_colors[["Plot_Cover_T"]], 0.5)) +
  labs(
    title = "Predicted Floral Simpson Index vs Flower Cover %",
    x = "Flower Cover per transect (%)",
    y = "Predicted Floral Simpson Index"
  ))

#cowplot the two plots
cowplot::plot_grid(flower_survey_est, coverperc, rel_widths = c(1.2, 1), ncol = 2, labels = c("A", "B"), label_size = 12) +
  theme(plot.title = element_text(hjust = 0.5))


ggsave("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/figures/flower_survey_estimates.png",
       width = 10, height = 6, dpi = 600)

rm(coverperc, flower_survey_est)
```

```{r}
# Make predictions at -1 SD, mean (0), and +1 SD of flower cover
new_data <- data.frame(
  Site_type = "reference",  # pick your reference level
  majority_class = "grass",  # pick your reference level
  Plot_Cover_T = c(-1, 0, 1),  # -1 SD, mean, +1 SD
  top2_ratio = 0,  # set other numeric predictors at their mean (which is 0 if scaled)
  Site = NA  # random effect NA for population-level prediction
)

# Predict (on response scale, i.e., Floral Simpson Index)
pred <- predict(plantsimp_mod1_beta, 
                newdata = new_data, 
                type = "response", 
                se.fit = TRUE)

# Combine predictions into a table
results <- new_data %>%
  mutate(
    Predicted_Diversity = pred$fit,
    SE = pred$se.fit,
    Lower_CI = pred$fit - 1.96 * pred$se.fit,
    Upper_CI = pred$fit + 1.96 * pred$se.fit
  )

print(results)

```

#### IV.A.1.b. Flower Survey Model Interpretation of Results

- **Model Type**: Generalized linear mixed-effects model (`glmmTMB`)
  - **Family**: Beta distribution with a logit link (suitable for proportions between 0 and 1)
  - **Random Effect**: `Site` (included as random intercept)
  
- **Model's Assumptions**:
  - **Distribution**: Beta distribution is appropriate for the response variable (bounded between 0 and 1), not normally distributed.
  - **No overdispersion**: Dispersion ratio close to 1 (1.052, *p* = 0.776).
  - **No multicollinearity**: All predictors have low variance inflation factors (all VIF below 2.5)
  - **Singular fit warning**: While the model reported a potential singular fit due to an extremely small random effect variance for `Site` (SD ≈ 9.3e-06), this suggests that most of the variation was captured by the fixed effects, and random intercepts contributed minimally. 
  - **Residual diagnostics**: No significant issues detected (e.g., no zero-inflation, no major residual structure, no significant outliers)

- **Response Variable**:  
  - `Floral_simpson_index_T` — Floral Simpson diversity index at a transect level. 

- **Fixed Effects Included**:
  - `Site_type` — young restored vs reference
  - `majority_class` — Dominant land cover type in 1 km buffer at site level (e.g., forest, grassland, urban)
  - `Plot_Cover_T` — Total flower cover in % per transect (scaled)
  - `top2_ratio` — Relative dominance ratio of the two most abundant species at a transect level (scaled)

- **Results**:
  - **Total plant cover (`Plot_Cover_T`)** had a **strong, significant negative effect** on floral diversity  
    - *Estimate = -0.638, p < 0.001*
  - **Other predictors** (site type, land cover class, species dominance) had **non-significant effects**
  - **Random effect (`Site`)** showed **negligible variance**, suggesting minimal site-to-site variation after accounting for fixed effects

- **Interpretation**:
  - Higher flower cover percentage was associated with **lower floral diversity** — possibly due to competitive exclusion or dominance of a few species. 
  - Local vegetation structure (cover) had more influence than broader landscape context (site type or surrounding land cover)


## IV.B. Netting data

For the netting data, the predictor variables are:
- Floral Simpson Index
    + Simpson index captures dominant flowering species, aligning with the nested structure of plant–pollinator networks: many specialists rely on a few generalists. This skewed interaction pattern makes generalist flowers key to maintaining pollinator communities, justifying their emphasis in diversity modeling.
- Minutes since 9 am
    + Time since 9 am, to account for the time of day. Each netting session is made to be 30 minutes of active netting, so the sampling effort is the same for all transects. 
- Top 2 ratio
    + Relative abundance ratio of D. carota and P. sativa combined, used as a proxy for dominance shifts.
- Site type
    + Young restored sites (1 to 5 years ago) vs reference sites.
- Daily mean wind velocity
    + Daily mean wind velocity (m/s) measured at the nearest weather station to account for weather conditions.
- Daily mean temperature
    + Daily mean temperature (°C) measured at the nearest weather station to account for weather conditions.
- Days since start
    + Days since the start of the sampling to account for seasonal effects.
    
Majority class or land cover type (agri, grass, snh, forest, urban, water) were not included in the model.
Since we have only 5 transects per site (5x9= 45 units), we need to be careful with the number of predictors we include in the model. The following variables were not included in the model, because they were not significant for the floral simpson index, and because they are not very precise (100m resolution), and would not show a meaningful impact on our sites. (For example, for categories like agricultural areas, the type of crop cultivated is not known which could have a big impact on the floral diversity). 

### IV.B.1. NETTING Interaction counts - Poisson
```{r prepare data}
#scale the last envir_data - Floral simpson_index
scaled_envir_data <- envir_data %>%
  #z transform the numerical columns, exceptFloral_simpson_index_T
  mutate(across(where(is.numeric), scale))

netting1 <- netting %>%
  #right date format
  mutate(date = as.Date(date, format = "%Y-%m-%d"))%>%
  #summarize by site, transect
  group_by(site, transect) %>%
  summarise(total_interaction_T = sum(total_interaction), .groups = "drop")%>%
   #join the envir_data with netting
  left_join(scaled_envir_data, by = c("site"="Site", "transect"="Transect"))

#histogram of total_interaction_T
netting1 %>%
  ggplot(aes(x = total_interaction_T)) +
  geom_histogram(fill = "lightblue", color = "black") +
  labs(title = "Histogram of Transect Walk Counts",
       x = "total interactions",
       y = "Count")
```

The first model has too many predictors and is over fitting the data. 
A lot of the predictors are significant, but the assumptions of the model are not met (overdispersion(p < 0.001), S-shape around qqplot, and the residuals appear to be heteroskedastic (residuals vs predicted plot)). 
We will be removing predictors one by one and checking the model assumptions after each step. 

The comparison of the models shows that the model with the lowest AICc and BIC is the third model (netting_mod3_full), which has the lowest AICc and BIC values. However, even in this model, the AICc and BIC values are quite high, indicating that the model is not the best fit for the data. In the next step, we will try to run a negative binomial model to see if it improves the fit of the model.

#### IV.B.1.a. Interpretation of results for POISSON GLMM
**netting_mod3_full**
netting_mod3_full <- glmer(total_interaction_T 
                           ~Floral_simpson_index_T 
                           + minutes_since_9am
                           + top2_ratio
                           + Site_type
                           + dm_wind_velocity
                           + (1|site), 
                           data = netting1, family = "poisson")
*Model summary:*
- has 5 predictors and one random effect
- has a significant effect of the floral simpson index (p < 0.001), time category (p < 0.001), top2_ratio (p < 0.001), has a significant effect of dm_wind_velocity (p = 0.014 )
- has a marginal effect of site type (p = 0.051)

*Model assumptions:*
- Over dispersion was detected (p < 0.001) with the performance package check_overdispersion()
    + another model could be used - *negative binomial*
    + the DHARMa qqplot showed the same pattern - dispersion is not normal (p < 0.001)
- the DHARMa qqplot also indicated significant outliers. 
- Correlation is low between predictors (VIF < 2) with the performance package check_collinearity()
- The binned residuals plot from the arm package shows no clear trend.


### IV.B.2. NETTING - Interaction counts NB

We start again with the full model, but this time we use a negative binomial distribution.

```{r netting_mod1_NB, fig.width=6, fig.height=6}
# full model with interaction counts as response variable and environmental, weather and plant diversity variables as explanatory variables, and site as random effect
# negative binomial distribution

netting_mod1_NB <- glmer.nb(total_interaction_T 
                            ~Floral_simpson_index_T 
                            + minutes_since_9am
                            + top2_ratio
                            + Site_type
                            + dm_wind_velocity
                            + dm_temperature
                            + Plot_Cover_T
                            #+  majority_class
                            #+ urban + agri + grass + snh + forest + water
                            + Days_since_start
                            + (1|site), 
                            data = netting1, 
                            family = nbinom2)

summary(netting_mod1_NB)
parameters(netting_mod1_NB)
  
#check the model
check_model(netting_mod1_NB, verbose = T)

#overdispersion
check_overdispersion(netting_mod1_NB)
#collinearity
check_collinearity(netting_mod1_NB)

# Compute fitted values and Pearson residuals
netting_mod1_NB_vals <- fitted(netting_mod1_NB)
netting_mod1_NB_residuals <- residuals(netting_mod1_NB, type = "pearson")

# Create binned residuals plot
arm::binnedplot(netting_mod1_NB_vals, netting_mod1_NB_residuals)

#DHARMa package - simulate residuals and check model assumptions
netting_mod1_NB_sim_res <- simulateResiduals(fittedModel = netting_mod1_NB)
plot(netting_mod1_NB_sim_res)
```

With this model, the assumptions are met (qqplot is normal, no overdispersion, and the residuals are homoscedastic). There are still too many predictors for the amount of data we have, so we will remove the predictors one by one and check the model assumptions after each step.

```{r netting_mod2_NB, fig.width=6, fig.height=6}

# full model with interaction counts as response variable and environmental, weather and plant diversity variables as explanatory variables, and site as random effect
# remove minutes_since_9am (p= 0.376 for netting_mod1_NB)

netting_mod2_NB <- glmer.nb(total_interaction_T 
                           ~Floral_simpson_index_T 
                           #+ minutes_since_9am
                           + top2_ratio
                           + Site_type
                           + dm_wind_velocity
                           + dm_temperature
                           + Plot_Cover_T
                           #+  majority_class
                           #+ urban + agri + grass + snh + forest + water
                           + Days_since_start
                           + (1|site), 
                           data = netting1,
                           family = nbinom2)

summary(netting_mod2_NB)
parameters(netting_mod2_NB)

#check the model
check_model(netting_mod2_NB, verbose = T)
#overdispersion
check_overdispersion(netting_mod2_NB)
#collinearity
check_collinearity(netting_mod2_NB)

# Compute fitted values and Pearson residuals
netting_mod2_NB_vals <- fitted(netting_mod2_NB)
netting_mod2_NB_residuals <- residuals(netting_mod2_NB, type = "pearson")

# Create binned residuals plot
arm::binnedplot(netting_mod2_NB_vals, netting_mod2_NB_residuals)
#DHARMa package - simulate residuals and check model assumptions
netting_mod2_NB_sim_res <- simulateResiduals(fittedModel = netting_mod2_NB)
plot(netting_mod2_NB_sim_res)

```

```{r netting_mod3_NB, fig.width=6, fig.height=6} 
# full model with interaction counts as response variable and environmental, weather and plant diversity variables as explanatory variables, and site as random effect
# remove days since start ( p= 0.441  for netting_mod2_NB)

netting_mod3_NB <- glmer.nb(total_interaction_T 
                           ~Floral_simpson_index_T 
                           #+ minutes_since_9am
                           + top2_ratio
                           + Site_type
                           + dm_wind_velocity
                           + dm_temperature
                           + Plot_Cover_T
                           #+  majority_class
                           #+ urban + agri + grass + snh + forest + water
                           #+ Days_since_start
                           + (1|site), 
                           data = netting1,
                           family = nbinom2)

summary(netting_mod3_NB)
parameters(netting_mod3_NB)

#check the model
check_model(netting_mod3_NB, verbose = T)
#overdispersion
check_overdispersion(netting_mod3_NB)
#collinearity
check_collinearity(netting_mod3_NB)

# Compute fitted values and Pearson residuals
netting_mod3_NB_vals <- fitted(netting_mod3_NB)
netting_mod3_NB_residuals <- residuals(netting_mod3_NB, type = "pearson")

# Create binned residuals plot
arm::binnedplot(netting_mod3_NB_vals, netting_mod3_NB_residuals)
#DHARMa package - simulate residuals and check model assumptions
netting_mod3_NB_sim_res <- simulateResiduals(fittedModel = netting_mod3_NB)
plot(netting_mod3_NB_sim_res)

```

```{r netting_mod4_NB, fig.width=6, fig.height=6}
#  model with pollinator interaction counts as response variable and environmental, weather and plant diversity variables as explanatory variables, and site as random effect
# remove dm temperature (p= 0.266  for netting_mod3_NB)
netting_mod4_NB <- glmer.nb(total_interaction_T 
                           ~Floral_simpson_index_T 
                           #+ minutes_since_9am
                           + top2_ratio
                           + Site_type
                           + dm_wind_velocity
                           + Plot_Cover_T
                           #+ dm_temperature
                           #+  majority_class
                           #+ urban + agri + grass + snh + forest + water
                           #+ Days_since_start
                           + (1|site), 
                           data = netting1, 
                           family = nbinom2)

summary(netting_mod4_NB)
parameters(netting_mod4_NB)

#check the model
check_model(netting_mod4_NB, verbose = T)

#overdispersion
check_overdispersion(netting_mod4_NB)
#collinearity
check_collinearity(netting_mod4_NB)

# Compute fitted values and Pearson residuals
netting_mod4_NB_vals <- fitted(netting_mod4_NB)
netting_mod4_NB_residuals <- residuals(netting_mod4_NB, type = "pearson")
# Create binned residuals plot
arm::binnedplot(netting_mod4_NB_vals, netting_mod4_NB_residuals)

#check singularity
isSingular(netting_mod4_NB)
#DHARMa package - simulate residuals and check model assumptions
netting_mod4_NB_sim_res <- simulateResiduals(fittedModel = netting_mod4_NB)
plot(netting_mod4_NB_sim_res)
```

```{r netting_mod5_NB, fig.width=6, fig.height=6}
#removing floral_simpson (p=0.1731 for netting_mod4_NB)
netting_mod5_NB <- glmer.nb(total_interaction_T 
                           #~Floral_simpson_index_T 
                           #+ minutes_since_9am
                           ~ top2_ratio
                           + Site_type
                           + dm_wind_velocity
                           + Plot_Cover_T
                           #+ dm_temperature
                           #+  majority_class
                           #+ urban + agri + grass + snh + forest + water
                           #+ Days_since_start
                           + (1|site), 
                           data = netting1, 
                           family = nbinom2)

summary(netting_mod5_NB)
parameters(netting_mod5_NB)
#check the model
check_model(netting_mod5_NB, verbose = T)
#overdispersion
check_overdispersion(netting_mod5_NB)
#collinearity
check_collinearity(netting_mod5_NB)

# Compute fitted values and Pearson residuals
netting_mod5_NB_vals <- fitted(netting_mod5_NB)
netting_mod5_NB_residuals <- residuals(netting_mod5_NB, type = "pearson")
# Create binned residuals plot
arm::binnedplot(netting_mod5_NB_vals, netting_mod5_NB_residuals)
#DHARMa package - simulate residuals and check model assumptions
netting_mod5_NB_sim_res <- simulateResiduals(fittedModel = netting_mod5_NB)
plot(netting_mod5_NB_sim_res)

```


#### IV.B.2.a. Compare the NB models with the performance package

```{r netting_NB_comp1}
# Compare the models with the performance package
netting_NB_comp1 <- compare_performance(netting_mod1_NB, netting_mod2_NB, netting_mod3_NB, netting_mod4_NB, netting_mod5_NB,  
                                        metrics = c("AICc", "BIC", "R2", "ICC", "RMSE"))

# Print the comparison table
print(netting_NB_comp1)
```

The comparison of the models shows that the model with the lowest AICc and BIC is the fourth model (netting_mod4_NB), which has the lowest AICc and BIC values. 

#### IV.B.2.b. Visualize the model results

**netting_mod4_NB**
Parameter                  | Log-Mean |   SE |         95% CI |     z |      p
(Intercept)                |     4.04 | 0.07 | [ 3.90,  4.18] | 57.64 | < .001
Floral simpson index T     |    -0.31 | 0.08 | [-0.46, -0.16] | -4.01 | < .001
top2 ratio                 |     0.24 | 0.05 | [ 0.14,  0.34] |  4.67 | < .001
Site type [young_restored] |    -0.36 | 0.11 | [-0.58, -0.14] | -3.25 | 0.001 
dm wind velocity           |    -0.15 | 0.05 | [-0.26, -0.05] | -2.82 | 0.005 
Plot Cover T               |    -0.17 | 0.07 | [-0.31, -0.02] | -2.29 | 0.022 

```{r}
library(sjPlot)
#plot_model(netting_mod1_NB, type = "est", show.values = TRUE, value.offset = 0.3)
#plot_model(netting_mod2_NB, type = "est", show.values = TRUE, value.offset = 0.3)
#plot_model(netting_mod3_NB, type = "est", show.values = TRUE, value.offset = 0.3)

plot_model(netting_mod4_NB, type = "est", show.values = TRUE, value.offset = 0.3) ## KEEPER

(est_count_net <- plot_model(netting_mod4_NB, 
           type = "est", 
           show.values = TRUE, 
           value.offset = 0.3,
           #sort.est = TRUE,
           axis.labels = c("Flower Cover % per Transect",
                           "Wind Velocity (km/h)",
                           "Young Restored Site",
                           "Top 2 Flower Ratio",
                           "Floral Simpson Index")) +
    labs(title = "", x = "Predictors",y = "Estimate") + 
    theme(axis.text.y = element_text(hjust = 0)))  # 0 = left, 1 = right


#plot_model(netting_mod5_NB, type = "est", show.values = TRUE, value.offset = 0.3)



```

```{r plot netting_mod4_NB predictions}
## Site Type netting_mod4_NB ------------  
pred <- ggpredict(netting_mod4_NB, terms = "Site_type")

# Manually assign group labels in the correct order
pred$group <- factor(c("Reference", "Young Restored"), levels = c("Reference", "Young Restored"))

# Plot using your custom colors
cc <- c("Reference" = "#1F78B4", "Young Restored" = "#9BB655FF")

(sitetype_count_net <- plot(pred) +
  labs(
    title = "Predicted Insect Counts vs Site Type",
    x = "Site Type",
    y = "Predicted Count of insects caught \nduring transect walk"
  ) +
  scale_color_manual(values = cc) +
  scale_fill_manual(values = cc) +
  theme_new +
  theme(legend.position = "none") +  # Remove the legend
  geom_point(size = 5 ) ) #Increase the point size
  #coord_fixed(ratio = 0.04))  

## wind netting_mod4_NB ---------
# Get the original mean and SD of wind velocity before scaling
wind_mean <- mean(envir_data$dm_wind_velocity, na.rm = TRUE)
wind_sd <- sd(envir_data$dm_wind_velocity, na.rm = TRUE)

# Get predictions on the scaled variable
pred_wind <- ggpredict(netting_mod4_NB , terms = "dm_wind_velocity")

# Unscale the x-axis
pred_wind$x_unscaled <- (pred_wind$x * wind_sd) + wind_mean

# Plot
(wind_count_net <- ggplot(pred_wind, aes(x = x_unscaled, y = predicted)) +
  geom_line(size = 1.2, color = predictor_colors[["dm_wind_velocity"]]) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), 
              fill = alpha(predictor_colors[["dm_wind_velocity"]], 0.5)) +
  labs(
    title = "Transect walk: Predicted Interaction Counts vs Wind Velocity",
    x = "Wind Velocity (km/hour)",
    y = "Predicted Insect Count"
  ))

## top2_ratio netting_mod4_NB ---------
# Get the original mean and SD of top2_ratio before scaling
top2_mean <- mean(envir_data$top2_ratio, na.rm = TRUE)
top2_sd <- sd(envir_data$top2_ratio, na.rm = TRUE)

# Get predictions on the scaled variable
pred_top2 <- ggpredict(netting_mod4_NB , terms = "top2_ratio")

# Unscale the x-axis
pred_top2$x_unscaled <- (pred_top2$x * top2_sd) + top2_mean

# Plot
(top2_count_net <-ggplot(pred_top2, aes(x = x_unscaled, y = predicted)) +
  geom_line(size = 1.2, color = predictor_colors[["top2_ratio"]]) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), 
              fill = alpha(predictor_colors[["top2_ratio"]], 0.5)) + 
  labs(
    title = "Predicted Interaction Counts vs Ratio of Top 2 \nFlower Species",
    x = "Top 2 Ratio: percentage of D. carota and P. sativa per transect",
    y = "Predicted Count of insects caught \nduring transect walk"
  ))

## Floral_simpson_index_T netting_mod4_NB ---------
# Get the original mean and SD of Floral_simpson_index_T before scaling
floral_mean <- mean(envir_data$Floral_simpson_index_T, na.rm = TRUE)
floral_sd <- sd(envir_data$Floral_simpson_index_T, na.rm = TRUE)

# Get predictions on the scaled variable
pred_floral <- ggpredict(netting_mod4_NB , terms = "Floral_simpson_index_T")

# Unscale the x-axis
pred_floral$x_unscaled <- (pred_floral$x * floral_sd) + floral_mean
# Plot
(flosimp <-ggplot(pred_floral, aes(x = x_unscaled, y = predicted)) +
  geom_line(size = 1.2, color = predictor_colors[["Floral_simpson_index_T"]]) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), 
              fill = alpha(predictor_colors[["Floral_simpson_index_T"]], 0.5)) + 
  labs(
    title = "Transect walk: Predicted Interaction Counts vs Floral Simpson Index",
    x = "Floral Simpson Index",
    y = "Predicted Count of insects caught during transect walk"
  ))

## Plot_Cover_T netting_mod4_NB ---------
# Get the original mean and SD of Plot_Cover_T before scaling
plot_cover_mean <- mean(envir_data$Plot_Cover_T, na.rm = TRUE)
plot_cover_sd <- sd(envir_data$Plot_Cover_T, na.rm = TRUE)

# Get predictions on the scaled variable
pred_plot_cover <- ggpredict(netting_mod4_NB , terms = "Plot_Cover_T")

# Unscale the x-axis
pred_plot_cover$x_unscaled <- (pred_plot_cover$x * plot_cover_sd) + plot_cover_mean
# Plot
(floralcover <-ggplot(pred_plot_cover, aes(x = x_unscaled, y = predicted)) +
  geom_line(size = 1.2, color = predictor_colors[["Plot_Cover_T"]]) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), 
              fill = alpha(predictor_colors[["Plot_Cover_T"]],0.5)) +
  labs(
    title = "Predicted Interaction Counts vs Floral Cover %",
    x = "Floral Cover: average percentage \nof flower cover per transect",
    y = "Predicted Count of insects caught \nduring transect walk"
  ))

```

```{r}
#save combined plots for thesis
# est_count_net,  sitetype_count_net, top2_count_net, floralcover
library(cowplot)

# First row
top_row <- cowplot::plot_grid(
  est_count_net, 
  top2_count_net, 
  ncol = 2, 
  labels = c("A", "B"), 
  label_size = 12, 
  rel_widths = c(1, 1)
)

# Second row
bottom_row <- cowplot::plot_grid(
  sitetype_count_net, 
  floralcover, 
  ncol = 2, 
  labels = c("C", "D"), 
  label_size = 12, 
  rel_widths = c(1, 1)
)

# Combine with vertical spacing
p_grid <- cowplot::plot_grid(
  top_row, 
  NULL,  # Spacer
  bottom_row, 
  ncol = 1, 
  rel_heights = c(1, 0.1, 1)  # Increase 0.1 to make bigger space
)

# Add a common title
(final_plot <- ggdraw() +
  draw_label("Transect walk: Interaction counts", fontface = 'bold', x = 0.5, y = 0.98, hjust = 0.5, size = 14) +
  draw_plot(p_grid, y = 0, height = 0.95))

# Save the final plot
ggsave("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/figures/netting_interaction_counts.png", 
       plot = final_plot, width = 10, height = 8, dpi = 600)

```


```{r}
#save est_count_net, top2_count_net, sitetype_count_net
#ggsave("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/figures/est_count_net.png", plot = est_count_net, width = 8, height = 6)
#ggsave("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/figures/top2_count_net.png", plot = top2_count_net, width = 8, height = 6)
#ggsave("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/figures/sitetype_count_net.png", plot = sitetype_count_net, width = 8, height = 6)
ggsave("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/figures/flosimp_count_net.png", plot = flosimp, width = 8, height = 6, dpi=600)

rm(top_row, bottom_row, p_grid, final_plot)
```


#### IV.B.2.c. Interpretation of results

- **Model Type**: `netting_mod4_NB` Generalized linear mixed-effects model (GLMM)
  - **Family**: Negative Binomial (`glmer.nb`), log link  
  - **Random Effect**: `site` (random intercept)
  
- **Model Fit and Assumptions**:
  - No signs of **overdispersion** (*dispersion ratio = 1.52*, *p = 0.176*)
  - **Residuals** were well-behaved in simulation checks (`DHARMa`)
  - **Multicollinearity** was low (VIFs all < 2.2)
  - **Random intercept variance** was very low (*SD = 0.05*), suggesting limited variability between sites after accounting for fixed effects
  - **No singularity issues** were detected

- **Response Variable**:  
  - `total_interaction_T` — Total number of observed and collected pollinator interactions

- **Fixed Effects Included**:
  - `Floral_simpson_index_T` — Floral diversity (scaled)
  - `top2_ratio` — Dominance of top 2 most abundant floral species (scaled)
  - `Site_type` — Young restored vs. reference sites
  - `dm_wind_velocity` — Wind speed (scaled)
  - `Plot_Cover_T` — Total plant cover (scaled)

- **Key Results**:
  - **Floral Simpson Diversity**: Significant **negative** effect  
    - *Estimate = -0.31, p < 0.001* → Higher diversity = fewer total interactions
  - **Top2 Dominance**: Significant **positive** effect  
    - *Estimate = 0.24, p < 0.001* → Higher dominance = more interactions
  - **Site Type**: Young restored sites had **fewer interactions** than reference  
    - *Estimate = -0.36, p = 0.001*
  - **Wind Speed**: Significant **negative** effect on interaction count  
    - *Estimate = -0.15, p = 0.005*
  - **Plant Cover**: Also showed a **negative** effect on interaction count
    - *Estimate = -0.17, p = 0.022*


```{r}
#removal of unnecessary objects - all starting with netting_
rm(list = ls(pattern = "^netting_mod"))
rm(list = ls(pattern = "^plantsimp_"))
```


### IV.B.3. NETTING Species richness - Poisson

We don't actually have the insects ID to species level, only some groups, so we'll use the the lowest taxa available to do this step. 

```{r netting_richness}
# Create a new data frame with the number of unique families per site
netting_richness <- netting %>%
  group_by(site, transect) %>%
  summarise(unique_taxa = n_distinct(lowest_taxa), .groups = "drop")%>%
  #join the scaled_envir_data 
  left_join(scaled_envir_data, by = c("site"="Site", "transect"="Transect"))

#histogram of unique families, binwidth =1 
netting_richness %>%
  ggplot(aes(x = unique_taxa)) +
  geom_histogram(binwidth = 1, fill = "lightblue", color = "black") +
  labs(title = "Histogram of Unique Families",
       x = "Unique Taxa",
       y = "Count")

#is the richness of taxa normally distributed?
shapiro.test(netting_richness$unique_taxa) # p-value = 0.2197, so it is normally distributed
```


```{r netting_rich_mod1_full, fig.width=6, fig.height=6}
# full model with family richness as response variable and environmental, weather and plant diversity variables as explanatory variables, and site as random effect
# Poisson distribution

netting_rich_mod1_poiss <- glmer(unique_taxa 
                                 ~Floral_simpson_index_T 
                                 + minutes_since_9am
                                 + top2_ratio
                                 + Site_type
                                 + dm_wind_velocity
                                 + dm_temperature
                                 + Days_since_start
                                 + Plot_Cover_T
                                 + (1|site), 
                                 data = netting_richness, family = "poisson")

summary(netting_rich_mod1_poiss)
parameters(netting_rich_mod1_poiss)

#check for singularity
performance::check_singularity(netting_rich_mod1_poiss)

#check the model
check_model(netting_rich_mod1_poiss, verbose = T)
#overdispersion
check_overdispersion(netting_rich_mod1_poiss)
#collinearity
check_collinearity(netting_rich_mod1_poiss)

# dharma package - simulate residuals and check model assumptions
netting_rich_mod1_poiss_sim_res <- simulateResiduals(fittedModel = netting_rich_mod1_poiss)
plot(netting_rich_mod1_poiss_sim_res)


```

```{r netting_rich_mod2_poiss, fig.width=6, fig.height=6}
# full model with family richness as response variable and environmental, weather and plant diversity variables as explanatory variables, and site as random effect
# removing dm_temperature (p= 0.955    for netting_rich_mod1_poiss)

netting_rich_mod2_poiss <- glmer(unique_taxa 
                                 ~Floral_simpson_index_T 
                                 + minutes_since_9am
                                 + top2_ratio
                                 + Site_type
                                 + dm_wind_velocity
                                 #+ dm_temperature
                                 + Days_since_start
                                 + Plot_Cover_T
                                 + (1|site), 
                                 data = netting_richness, family = "poisson")

summary(netting_rich_mod2_poiss)
parameters(netting_rich_mod2_poiss)
#check the model
check_model(netting_rich_mod2_poiss, verbose = T)

#overdispersion
check_overdispersion(netting_rich_mod2_poiss)
#collinearity
check_collinearity(netting_rich_mod2_poiss)

# dharma package - simulate residuals and check model assumptions
netting_rich_mod2_poiss_sim_res <- simulateResiduals(fittedModel = netting_rich_mod2_poiss)
plot(netting_rich_mod2_poiss_sim_res)
```

```{r netting_rich_mod3_poiss, fig.width=6, fig.height=6}
#removing site type (p= 0.976     for netting_rich_mod2_poiss)

netting_rich_mod3_poiss <- glmer(unique_taxa 
                                 ~Floral_simpson_index_T 
                                 + minutes_since_9am
                                 + top2_ratio
                                 #+ Site_type
                                 + dm_wind_velocity
                                 #+ dm_temperature
                                 + Days_since_start
                                 + Plot_Cover_T
                                 + (1|site), 
                                 data = netting_richness, family = "poisson")

summary(netting_rich_mod3_poiss)
parameters(netting_rich_mod3_poiss)

#check the model
check_model(netting_rich_mod3_poiss, verbose = T)

#overdispersion
check_overdispersion(netting_rich_mod3_poiss)
#collinearity
check_collinearity(netting_rich_mod3_poiss)
# dharma package - simulate residuals and check model assumptions
netting_rich_mod3_poiss_sim_res <- simulateResiduals(fittedModel = netting_rich_mod3_poiss)
plot(netting_rich_mod3_poiss_sim_res)
```

```{r netting_rich_mod4_poiss, fig.width=6, fig.height=6}
# removing wind velocity (p= 0.813   ,  for netting_rich_mod3_poiss)
netting_rich_mod4_poiss <- glmer(unique_taxa 
                                 ~Floral_simpson_index_T 
                                 + minutes_since_9am
                                 + top2_ratio
                                 #+ Site_type
                                 #+ dm_wind_velocity
                                 #+ dm_temperature
                                 + Days_since_start
                                 + Plot_Cover_T
                                 + (1|site), 
                                 data = netting_richness, family = "poisson")

summary(netting_rich_mod4_poiss)
parameters(netting_rich_mod4_poiss)

#check the model
check_model(netting_rich_mod4_poiss, verbose = T)
#overdispersion
check_overdispersion(netting_rich_mod4_poiss)
#collinearity
check_collinearity(netting_rich_mod4_poiss)

# dharma package - simulate residuals and check model assumptions
netting_rich_mod4_poiss_sim_res <- simulateResiduals(fittedModel = netting_rich_mod4_poiss)
plot(netting_rich_mod4_poiss_sim_res)

```

```{r netting_rich_mod5_poiss, fig.width=6, fig.height=6}
# removing Plot Cover T  (p= 0.418  ,  for netting_rich_mod4_poiss)
netting_rich_mod5_poiss <- glmer(unique_taxa 
                                 ~Floral_simpson_index_T 
                                 + minutes_since_9am
                                 + top2_ratio
                                 #+ Site_type
                                 #+ dm_wind_velocity
                                 #+ dm_temperature
                                 + Days_since_start
                                 + (1|site), 
                                 data = netting_richness, family = "poisson")

summary(netting_rich_mod5_poiss)
parameters(netting_rich_mod5_poiss)

#check the model
check_model(netting_rich_mod5_poiss, verbose = T)
#overdispersion
check_overdispersion(netting_rich_mod5_poiss)
#collinearity
check_collinearity(netting_rich_mod5_poiss)
# dharma package - simulate residuals and check model assumptions
netting_rich_mod5_poiss_sim_res <- simulateResiduals(fittedModel = netting_rich_mod5_poiss)
plot(netting_rich_mod5_poiss_sim_res)
```

```{r netting_rich_mod6_poiss, fig.width=6, fig.height=6}
# removing top2 ratio(p= 0.279   ,  for netting_rich_mod5_poiss)
netting_rich_mod6_poiss <- glmer(unique_taxa 
                                 ~Floral_simpson_index_T 
                                 + minutes_since_9am
                                 # top2_ratio
                                 #+ Site_type
                                 #+ dm_wind_velocity
                                 #+ dm_temperature
                                 + Days_since_start
                                 + (1|site), 
                                 data = netting_richness, family = "poisson")
summary(netting_rich_mod6_poiss)
parameters(netting_rich_mod6_poiss)
#check the model
check_model(netting_rich_mod6_poiss, verbose = T)
#overdispersion
check_overdispersion(netting_rich_mod6_poiss)
#collinearity
check_collinearity(netting_rich_mod6_poiss)
# dharma package - simulate residuals and check model assumptions
netting_rich_mod6_poiss_sim_res <- simulateResiduals(fittedModel = netting_rich_mod6_poiss)
plot(netting_rich_mod6_poiss_sim_res)
```


#### IV.B.3.a. Compare the models with the performance package
```{r netting_rich_pois_comp1}
# Compare the models with the performance package
netting_rich_pois_comp1 <- compare_performance(netting_rich_mod1_poiss, netting_rich_mod2_poiss, netting_rich_mod3_poiss, netting_rich_mod4_poiss, netting_rich_mod5_poiss, netting_rich_mod6_poiss,
                                        metrics = c("AICc", "BIC", "R2", "ICC", "RMSE"))

# Print the comparison table
print(netting_rich_pois_comp1)

```


#### IV.B.3.b. Visualize the model results

```{r}
#plot_model(netting_rich_mod1_poiss, type = "est", show.values = TRUE, value.offset = 0.3)
#plot_model(netting_rich_mod2_poiss, type = "est", show.values = TRUE, value.offset = 0.3)
#plot_model(netting_rich_mod3_poiss, type = "est", show.values = TRUE, value.offset = 0.3)
#plot_model(netting_rich_mod4_poiss, type = "est", show.values = TRUE, value.offset = 0.3)
#plot_model(netting_rich_mod5_poiss, type = "est", show.values = TRUE, value.offset = 0.3)
plot_model(netting_rich_mod6_poiss, type = "est", show.values = TRUE, value.offset = 0.3) 

(mod6 <-plot_model(netting_rich_mod6_poiss, 
           type = "est", 
           show.values = TRUE, 
           value.offset = 0.3,
           #sort.est = TRUE,
           axis.labels = c("Days Since Start",
                           "Time of Day",
                           "Floral Simpson Index")) +
    labs(title = "Transect walk: Species Richness",y = "Estimate") + 
    theme(axis.text.y = element_text(hjust = 1)))  # 0 = left, 1 = right
```


```{r plot netting_rich_mod1_poiss predictions}
## days since start netting_rich_mod1_poiss ---------
# Get the original mean and SD of days since start before scaling
days_mean <- mean(envir_data$Days_since_start, na.rm = TRUE)
days_sd <- sd(envir_data$Days_since_start, na.rm = TRUE)
# Get predictions on the scaled variable
pred_days <- ggpredict(netting_rich_mod1_poiss , terms = "Days_since_start")
# Unscale the x-axis
pred_days$x_unscaled <- (pred_days$x * days_sd) + days_mean
# Plot
(days_rich_net <- ggplot(pred_days, aes(x = x_unscaled, y = predicted)) +
  geom_line(size = 1.2, color = predictor_colors[["Days_since_start"]]) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), 
              fill = alpha(predictor_colors[["Days_since_start"]], 0.5)) +
  labs(
    title = "Transect walk: Predicted Insect Richness vs Days Since Start",
    x = "Days Since Start",
    y = "Predicted Count of unique taxa"
  ))

## minutes since 9am index netting_rich_mod1_poiss ---------
# Get the original mean and SD of minutes since 9am before scaling
minutes_mean <- mean(envir_data$minutes_since_9am, na.rm = TRUE)
minutes_sd <- sd(envir_data$minutes_since_9am, na.rm = TRUE)
# Get predictions on the scaled variable
pred_minutes <- ggpredict(netting_rich_mod1_poiss , terms = "minutes_since_9am")
# Unscale the x-axis
pred_minutes$x_unscaled <- (pred_minutes$x * minutes_sd) + minutes_mean
# divide by 60 to get hours, and add 9 to get hour of the day
pred_minutes$x_unscaled <- (pred_minutes$x_unscaled / 60) + 9

# Plot
ggplot(pred_minutes, aes(x = x_unscaled, y = predicted)) +
  geom_line(size = 1.2, color = predictor_colors[["minutes_since_9am"]]) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), 
              fill = alpha(predictor_colors[["minutes_since_9am"]], 0.5)) +
  labs(
    title = "Transect walk: Predicted Insect Richness vs Time of day",
    x = "Time of day",
    y = "Predicted Count of unique taxa caught during transect walk"
  ) 
```

```{r}
#save combined plots mod6 and days_rich_net
library(cowplot)
#change title of mod6
mod6 <- mod6 + labs(title = "Species Richness")+
  theme(axis.title = element_text(size = 12))
days_rich_net <- days_rich_net + labs(title = "Species Richness vs Days Since Start")+
  #change font size
  theme(axis.title = element_text(size = 12))


# Step 1: Combine the plots and label ONLY them (A and B)
combined_plots <- cowplot::plot_grid(
  mod6, 
  days_rich_net, 
  ncol = 2,
  labels = c("A", "B"),   # Label just these two plots
  label_size = 12, 
  rel_widths = c(1.2, 1) 
)

# Step 2: Add the title separately, so it doesn't get a label
(final_plot <- cowplot::plot_grid(
  ggdraw() + draw_label(
    "Transect walk: Species Richness", 
    fontface = 'bold', size = 12, x = 0.5, hjust = 0.5
  ),
  combined_plots,
  ncol = 1,
  rel_heights = c(0.1, 1)  # Title height vs. plots height
))



# Save the combined plot
ggsave("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/figures/days_rich_net.png", plot = final_plot, 
       #size to match an a4 page      
       width = 20, height = 10, units = "cm", 
       dpi = 300, device = "png")
```


#### IV.B.3. c. Interpretation of results

```{r}
#removal of unnecessary objects - all starting with netting_
rm(list = ls(pattern = "^netting_"))
```



### IV.B.4. NETTING Shannon Index - Gaussian

```{r netting_shannon}
# 1. First, let's aggregate by 'site' and 'transect' and calculate the counts per insect order
netting_agg <- netting %>%
  group_by(site, transect, lowest_taxa) %>%
  summarise(count = n(), .groups = 'drop')  # Count the occurrences of each order

# 2. Pivot the data into a wider format, where each column is an insect order and the values are counts
netting_wide <- netting_agg %>%
  pivot_wider(names_from = lowest_taxa, values_from = count, values_fill = list(count = 0))

# 3. Compute Shannon diversity index for each transect per site using the 'vegan::diversity()' function
# Apply the diversity function to each row, excluding the site and transect identifiers
netting_div <- netting_wide %>%
  rowwise() %>%
  mutate(shannon_diversity = diversity(c_across(3:106), index = "shannon"),
    simpson_diversity = diversity(c_across(3:106), index = "simpson")
    ) %>%
  ungroup()%>%
  #remove all the columns with the counts
  dplyr::select(-c(3:106)) 

netting_diversity <- netting_div %>%
  #join the scaled_envir_data 
  left_join(scaled_envir_data, by = c("site"="Site", "transect"="Transect"))

netting_div_unscaled <- netting_div %>%
  #join the scaled_envir_data 
  left_join(envir_data, by = c("site"="Site", "transect"="Transect"))

# View the new data frame with Shannon diversity values
head(netting_diversity)
#remove intermediate data frames
rm(netting_agg, netting_wide, netting_div)

#histogram of shannon diversity, binwidth =0.1
netting_diversity %>%
  ggplot(aes(x = shannon_diversity)) +
  geom_histogram(binwidth = 0.05, fill = "lightblue", color = "black") +
  labs(title = "Histogram of Shannon Diversity Index",
       x = "Shannon Diversity Index",
       y = "Count")

#testing the normality of the shannon index
shapiro.test(netting_diversity$shannon_diversity) # p-value = 0.1578, shannon index is normally distributed

#testing skewness
datawizard::describe_distribution(netting_diversity$shannon_diversity)
```

The shannon index is normally distributed (shapiro test: p-value = 0.1578) and has a skewness of -0.23, indicating a slight left skew. The kurtosis is 2.4, indicating a platykurtic distribution (flatter than normal), but fairly normal. Since the shannon index is a continuous variable, we cannot use a poisson model that expects count based integers, but we can use a Gaussian distribution (aka normal distribution) that is better modeled with a linear mixed model (lmm).



```{r netting_shannon_mod1_gauss, fig.width=6, fig.height=6}
# full model with shannon index as response variable and environmental, weather and plant diversity variables as explanatory variables, and site as random effect
# Poisson distribution
netting_shannon_mod1_gauss <- lmer(shannon_diversity 
                                   ~Floral_simpson_index_T 
                                   + minutes_since_9am
                                   + top2_ratio
                                   + Site_type
                                   + dm_wind_velocity
                                   + dm_temperature
                                   + Days_since_start
                                   + Plot_Cover_T
                                   + (1 | site), 
                                   data = netting_diversity)
summary(netting_shannon_mod1_gauss)
parameters(netting_shannon_mod1_gauss)
#check for singularity
performance::check_singularity(netting_shannon_mod1_gauss)
#check the model
check_model(netting_shannon_mod1_gauss, verbose = T)

#overdispersion
check_overdispersion(netting_shannon_mod1_gauss)
#collinearity
check_collinearity(netting_shannon_mod1_gauss)

# dharma package - simulate residuals and check model assumptions
netting_shannon_mod1_gauss_sim_res <- simulateResiduals(fittedModel = netting_shannon_mod1_gauss)
plot(netting_shannon_mod1_gauss_sim_res)
```


```{r netting_shannon_mod2_gauss, fig.width=6, fig.height=6}
# full model with shannon index as response variable and environmental, weather and plant diversity variables as explanatory variables, and site as random effect
# removing top2_ratio (p= 0.940   for netting_shannon_mod1_gauss)

netting_shannon_mod2_gauss <- lmer(shannon_diversity 
                                   ~Floral_simpson_index_T 
                                   + minutes_since_9am
                                   #+ top2_ratio
                                   + Site_type
                                   + dm_wind_velocity
                                   + dm_temperature
                                   + Days_since_start
                                   + Plot_Cover_T
                                   + (1 | site), 
                                   data = netting_diversity)
summary(netting_shannon_mod2_gauss)
parameters(netting_shannon_mod2_gauss)

#check the model
check_model(netting_shannon_mod2_gauss, verbose = T)

#overdispersion
check_overdispersion(netting_shannon_mod2_gauss)
#collinearity
check_collinearity(netting_shannon_mod2_gauss)
# dharma package - simulate residuals and check model assumptions
netting_shannon_mod2_gauss_sim_res <- simulateResiduals(fittedModel = netting_shannon_mod2_gauss)
plot(netting_shannon_mod2_gauss_sim_res)


```

```{r netting_shannon_mod3_gauss, fig.width=6, fig.height=6}
#remove Plot cover T (p= 0.904    for netting_shannon_mod2_gauss)
netting_shannon_mod3_gauss <- lmer(shannon_diversity 
                                   ~Floral_simpson_index_T 
                                   + minutes_since_9am
                                   #+ top2_ratio
                                   + Site_type
                                   + dm_wind_velocity
                                   + dm_temperature
                                   + Days_since_start
                                   #+ Plot_Cover_T
                                   + (1 | site), 
                                   data = netting_diversity)

summary(netting_shannon_mod3_gauss)
parameters(netting_shannon_mod3_gauss)
#check the model
check_model(netting_shannon_mod3_gauss, verbose = T)
#overdispersion
check_overdispersion(netting_shannon_mod3_gauss)
#collinearity
check_collinearity(netting_shannon_mod3_gauss)
# dharma package - simulate residuals and check model assumptions
netting_shannon_mod3_gauss_sim_res <- simulateResiduals(fittedModel = netting_shannon_mod3_gauss)
plot(netting_shannon_mod3_gauss_sim_res)
```

```{r netting_shannon_mod4_gauss, fig.width=6, fig.height=6}
#remove floral simpson index (p= 0.935     for netting_shannon_mod3_gauss)
netting_shannon_mod4_gauss <- lmer(shannon_diversity 
                                   #~Floral_simpson_index_T 
                                   ~ minutes_since_9am
                                   #+ top2_ratio
                                   + Site_type
                                   + dm_wind_velocity
                                   + dm_temperature
                                   + Days_since_start
                                   #+ Plot_Cover_T
                                   + (1 | site), 
                                   data = netting_diversity)
summary(netting_shannon_mod4_gauss)
parameters(netting_shannon_mod4_gauss)
#check the model
check_model(netting_shannon_mod4_gauss, verbose = T)
#overdispersion
check_overdispersion(netting_shannon_mod4_gauss)
#collinearity
check_collinearity(netting_shannon_mod4_gauss)
# dharma package - simulate residuals and check model assumptions
netting_shannon_mod4_gauss_sim_res <- simulateResiduals(fittedModel = netting_shannon_mod4_gauss)
plot(netting_shannon_mod4_gauss_sim_res)

```


```{r netting_shannon_mod5_gauss, fig.width=6, fig.height=6}
#remove site type (p= 0.816   for netting_shannon_mod4_gauss)
netting_shannon_mod5_gauss <- lmer(shannon_diversity 
                                   #~Floral_simpson_index_T 
                                   ~ minutes_since_9am
                                   #+ top2_ratio
                                   #+ Site_type
                                   + dm_wind_velocity
                                   + dm_temperature
                                   + Days_since_start
                                   #+ Plot_Cover_T
                                   + (1 | site), 
                                   data = netting_diversity)

summary(netting_shannon_mod5_gauss)
parameters(netting_shannon_mod5_gauss)
#check the model
check_model(netting_shannon_mod5_gauss, verbose = T)
#overdispersion
check_overdispersion(netting_shannon_mod5_gauss)
#collinearity
check_collinearity(netting_shannon_mod5_gauss)
# dharma package - simulate residuals and check model assumptions
netting_shannon_mod5_gauss_sim_res <- simulateResiduals(fittedModel = netting_shannon_mod5_gauss)
plot(netting_shannon_mod5_gauss_sim_res)
```

```{r netting_shannon_mod6_gauss, fig.width=6, fig.height=6}
#removing dm temperature (p= 0.329    for netting_shannon_mod5_gauss)
netting_shannon_mod6_gauss <- lmer(shannon_diversity 
                                   #~Floral_simpson_index_T 
                                   ~ minutes_since_9am
                                   #+ top2_ratio
                                   #+ Site_type
                                   + dm_wind_velocity
                                   #+ dm_temperature
                                   + Days_since_start
                                   #+ Plot_Cover_T
                                   + (1 | site), 
                                   data = netting_diversity)
summary(netting_shannon_mod6_gauss)
parameters(netting_shannon_mod6_gauss)
#check the model
check_model(netting_shannon_mod6_gauss, verbose = T)
#overdispersion
check_overdispersion(netting_shannon_mod6_gauss)
#collinearity
check_collinearity(netting_shannon_mod6_gauss)
# dharma package - simulate residuals and check model assumptions
netting_shannon_mod6_gauss_sim_res <- simulateResiduals(fittedModel = netting_shannon_mod6_gauss)
plot(netting_shannon_mod6_gauss_sim_res)

```



#### IV.B.4.a. Compare the models with the performance package
```{r netting_shannon_gauss_comp1}
# Compare the models with the performance package
netting_shannon_gauss_comp1 <- compare_performance(netting_shannon_mod1_gauss, netting_shannon_mod2_gauss, netting_shannon_mod3_gauss, netting_shannon_mod4_gauss, netting_shannon_mod5_gauss,netting_shannon_mod6_gauss,
                                        metrics = c("AICc", "BIC", "R2", "ICC", "RMSE"))
# Print the comparison table
print(netting_shannon_gauss_comp1)
```

#### IV.B.4.b. Visualize the model results
```{r}
#plot_model(netting_shannon_mod1_gauss, type = "est", show.values = TRUE, value.offset = 0.3)
#plot_model(netting_shannon_mod2_gauss, type = "est", show.values = TRUE, value.offset = 0.3)
#plot_model(netting_shannon_mod3_gauss, type = "est", show.values = TRUE, value.offset = 0.3)
#plot_model(netting_shannon_mod4_gauss, type = "est", show.values = TRUE, value.offset = 0.3)
#plot_model(netting_shannon_mod5_gauss, type = "est", show.values = TRUE, value.offset = 0.3)
plot_model(netting_shannon_mod6_gauss, type = "est", show.values = TRUE, value.offset = 0.3) 
plot_model(netting_shannon_mod6_gauss, 
           type = "est", 
           show.values = TRUE, 
           value.offset = 0.3,
           #sort.est = TRUE,
           axis.labels = c("Days Since Start",
                           "Wind Velocity",
                           "Time of Day")) +
    labs(title = "Transect walk: Shannon Index of Pollinator", x = "Predictors",y = "Estimate") + 
    theme(axis.text.y = element_text(hjust = 0))  # 0 = left, 1 = right

```

```{r plot netting_shannon_mod6_gauss predictions}
## days since start netting_shannon_mod5_gauss ---------
# Get the original mean and SD of days since start before scaling
days_mean <- mean(envir_data$Days_since_start, na.rm = TRUE)
days_sd <- sd(envir_data$Days_since_start, na.rm = TRUE)
# Get predictions on the scaled variable
pred_days <- ggpredict(netting_shannon_mod6_gauss , terms = "Days_since_start")
# Unscale the x-axis
pred_days$x_unscaled <- (pred_days$x * days_sd) + days_mean
# Plot
ggplot(pred_days, aes(x = x_unscaled, y = predicted)) +
  geom_line(size = 1.2, color = predictor_colors[["Days_since_start"]]) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), 
              fill = alpha(predictor_colors[["Days_since_start"]], 0.5)) +
  labs(
    title = "Transect walk: Predicted Pollinator Shannon Diversity vs Days Since Start",
    x = "Days Since Start",
    y = "Predicted Pollinator Shannon Diversity Index"
  ) 

## minutes since 9am index netting_shannon_mod6_gauss ---------
# Get the original mean and SD of minutes since 9am before scaling
minutes_mean <- mean(envir_data$minutes_since_9am, na.rm = TRUE)
minutes_sd <- sd(envir_data$minutes_since_9am, na.rm = TRUE)
# Get predictions on the scaled variable
pred_minutes <- ggpredict(netting_shannon_mod6_gauss , terms = "minutes_since_9am")
# Unscale the x-axis
pred_minutes$x_unscaled <- (pred_minutes$x * minutes_sd) + minutes_mean
# divide by 60 to get hours, and add 9 to get hour of the day
pred_minutes$x_unscaled <- (pred_minutes$x_unscaled / 60) + 9
# Plot
ggplot(pred_minutes, aes(x = x_unscaled, y = predicted)) +
  geom_line(size = 1.2, color = predictor_colors[["minutes_since_9am"]]) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), 
              fill = alpha(predictor_colors[["minutes_since_9am"]], 0.5)) +
  labs(
    title = "Transect walk: Predicted Pollinator Shannon Diversity vs Time of day",
    x = "Time of day",
    y = "Predicted Pollinator Shannon Diversity Index"
  ) 
```
 
#### IV.B.4.c. Interpretation of results



```{r}
#removal of unnecessary objects - all starting with netting_shannon
rm(list = ls(pattern = "^netting_shannon_"))
```

### IV.B.5 NETTING Simpson Index - Beta regression

The Simpson index per transect was calculated in the previous section and is stored in the netting_diversity data frame.

```{r netting_simpson}
#histogram of simpson diversity, binwidth =0.01
netting_diversity %>%
  ggplot(aes(x = simpson_diversity)) +
  geom_histogram(binwidth = 0.01, fill = "lightblue", color = "black") +
  labs(title = "Histogram of Simpson Diversity Index",
       x = "Simpson Diversity Index",
       y = "Count")

#testing the normality of the simpson index
shapiro.test(netting_diversity$simpson_diversity) # p-value = 0.0034, simpson index is not normally distributed

#testing skewness
datawizard::describe_distribution(netting_diversity$simpson_diversity)
```

The Simpson index is not normally distributed (shapiro test: p-value = 0.0034) and has a skewness of -0.23, indicating a slight left skew. The kurtosis is 2.4, indicating a platykurtic distribution (flatter than normal), but fairly normal. In this case, where simpson index is bounded between 0 and 1, we can use a beta regression or a binomial regression with a logit link function. 

```{r netting_simpson_mod1_beta, fig.width=6, fig.height=6}
netting_simpson_mod1_beta <- glmmTMB(simpson_diversity 
                                     ~Floral_simpson_index_T 
                                     + minutes_since_9am 
                                     + dm_wind_velocity
                                     + top2_ratio
                                     + Site_type
                                     + dm_temperature
                                     + Days_since_start 
                                     + Plot_Cover_T
                                     + (1 | site),
                                     family = beta_family(),  
                                     data = netting_diversity)
summary(netting_simpson_mod1_beta)
parameters(netting_simpson_mod1_beta)
#check for singularity
performance::check_singularity(netting_simpson_mod1_beta)
#check the model
check_model(netting_simpson_mod1_beta, verbose = T)
#overdispersion
check_overdispersion(netting_simpson_mod1_beta)
#collinearity
check_collinearity(netting_simpson_mod1_beta)

# dharma package - simulate residuals and check model assumptions
netting_simpson_mod1_beta_sim_res <- simulateResiduals(fittedModel = netting_simpson_mod1_beta)
plot(netting_simpson_mod1_beta_sim_res)

```

```{r netting_simpson_mod2_beta, fig.width=6, fig.height=6}
# REMOVE top2_ratio (p= 0.835   for netting_simpson_mod1_beta)
netting_simpson_mod2_beta <- glmmTMB(simpson_diversity 
                                     ~Floral_simpson_index_T 
                                     + minutes_since_9am 
                                     + dm_wind_velocity
                                     #+ top2_ratio
                                     + Site_type
                                     + dm_temperature
                                     + Days_since_start 
                                     + Plot_Cover_T
                                     + (1 | site),
                                     family = beta_family(),  
                                     data = netting_diversity)

summary(netting_simpson_mod2_beta)
parameters(netting_simpson_mod2_beta)

#check for singularity
performance::check_singularity(netting_simpson_mod2_beta)
#check the model
check_model(netting_simpson_mod2_beta, verbose = T)

#overdispersion
check_overdispersion(netting_simpson_mod2_beta)
#collinearity
check_collinearity(netting_simpson_mod2_beta)
# dharma package - simulate residuals and check model assumptions
netting_simpson_mod2_beta_sim_res <- simulateResiduals(fittedModel = netting_simpson_mod2_beta)
plot(netting_simpson_mod2_beta_sim_res)
```

```{r netting_simpson_mod3_beta, fig.width=6, fig.height=6}
#remove temperature (p= 0.817   for netting_simpson_mod2_beta)

netting_simpson_mod3_beta <- glmmTMB(simpson_diversity 
                                     ~Floral_simpson_index_T 
                                     + minutes_since_9am 
                                     + dm_wind_velocity
                                     #+ top2_ratio
                                     + Site_type
                                     #+ dm_temperature
                                     + Days_since_start 
                                     + Plot_Cover_T
                                     + (1 | site),
                                     family = beta_family(),  
                                     data = netting_diversity)
summary(netting_simpson_mod3_beta)
parameters(netting_simpson_mod3_beta)
#check for singularity
performance::check_singularity(netting_simpson_mod3_beta)
#check the model
check_model(netting_simpson_mod3_beta, verbose = T)
#overdispersion
check_overdispersion(netting_simpson_mod3_beta)
#collinearity
check_collinearity(netting_simpson_mod3_beta)
# dharma package - simulate residuals and check model assumptions
netting_simpson_mod3_beta_sim_res <- simulateResiduals(fittedModel = netting_simpson_mod3_beta)
plot(netting_simpson_mod3_beta_sim_res)
```

```{r netting_simpson_mod4_beta, fig.width=6, fig.height=6}
#remove floral simpson index (p= 0.792         for netting_simpson_mod3_beta)
netting_simpson_mod4_beta <- glmmTMB(simpson_diversity 
                                     #~Floral_simpson_index_T 
                                     ~ minutes_since_9am 
                                     + dm_wind_velocity
                                     #+ top2_ratio
                                     + Site_type
                                     #+ dm_temperature
                                     + Days_since_start 
                                     + Plot_Cover_T
                                     + (1 | site),
                                     family = beta_family(),  
                                     data = netting_diversity)
summary(netting_simpson_mod4_beta)
parameters(netting_simpson_mod4_beta)
#check for singularity
performance::check_singularity(netting_simpson_mod4_beta)
#check the model
check_model(netting_simpson_mod4_beta, verbose = T)
#overdispersion
check_overdispersion(netting_simpson_mod4_beta)
#collinearity
check_collinearity(netting_simpson_mod4_beta)
# dharma package - simulate residuals and check model assumptions
netting_simpson_mod4_beta_sim_res <- simulateResiduals(fittedModel = netting_simpson_mod4_beta)
plot(netting_simpson_mod4_beta_sim_res)

```

```{r netting_simpson_mod5_beta, fig.width=6, fig.height=6}
#REMOVE plot cover t (p= 0.580 for netting_simpson_mod4_beta)

netting_simpson_mod5_beta <- glmmTMB(simpson_diversity 
                                     #~Floral_simpson_index_T 
                                     ~ minutes_since_9am 
                                     + dm_wind_velocity
                                     #+ top2_ratio
                                     + Site_type
                                     #+ dm_temperature
                                     + Days_since_start 
                                     #+ Plot_Cover_T
                                     + (1 | site),
                                     family = beta_family(),  
                                     data = netting_diversity)
summary(netting_simpson_mod5_beta)
parameters(netting_simpson_mod5_beta)
#check for singularity
performance::check_singularity(netting_simpson_mod5_beta)
#check the model
check_model(netting_simpson_mod5_beta, verbose = T)
#overdispersion
check_overdispersion(netting_simpson_mod5_beta)
#collinearity
check_collinearity(netting_simpson_mod5_beta)
# dharma package - simulate residuals and check model assumptions
netting_simpson_mod5_beta_sim_res <- simulateResiduals(fittedModel = netting_simpson_mod5_beta)
plot(netting_simpson_mod5_beta_sim_res)

```

```{r netting_simpson_mod6_beta, fig.width=6, fig.height=6}
#remove site type (p= 0.117      for netting_simpson_mod5_beta)
netting_simpson_mod6_beta <- glmmTMB(simpson_diversity 
                                     #~Floral_simpson_index_T 
                                     ~ minutes_since_9am 
                                     + dm_wind_velocity
                                     #+ top2_ratio
                                     #+ Site_type
                                     #+ dm_temperature
                                     + Days_since_start 
                                     #+ Plot_Cover_T
                                     + (1 | site),
                                     family = beta_family(),  
                                     data = netting_diversity)
summary(netting_simpson_mod6_beta)
parameters(netting_simpson_mod6_beta)
#check for singularity
performance::check_singularity(netting_simpson_mod6_beta)
#check the model
check_model(netting_simpson_mod6_beta, verbose = T)
#overdispersion
check_overdispersion(netting_simpson_mod6_beta)
#collinearity
check_collinearity(netting_simpson_mod6_beta)
# dharma package - simulate residuals and check model assumptions
netting_simpson_mod6_beta_sim_res <- simulateResiduals(fittedModel = netting_simpson_mod6_beta)
plot(netting_simpson_mod6_beta_sim_res)

```


#### IV.B.5.a. Compare the models with the performance package
```{r netting_simpson_beta_comp1}
# Compare the models with the performance package
netting_simpson_beta_comp1 <- compare_performance(netting_simpson_mod1_beta, netting_simpson_mod2_beta, netting_simpson_mod3_beta, netting_simpson_mod4_beta, netting_simpson_mod5_beta,netting_simpson_mod6_beta, metrics = c("AICc", "BIC", "R2", "ICC", "RMSE"))

# Print the comparison table
print(netting_simpson_beta_comp1)
```

#### IV.B.5.b. visualize the model results

```{r}
#plot_model(netting_simpson_mod1_beta, type = "est", show.values = TRUE, value.offset = 0.3)
#plot_model(netting_simpson_mod2_beta, type = "est", show.values = TRUE, value.offset = 0.3)
#plot_model(netting_simpson_mod3_beta, type = "est", show.values = TRUE, value.offset = 0.3)
#plot_model(netting_simpson_mod4_beta, type = "est", show.values = TRUE, value.offset = 0.3)

(netsimp_est <- plot_model(netting_simpson_mod6_beta, 
           type = "est", 
           show.values = TRUE, 
           value.offset = 0.3,
           #sort.est = TRUE,
           axis.labels = c( "Days Since Start",
                           "Wind Velocity (km/h)",
                           "Time of day")) +
    labs(title = "Transect walk: Simpson Index of Pollinator", x = "Predictors",y = "Estimate") + 
    theme(axis.text.y = element_text(hjust = 0)))  # 0 = left, 1 = right


#plot_model(netting_simpson_mod5_beta, type = "est", show.values = TRUE, value.offset = 0.3)
#plot_model(netting_simpson_mod6_beta, type = "est", show.values = TRUE, value.offset = 0.3) 
```

```{r plot netting_simpson_mod6_beta predictions}
## days since start netting_simpson_mod6_beta ---------
# Get the original mean and SD of days since start before scaling
days_mean <- mean(envir_data$Days_since_start, na.rm = TRUE)
days_sd <- sd(envir_data$Days_since_start, na.rm = TRUE)
# Get predictions on the scaled variable
pred_days <- ggpredict(netting_simpson_mod6_beta , terms = "Days_since_start")
# Unscale the x-axis
pred_days$x_unscaled <- (pred_days$x * days_sd) + days_mean
# Plot
ggplot(pred_days, aes(x = x_unscaled, y = predicted)) +
  geom_line(size = 1.2, color = predictor_colors[["Days_since_start"]]) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), 
              fill = alpha(predictor_colors[["Days_since_start"]], 0.5)) +
  labs(
    title = "Transect walk: Predicted Pollinator Simpson Diversity vs Days Since Start",
    x = "Days Since Start",
    y = "Predicted Pollinator Simpson Diversity Index"
  ) 

## minutes since 9am index netting_simpson_mod6_beta ---------
# Get the original mean and SD of minutes since 9am before scaling
minutes_mean <- mean(envir_data$minutes_since_9am, na.rm = TRUE)
minutes_sd <- sd(envir_data$minutes_since_9am, na.rm = TRUE)
# Get predictions on the scaled variable
pred_minutes <- ggpredict(netting_simpson_mod6_beta , terms = "minutes_since_9am")
# Unscale the x-axis
pred_minutes$x_unscaled <- (pred_minutes$x * minutes_sd) + minutes_mean
# divide by 60 to get hours, and add 9 to get hour of the day
pred_minutes$x_unscaled <- (pred_minutes$x_unscaled / 60) + 9
# Plot
ggplot(pred_minutes, aes(x = x_unscaled, y = predicted)) +
  geom_line(size = 1.2, color = predictor_colors[["minutes_since_9am"]]) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), 
              fill = alpha(predictor_colors[["minutes_since_9am"]], 0.5)) +
  labs(
    title = "Transect walk: Predicted Pollinator Simpson Diversity vs Time of day",
    x = "Time of day",
    y = "Predicted Pollinator Simpson Diversity Index"
  ) 

#combine netsimp_est and the two plots


```

#### IV.B.5.c. Interpretation of the model results
The fourth model is the last one that meets the assumptions of the model (residuals vs fitted from the dharma package). The model is a beta regression with a logit link function, which is appropriate for bounded continuous data like the Simpson index. The model includes floral Simpson index (p=), time of day (p=), wind velocity (p=), site type (p=) and sampling date (p=) as fixed effects, and site as a random effect. 


```{r}  
#removal of unnecessary objects - all starting with netting_
rm(list = ls(pattern = "^netting_"))
```  




## IV.C. PLATFORM CAMERAS

At first, I tried to also have the minutes_since_9am variable for platform cameras, only to realize that it is not relevant in this specific case. We will be able to look at the time at which each insect is captured since it is recorded in the filename of the image, and the starting time of the camera is not a ecologically relevant variable. 

### IV.C.1. PLATFORM CAMERAS Counts - Poisson glmer (offset: recording time)

```{r platform_counts}  
# count of insect per transect per site
platty <- platform_camera %>%
  group_by(location, transect) %>%
  summarise(count = n(), .groups = 'drop')  # Count the occurrence

#join the  specific envir_data already in platform_camera1
platform_counts <- platty %>%
  left_join(platform_camera1, by = c("location", "transect"))%>%
  #REMOVE EXTRA COLUMNS "ID" "Site_Tn" "det_conf_mean" "track_ID_imgs" "top1_imgs" "top1_prob_mean" "top1_prob_weighted"
 dplyr::select(-c(start_time, top1,ID, Site_Tn, det_conf_mean, track_ID_imgs, top1_imgs, top1_prob_mean, top1_prob_weighted)) %>%
  #keep only unique rows
  distinct()
  #scale numerical

#histogram of counts, binwidth =0.01
platform_counts %>%
  ggplot(aes(x = count)) +
  geom_histogram(binwidth = 1, fill = "lightblue", color = "black") +
  labs(title = "Histogram of Insect Counts",
       x = "Insect Count",
       y = "Count")
rm(platty)
```

Since this is count data, it is going to be modeled with a Poisson distribution. However, if the data is overdispersed (variance > mean), we will use a negative binomial distribution instead. 


```{r platform_count_mod1_poiss, fig.width=6, fig.height=6}
# full model with insect counts as response variable and environmental, weather and plant diversity variables as explanatory variables, and site as random effect
# Poisson distribution
platform_count_mod1_poiss <- glmmTMB(count 
                                     ~ Floral_simpson_index_T
                                     #+ minutes_since_9am
                                     + top2_ratio
                                     + Site_type
                                     + dm_wind_velocity
                                     + dm_temperature
                                     + Days_since_start
                                     + Plot_Cover_T
                                     + (1 | location),
                                     offset = log(rec_time_min),
                                     family = poisson(),
                                     data = platform_counts)

summary(platform_count_mod1_poiss)
parameters(platform_count_mod1_poiss)
#check for singularity
performance::check_singularity(platform_count_mod1_poiss)
#check the model
check_model(platform_count_mod1_poiss, verbose = T)

#overdispersion
check_overdispersion(platform_count_mod1_poiss)
#collinearity
check_collinearity(platform_count_mod1_poiss)
# dharma package - simulate residuals and check model assumptions
platform_count_mod1_poiss_sim_res <- simulateResiduals(fittedModel = platform_count_mod1_poiss)
plot(platform_count_mod1_poiss_sim_res)

```

There is overdispersion in the model, so we will use a negative binomial distribution instead of poisson distribution. 

```{r platform_count_mod1_nb, fig.width=6, fig.height=6}
# full model with insect counts as response variable and environmental, weather and plant diversity variables as explanatory variables, and site as random effect
# Negative binomial distribution

platform_count_mod1_nb <- glmmTMB(count 
                                   ~ Floral_simpson_index_T 
                                   + top2_ratio
                                   + Site_type
                                   + dm_wind_velocity
                                   + dm_temperature
                                   + Days_since_start
                                   + Plot_Cover_T
                                   + (1 | location),
                                   offset = log(rec_time_min),
                                   family = nbinom2(),
                                   data = platform_counts)
summary(platform_count_mod1_nb)
parameters(platform_count_mod1_nb)
#check for singularity
performance::check_singularity(platform_count_mod1_nb)
#check the model
check_model(platform_count_mod1_nb, verbose = T)
#overdispersion
check_overdispersion(platform_count_mod1_nb)
#collinearity
check_collinearity(platform_count_mod1_nb)
# dharma package - simulate residuals and check model assumptions
platform_count_mod1_nb_sim_res <- simulateResiduals(fittedModel = platform_count_mod1_nb)
plot(platform_count_mod1_nb_sim_res)
```

```{r platform_count_mod2_nb, fig.width=6, fig.height=6}
# removing top2_ratio (p= 0.978    for platform_count_mod1_nb)

platform_count_mod2_nb <- glmmTMB(count 
                                   ~ Floral_simpson_index_T 
                                   #+ top2_ratio
                                   + Site_type
                                   + dm_wind_velocity
                                   + dm_temperature
                                   + Days_since_start
                                   + Plot_Cover_T
                                   + (1 | location),
                                   offset = log(rec_time_min),
                                   family = nbinom2(),
                                   data = platform_counts)
summary(platform_count_mod2_nb)
parameters(platform_count_mod2_nb)
#check for singularity
performance::check_singularity(platform_count_mod2_nb)
#check the model
check_model(platform_count_mod2_nb, verbose = T)
#overdispersion
check_overdispersion(platform_count_mod2_nb)
#collinearity
check_collinearity(platform_count_mod2_nb)
# dharma package - simulate residuals and check model assumptions
platform_count_mod2_nb_sim_res <- simulateResiduals(fittedModel = platform_count_mod2_nb)
plot(platform_count_mod2_nb_sim_res)
```

```{r platform_count_mod3_nb, fig.width=6, fig.height=6}
# removing days since start (p= 0.909      for platform_count_mod2_nb)
platform_count_mod3_nb <- glmmTMB(count 
                                   ~ Floral_simpson_index_T 
                                   #+ top2_ratio
                                   + Site_type
                                   + dm_wind_velocity
                                   + dm_temperature
                                   #+ Days_since_start
                                   + Plot_Cover_T
                                   + (1 | location),
                                   offset = log(rec_time_min),
                                   family = nbinom2(),
                                   data = platform_counts)
summary(platform_count_mod3_nb)
parameters(platform_count_mod3_nb)
#check the model
check_model(platform_count_mod3_nb, verbose = T)
  
#overdispersion
check_overdispersion(platform_count_mod3_nb)
#collinearity
check_collinearity(platform_count_mod3_nb)
# dharma package - simulate residuals and check model assumptions
platform_count_mod3_nb_sim_res <- simulateResiduals(fittedModel = platform_count_mod3_nb)
plot(platform_count_mod3_nb_sim_res)
```

```{r platform_count_mod4_nb, fig.width=6, fig.height=6}
#removing site type (p= 0.806    for platform_count_mod3_nb)
platform_count_mod4_nb <- glmmTMB(count 
                                   ~ Floral_simpson_index_T 
                                   #+ top2_ratio
                                   #+ Site_type
                                   + dm_wind_velocity
                                   + dm_temperature
                                   #+ Days_since_start
                                   + Plot_Cover_T
                                   + (1 | location),
                                   offset = log(rec_time_min),
                                   family = nbinom2(),
                                   data = platform_counts)

summary(platform_count_mod4_nb)
parameters(platform_count_mod4_nb)
#check the model
check_model(platform_count_mod4_nb, verbose = T)
#overdispersion
check_overdispersion(platform_count_mod4_nb)
#collinearity
check_collinearity(platform_count_mod4_nb)
# dharma package - simulate residuals and check model assumptions
platform_count_mod4_nb_sim_res <- simulateResiduals(fittedModel = platform_count_mod4_nb)
plot(platform_count_mod4_nb_sim_res)

```

```{r platform_count_mod5_nb, fig.width=6, fig.height=6}
#removing plot cover t (p= 0.769    for platform_count_mod4_nb)
platform_count_mod5_nb <- glmmTMB(count 
                                   ~ Floral_simpson_index_T 
                                   #+ top2_ratio
                                   #+ Site_type
                                   + dm_wind_velocity
                                   + dm_temperature
                                   #+ Days_since_start
                                   #+ Plot_Cover_T
                                   + (1 | location),
                                   offset = log(rec_time_min),
                                   family = nbinom2(),
                                   data = platform_counts)

summary(platform_count_mod5_nb)
parameters(platform_count_mod5_nb)
#check the model
check_model(platform_count_mod5_nb, verbose = T)
#overdispersion
check_overdispersion(platform_count_mod5_nb)
#collinearity
check_collinearity(platform_count_mod5_nb)
# dharma package - simulate residuals and check model assumptions
platform_count_mod5_nb_sim_res <- simulateResiduals(fittedModel = platform_count_mod5_nb)
plot(platform_count_mod5_nb_sim_res)
```

```{r platform_count_mod6_nb, fig.width=6, fig.height=6}
#remove floral simpson index (p= 0.284     for platform_count_mod5_nb)
platform_count_mod6_nb <- glmmTMB(count 
                                   #~ Floral_simpson_index_T 
                                   #+ top2_ratio
                                   #+ Site_type
                                   ~ dm_wind_velocity
                                   + dm_temperature
                                   #+ Days_since_start
                                   #+ Plot_Cover_T
                                   + (1 | location),
                                   offset = log(rec_time_min),
                                   family = nbinom2(),
                                   data = platform_counts)
summary(platform_count_mod6_nb)
parameters(platform_count_mod6_nb)
#check the model
check_model(platform_count_mod6_nb, verbose = T)
#overdispersion
check_overdispersion(platform_count_mod6_nb)
#collinearity
check_collinearity(platform_count_mod6_nb)
# dharma package - simulate residuals and check model assumptions
platform_count_mod6_nb_sim_res <- simulateResiduals(fittedModel = platform_count_mod6_nb)
plot(platform_count_mod6_nb_sim_res)
```


##### IV.C.1.a. Compare the models with the performance package
```{r platform_count_nb_comp1}
# Compare the models with the performance package
platform_count_nb_comp1 <- compare_performance(platform_count_mod1_nb, platform_count_mod2_nb, platform_count_mod3_nb, platform_count_mod4_nb,platform_count_mod5_nb,platform_count_mod6_nb,
                                               metrics = c("AICc", "BIC", "R2", "ICC", "RMSE"))
# Print the comparison table
print(platform_count_nb_comp1)
```
The third model is the best one because it has lower AICc and BIC values, but still reaches the model's assumptions (dharma plot of fitted vs residual looks ok, no overdispersion, etc). 

#### IV.C.1.b. visualize the model results

```{r}
#plot_model(platform_count_mod1_nb , type = "est", show.values = TRUE, value.offset = .3)
#plot_model(platform_count_mod2_nb , type = "est", show.values = TRUE, value.offset = .3)
#plot_model(platform_count_mod3_nb , type = "est", show.values = TRUE, value.offset = .3)
plot_model(platform_count_mod4_nb , type = "est", show.values = TRUE, value.offset = .3)

plot_model(platform_count_mod6_nb, 
           type = "est", 
           show.values = TRUE, 
           value.offset = 0.3,
           #sort.est = TRUE,
           axis.labels = c(#"Flower Cover % per Transect",
                           "Temperature",
                           "Wind Velocity (km/h)"#,
                           #"Floral Simpson Index"
                           )) +
    labs(title = "Platform Camera: Count of Pollinators", x = "Predictors",y = "Estimate") + 
    theme(axis.text.y = element_text(hjust = 0))  # 0 = left, 1 = right

#plot_model(platform_count_mod5_nb , type = "est", show.values = TRUE, value.offset = .3)
#plot_model(platform_count_mod6_nb , type = "est", show.values = TRUE, value.offset = .3) 

```


```{r plot platform_count_mod3_nb predictions}
## temperature platform_count_mod1_nb ---------
# Get the original mean and SD of wind velocity before scaling
temp_mean <- mean(envir_data$dm_temperature, na.rm = TRUE)
temp_sd <- sd(envir_data$dm_temperature, na.rm = TRUE)

# Get predictions on the scaled variable
pred_temp <- ggpredict(platform_count_mod3_nb , terms = "dm_temperature")

# Unscale the x-axis
pred_temp$x_unscaled <- (pred_temp$x * temp_sd) + temp_mean

# Plot
ggplot(pred_temp, aes(x = x_unscaled, y = predicted)) +
  #plot with predictor color
  geom_line(size = 1.2, color = predictor_colors[["dm_temperature"]]) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), 
              fill = alpha(predictor_colors[["dm_temperature"]], 0.5)) +
  labs(
    title = "Platform cameras: Predicted Insect Count vs Temperature",
    x = "Temperature",
    y = "Predicted Insect Count")
  
## wind velocity platform_count_mod1_nb ---------
# Get the original mean and SD of wind velocity before scaling
wind_mean <- mean(envir_data$dm_wind_velocity, na.rm = TRUE)
wind_sd <- sd(envir_data$dm_wind_velocity, na.rm = TRUE)

# Get predictions on the scaled variable
pred_wind <- ggpredict(platform_count_mod3_nb , terms = "dm_wind_velocity")

# Unscale the x-axis
pred_wind$x_unscaled <- (pred_wind$x * wind_sd) + wind_mean

# Plot
(wind_count_platform <-ggplot(pred_wind, aes(x = x_unscaled, y = predicted)) +
  #plot with predictor color
  geom_line(size = 1.2, color = predictor_colors[["dm_wind_velocity"]]) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), 
              fill = alpha(predictor_colors[["dm_wind_velocity"]], 0.5)) +
  labs(
    title = "Platform cameras: Predicted Insect Count vs Wind velocity",
    x = "Wind velocity (km/h)",
    y = "Predicted Insect Count"
  ))

```


#### IV.C.1.c. Interpretation of the model results

```{r}
#remove all objects starting with platform_count_
rm(list = ls(pattern = "^platform_count_"))
```

### IV.C.2. PLATFORM CAMERAS Richness - Poisson glmer

```{r platform_richness}
# diversity of insects per transect per site
platty <- platform_camera %>%
  group_by(location, transect) %>%
  summarise(richness = n_distinct(top1), .groups = 'drop')  # Count the occurrences of each order

#join the scaled_envir_data
platform_richness <- platty %>%
  left_join(platform_camera1, by = c("location", "transect"))%>%
  #REMOVE EXTRA COLUMNS "ID" "Site_Tn" "det_conf_mean" "track_ID_imgs" "top1_imgs" "top1_prob_mean" "top1_prob_weighted"
 dplyr::select(-c(top1,ID, Site_Tn, det_conf_mean, track_ID_imgs, top1_imgs, top1_prob_mean, top1_prob_weighted,start_time)) %>%
  #keep only unique rows
  distinct()

#histogram of richness
platform_richness %>%
  ggplot(aes(x = richness)) +
  geom_histogram(binwidth = 1, fill = "lightblue", color = "black") +
  labs(title = "Histogram of Insect Richness",
       x = "Insect Richness",
       y = "Count")

#testing the normality of the shannon index
shapiro.test(platform_richness$richness) # p-value = 0.4406, shannon index is normally distributed

#testing skewness
datawizard::describe_distribution(platform_richness$richness)
```

The data for richness captured with the platform cameras is normally distributed (shapiro test: p-value = 0.4406) and has a skewness of 0.12, indicating a slight right skew. The kurtosis is -0.67, indicating a platykurtic distribution (flatter than normal), but fairly normal.


```{r platform_richness_mod1_poiss, fig.width=6, fig.height=6}
# full model with insect richness as response variable and environmental, weather and plant diversity variables as explanatory variables, and site as random effect
# Poisson distribution

platform_richness_mod1_poiss <- glmmTMB(richness 
                                        ~ Floral_simpson_index_T 
                                        + rec_time_min
                                        + top2_ratio
                                        + Site_type
                                        + dm_wind_velocity
                                        + dm_temperature
                                        + Days_since_start
                                        + Plot_Cover_T
                                        + (1 | location),
                                        family = poisson(),
                                        data = platform_richness)
summary(platform_richness_mod1_poiss)
parameters(platform_richness_mod1_poiss)
#check for singularity
performance::check_singularity(platform_richness_mod1_poiss)
#check the model
check_model(platform_richness_mod1_poiss, verbose = T)
#overdispersion
check_overdispersion(platform_richness_mod1_poiss)
#collinearity
check_collinearity(platform_richness_mod1_poiss)
# dharma package - simulate residuals and check model assumptions
platform_richness_mod1_poiss_sim_res <- simulateResiduals(fittedModel = platform_richness_mod1_poiss)
plot(platform_richness_mod1_poiss_sim_res)
```

The Poisson model seems to fit this data well, there is no sign of overdispersion and the correlation between predictors is low. 

```{r platform_richness_mod2_poiss, fig.width=6, fig.height=6}
#remove rec time min (p= 0.716     for platform_richness_mod1_poiss)

platform_richness_mod2_poiss <- glmmTMB(richness 
                                        ~ Floral_simpson_index_T 
                                        + top2_ratio
                                        #+ rec_time_min
                                        + Site_type
                                        + dm_wind_velocity
                                        + dm_temperature
                                        + Days_since_start
                                        + Plot_Cover_T
                                        + (1 | location),
                                        family = poisson(),
                                        data = platform_richness)
summary(platform_richness_mod2_poiss)
parameters(platform_richness_mod2_poiss)
#check for singularity
performance::check_singularity(platform_richness_mod2_poiss)
#check the model
check_model(platform_richness_mod2_poiss, verbose = T)
#overdispersion
check_overdispersion(platform_richness_mod2_poiss)
#collinearity
check_collinearity(platform_richness_mod2_poiss)
# dharma package - simulate residuals and check model assumptions
platform_richness_mod2_poiss_sim_res <- simulateResiduals(fittedModel = platform_richness_mod2_poiss)
plot(platform_richness_mod2_poiss_sim_res)
```

```{r platform_richness_mod3_poiss, fig.width=6, fig.height=6}
#remove top2 ratio (p= 0.642      for platform_richness_mod2_poiss)
platform_richness_mod3_poiss <- glmmTMB(richness 
                                        ~ Floral_simpson_index_T 
                                        #+ top2_ratio
                                        + Site_type
                                        #+ rec_time_min
                                        + dm_wind_velocity
                                        + dm_temperature
                                        + Days_since_start
                                        + Plot_Cover_T
                                        + (1 | location),
                                        family = poisson(),
                                        data = platform_richness)

summary(platform_richness_mod3_poiss)
parameters(platform_richness_mod3_poiss)
#check for singularity
performance::check_singularity(platform_richness_mod3_poiss)
#check the model
check_model(platform_richness_mod3_poiss, verbose = T)
#overdispersion
check_overdispersion(platform_richness_mod3_poiss)
#collinearity
check_collinearity(platform_richness_mod3_poiss)
# dharma package - simulate residuals and check model assumptions
platform_richness_mod3_poiss_sim_res <- simulateResiduals(fittedModel = platform_richness_mod3_poiss)
plot(platform_richness_mod3_poiss_sim_res)
```

```{r platform_richness_mod4_poiss, fig.width=6, fig.height=6}
#remove days since start (p= 0.287   for platform_richness_mod3_poiss)
platform_richness_mod4_poiss <- glmmTMB(richness 
                                        ~ Floral_simpson_index_T 
                                        #+ top2_ratio
                                        #+ rec_time_min
                                        + dm_wind_velocity
                                        + Site_type
                                        + dm_temperature
                                        #+ Days_since_start
                                        + Plot_Cover_T
                                        + (1 | location),
                                        family = poisson(),
                                        data = platform_richness)
summary(platform_richness_mod4_poiss)
parameters(platform_richness_mod4_poiss)
#check for singularity
performance::check_singularity(platform_richness_mod4_poiss)
#check the model
check_model(platform_richness_mod4_poiss, verbose = T)
#overdispersion
check_overdispersion(platform_richness_mod4_poiss)
#collinearity
check_collinearity(platform_richness_mod4_poiss)
# dharma package - simulate residuals and check model assumptions
platform_richness_mod4_poiss_sim_res <- simulateResiduals(fittedModel = platform_richness_mod4_poiss)
plot(platform_richness_mod4_poiss_sim_res)
```

```{r platform_richness_mod5_poiss, fig.width=6, fig.height=6}
#remove Floral simpson index T  (p= 0.095    for platform_richness_mod4_poiss)
platform_richness_mod5_poiss <- glmmTMB(richness 
                                        #~ Floral_simpson_index_T 
                                        #+ top2_ratio
                                        ~ Site_type
                                        #+ rec_time_min
                                        + dm_wind_velocity
                                        + dm_temperature
                                        #+ Days_since_start
                                        + Plot_Cover_T
                                        + (1 | location),
                                        family = poisson(),
                                        data = platform_richness)
summary(platform_richness_mod5_poiss)
parameters(platform_richness_mod5_poiss)
#check for singularity
performance::check_singularity(platform_richness_mod5_poiss)
#check the model
check_model(platform_richness_mod5_poiss, verbose = T)
#overdispersion
check_overdispersion(platform_richness_mod5_poiss)
#collinearity
check_collinearity(platform_richness_mod5_poiss)
# dharma package - simulate residuals and check model assumptions
platform_richness_mod5_poiss_sim_res <- simulateResiduals(fittedModel = platform_richness_mod5_poiss)
plot(platform_richness_mod5_poiss_sim_res)
```

```{r platform_richness_mod6_poiss, fig.width=6, fig.height=6}
#remove plot cover t (p= 0.219    for platform_richness_mod5_poiss)
platform_richness_mod6_poiss <- glmmTMB(richness 
                                        #~ Floral_simpson_index_T 
                                        #+ top2_ratio
                                        ~ Site_type
                                        #+ rec_time_min
                                        + dm_wind_velocity
                                        + dm_temperature
                                        #+ Days_since_start
                                        #+ Plot_Cover_T
                                        + (1 | location),
                                        family = poisson(),
                                        data = platform_richness)
summary(platform_richness_mod6_poiss)
parameters(platform_richness_mod6_poiss)
#check for singularity
performance::check_singularity(platform_richness_mod6_poiss)
#check the model
check_model(platform_richness_mod6_poiss, verbose = T)
#overdispersion
check_overdispersion(platform_richness_mod6_poiss)
#collinearity
check_collinearity(platform_richness_mod6_poiss)
# dharma package - simulate residuals and check model assumptions
platform_richness_mod6_poiss_sim_res <- simulateResiduals(fittedModel = platform_richness_mod6_poiss)
plot(platform_richness_mod6_poiss_sim_res)

```

```{r platform_richness_mod7_poiss, fig.width=6, fig.height=6}
#remove site type (p= 0.376     for platform_richness_mod6_poiss)
platform_richness_mod7_poiss <- glmmTMB(richness 
                                        #~ Floral_simpson_index_T 
                                        #+ top2_ratio
                                        #+ Site_type
                                        ~ dm_wind_velocity
                                        + dm_temperature
                                        #+ Days_since_start
                                        #+ Plot_Cover_T
                                        + (1 | location),
                                        family = poisson(),
                                        data = platform_richness)
summary(platform_richness_mod7_poiss)
parameters(platform_richness_mod7_poiss)
#check for singularity
performance::check_singularity(platform_richness_mod7_poiss)
#check the model
check_model(platform_richness_mod7_poiss, verbose = T)
#overdispersion
check_overdispersion(platform_richness_mod7_poiss)
#collinearity
check_collinearity(platform_richness_mod7_poiss)
# dharma package - simulate residuals and check model assumptions
platform_richness_mod7_poiss_sim_res <- simulateResiduals(fittedModel = platform_richness_mod7_poiss)
plot(platform_richness_mod7_poiss_sim_res)
```


#### IV.C.2.a. Compare the models with the performance package
```{r platform_richness_poiss_comp1}
# Compare the models with the performance package
platform_richness_poiss_comp1 <- compare_performance(platform_richness_mod1_poiss, platform_richness_mod2_poiss, platform_richness_mod3_poiss, platform_richness_mod4_poiss, platform_richness_mod5_poiss, platform_richness_mod6_poiss, platform_richness_mod7_poiss,
                                                     platform_richness_mod5_poiss,platform_richness_mod6_poiss, metrics = c("AICc", "BIC", "R2", "ICC", "RMSE"))

# Print the comparison table
print(platform_richness_poiss_comp1)
```

#### IV.C.2.b. Visualize the model results
```{r}
#plot_model(platform_richness_mod1_poiss , type = "est", show.values = TRUE, value.offset = .3)
#plot_model(platform_richness_mod2_poiss , type = "est", show.values = TRUE, value.offset = .3)
#plot_model(platform_richness_mod3_poiss , type = "est", show.values = TRUE, value.offset = .3)
#plot_model(platform_richness_mod4_poiss , type = "est", show.values = TRUE, value.offset = .3)
plot_model(platform_richness_mod5_poiss , type = "est", show.values = TRUE, value.offset = .3)

plot_model(platform_richness_mod5_poiss, 
           type = "est", 
           show.values = TRUE, 
           value.offset = 0.3,
           #sort.est = TRUE,
           axis.labels = c("Young Restored Site",
                           "Temperature",
                           "Wind Velocity (km/h)",
                           "Floral Simpson Index"
                           )) +
    labs(title = "Platform Camera: Richness of Pollinators", x = "Predictors",y = "Estimate") + 
    theme(axis.text.y = element_text(hjust = 0))  # 0 = left, 1 = right
           
plot_model(platform_richness_mod6_poiss , type = "est", show.values = TRUE, value.offset = .3)
plot_model(platform_richness_mod7_poiss , type = "est", show.values = TRUE, value.offset = .3)
```

```{r platform_richness_mod5_poiss predictions}
## temperature platform_richness_mod5_poiss ---------
# Get the original mean and SD of wind velocity before scaling
temp_mean <- mean(envir_data$dm_temperature, na.rm = TRUE)
temp_sd <- sd(envir_data$dm_temperature, na.rm = TRUE)
# Get predictions on the scaled variable
pred_temp <- ggpredict(platform_richness_mod5_poiss , terms = "dm_temperature")
# Unscale the x-axis
pred_temp$x_unscaled <- (pred_temp$x * temp_sd) + temp_mean
# Plot
ggplot(pred_temp, aes(x = x_unscaled, y = predicted)) +
  #plot with predictor_color
  geom_line(size = 1.2, color = predictor_colors[["dm_temperature"]]) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), 
              fill = alpha(predictor_colors[["dm_temperature"]], 0.5)) +
  labs(
    title = "Platform cameras: Predicted Insect Richness vs Temperature",
    x = "Temperature",
    y = "Predicted Insect Richness"
  ) 

## wind velocity platform_richness_mod5_poiss ---------
# Get the original mean and SD of wind velocity before scaling
wind_mean <- mean(envir_data$dm_wind_velocity, na.rm = TRUE)
wind_sd <- sd(envir_data$dm_wind_velocity, na.rm = TRUE)
# Get predictions on the scaled variable
pred_wind <- ggpredict(platform_richness_mod5_poiss , terms = "dm_wind_velocity")
# Unscale the x-axis
pred_wind$x_unscaled <- (pred_wind$x * wind_sd) + wind_mean
# Plot
ggplot(pred_wind, aes(x = x_unscaled, y = predicted)) +
  #plot with predictor color
  geom_line(size = 1.2, color = predictor_colors[["dm_wind_velocity"]]) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), 
              fill = alpha(predictor_colors[["dm_wind_velocity"]], 0.5)) +
  labs(
    title = "Platform cameras: Predicted Insect Richness vs Wind velocity",
    x = "Wind velocity (m/s)",
    y = "Predicted Insect Richness"
  ) 
```


#### IV.C.2.c. interpretation of the model results

This model has a Poisson distribution with a log-link, and an offset for the recording time per transect. We can see that the model is a good fit for the data, with no overdispersion and low correlation. The most parsimonious model is the one with the lowest AICc and BIC values, which is the model with only wind velocity and temperature as fixed effects. This model shows that with increasing wind velocity and temperature, the insect richness captured by the camera each minute decreases The previous models also show that the floral Simpson index, time of day, site type and days since start are not significant predictors of insect richness.

Fourth model also has the one of the lowest AICc and BIC values, but still meets the model's assumptions (dharma plot of fitted vs residual looks ok, no overdispersion, etc).


```{r}
#remove all objects starting with platform_richness_
rm(list = ls(pattern = "^platform_richness_"))
```


### IV.C.3. PLATFORM CAMERAS Shannon - GAUSSIAN glmer (rec_time_min as predictor)

```{r platform_diversity}
# diversity of insects per transect per site
platform_diversity <- platform_camera %>%
  #create new column with counts = 1
  mutate(count = 1) %>%
  #wide format filled with counts, fill empty cells with 0
  pivot_wider(names_from = top1, values_from = count, values_fill = 0) %>%
  #remove irrelevant columns
 dplyr::select(-c(ID, Site_Tn, det_conf_mean, track_ID_imgs, top1_imgs, top1_prob_mean, top1_prob_weighted, cam_ID, start_time))%>%
  #sum up rows that have same transect and site
  group_by(location, transect,date) %>%
  summarise(across(fly_sarco:fly_empi, sum), .groups = 'drop') %>%
  #calculate shannon index and simpson index
  mutate(shannon_diversity = diversity(across(fly_sarco:fly_empi), index = "shannon"),
         simpson_diversity = diversity(across(fly_sarco:fly_empi), index = "simpson"))%>%
  #remove irrelevant columns
 dplyr::select(-c(fly_sarco:fly_empi), -date) %>%
  #join the scaled_envir_data
  left_join(platform_camera1, by = c("location", "transect"))%>%
  #REMOVE EXTRA COLUMNS "ID" "Site_Tn" "det_conf_mean" "track_ID_imgs" "top1_imgs" "top1_prob_mean" "top1_prob_weighted"
 dplyr::select(-c(ID, Site_Tn, det_conf_mean, track_ID_imgs, top1, top1_imgs, top1_prob_mean, top1_prob_weighted, date,cam_ID, start_time)) %>%
  #keep only unique rows
  distinct()

#scale rec_time_min
platform_diversity <- platform_diversity %>%
  mutate(rec_time_min_scaled = scale(rec_time_min))%>%
  #scale plot cover t
  mutate(Plot_Cover_T = scale(Plot_Cover_T))
```

```{r platform_shannon}
#histogram of shannon index
platform_diversity %>%
  ggplot(aes(x = shannon_diversity)) +
  geom_histogram(binwidth = 0.1, fill = "lightblue", color = "black") +
  labs(title = "Histogram of Insect Shannon Diversity",
       x = "Insect Shannon Diversity",
       y = "Count")

#testing the normality of the shannon index
shapiro.test(platform_diversity$shannon_diversity) # p-value = 0.1193, shannon index is normally distributed

datawizard::describe_distribution(platform_diversity$shannon_diversity)
```

The data for shannon diversity captured with the platform cameras is normally distributed (shapiro test: p-value = 0.1193) and has a skewness of -0.28, indicating a slight left skew. The kurtosis is -0.28, indicating a platykurtic distribution (flatter than normal), but fairly normal.

Since a normal distribution is assumed, we will use a gaussian distribution for the model. However, Gaussian models cannot include an offset parameter. Here, there are two options: either add the rec_time_min as a predictor, or divide the diversity index by the recording time, in order to have as a response variable the diversity index per minute of recording.  

A first try with rates was not successful. And after some thought, using an index rate doesn't seem to make a lot of sense, so we decided to use a gaussian distribution with the rec_time_min as a predictor. 

```{r platform_shannon_mod1_gauss, fig.width=6, fig.height=6}
# full model with insect shannon diversity as response variable and environmental, weather and plant diversity variables as explanatory variables, and site as random effect, and recording time is included to account for sampling effort differences



platform_shannon_mod1_gauss <- lmer(shannon_diversity 
                                   ~ Floral_simpson_index_T 
                                   + rec_time_min_scaled
                                   + top2_ratio
                                   + Site_type
                                   + Days_since_start
                                   + dm_wind_velocity
                                   + dm_temperature
                                   + Plot_Cover_T
                                   + (1 | location), 
                                   data = platform_diversity)
summary(platform_shannon_mod1_gauss)
parameters(platform_shannon_mod1_gauss)
#check for singularity
performance::check_singularity(platform_shannon_mod1_gauss)
#check the model
check_model(platform_shannon_mod1_gauss, verbose = T)
#overdispersion
check_overdispersion(platform_shannon_mod1_gauss)
#collinearity
check_collinearity(platform_shannon_mod1_gauss)
# dharma package - simulate residuals and check model assumptions
platform_shannon_mod1_gauss_sim_res <- simulateResiduals(fittedModel = platform_shannon_mod1_gauss)
plot(platform_shannon_mod1_gauss_sim_res)

```

```{r platform_shannon_mod2_gauss, fig.width=6, fig.height=6}
#remove top2 ratio (p= 0.898  for platform_shannon_mod1_gauss)
platform_shannon_mod2_gauss <- lmer(shannon_diversity 
                                   ~ Floral_simpson_index_T 
                                   + rec_time_min_scaled
                                   #+ top2_ratio
                                   + Site_type
                                   + Days_since_start
                                   + dm_wind_velocity
                                   + dm_temperature
                                   + Plot_Cover_T
                                   + (1 | location), 
                                   data = platform_diversity)

summary(platform_shannon_mod2_gauss)
parameters(platform_shannon_mod2_gauss)
#check for singularity
performance::check_singularity(platform_shannon_mod2_gauss)
#check the model
check_model(platform_shannon_mod2_gauss, verbose = T)
#overdispersion
check_overdispersion(platform_shannon_mod2_gauss)
#collinearity
check_collinearity(platform_shannon_mod2_gauss)
# dharma package - simulate residuals and check model assumptions
platform_shannon_mod2_gauss_sim_res <- simulateResiduals(fittedModel = platform_shannon_mod2_gauss)
plot(platform_shannon_mod2_gauss_sim_res)

```

```{r platform_shannon_mod3_gauss, fig.width=6, fig.height=6}
# remove wind velocity (p= 0.293   for platform_shannon_mod2_gauss)
platform_shannon_mod3_gauss <- lmer(shannon_diversity 
                                   ~ Floral_simpson_index_T 
                                   + rec_time_min_scaled
                                   #+ top2_ratio
                                   + Site_type
                                   #+ dm_wind_velocity
                                   + Days_since_start
                                   + dm_temperature
                                   + Plot_Cover_T
                                   + (1 | location), 
                                   data = platform_diversity)

summary(platform_shannon_mod3_gauss)
parameters(platform_shannon_mod3_gauss)
#check for singularity
performance::check_singularity(platform_shannon_mod3_gauss)
#check the model
  
check_model(platform_shannon_mod3_gauss, verbose = T)
#overdispersion
check_overdispersion(platform_shannon_mod3_gauss)
#collinearity
check_collinearity(platform_shannon_mod3_gauss)
# dharma package - simulate residuals and check model assumptions
platform_shannon_mod3_gauss_sim_res <- simulateResiduals(fittedModel = platform_shannon_mod3_gauss)
plot(platform_shannon_mod3_gauss_sim_res)

```

```{r platform_shannon_mod4_gauss, fig.width=6, fig.height=6}
#remove site type (p= 0.241   for platform_shannon_mod3_gauss)
platform_shannon_mod4_gauss <- lmer(shannon_diversity 
                                   ~ Floral_simpson_index_T 
                                   + rec_time_min_scaled
                                   #+ top2_ratio
                                   #+ Site_type
                                   #+ dm_wind_velocity
                                   + Days_since_start
                                   + dm_temperature
                                   + Plot_Cover_T
                                   + (1 | location), 
                                   data = platform_diversity)
summary(platform_shannon_mod4_gauss)
parameters(platform_shannon_mod4_gauss)
#check for singularity
performance::check_singularity(platform_shannon_mod4_gauss)
#check the model
check_model(platform_shannon_mod4_gauss, verbose = T)
#overdispersion
check_overdispersion(platform_shannon_mod4_gauss)
#collinearity
check_collinearity(platform_shannon_mod4_gauss)
# dharma package - simulate residuals and check model assumptions
platform_shannon_mod4_gauss_sim_res <- simulateResiduals(fittedModel = platform_shannon_mod4_gauss)
plot(platform_shannon_mod4_gauss_sim_res)
```

```{r platform_shannon_mod5_gauss, fig.width=6, fig.height=6}
#remove days since start (p= 0.081   for platform_shannon_mod4_gauss)
platform_shannon_mod5_gauss <- lmer(shannon_diversity 
                                   ~ Floral_simpson_index_T 
                                   + rec_time_min_scaled
                                   #+ top2_ratio
                                   #+ Site_type
                                   #+ dm_wind_velocity
                                   #+ Days_since_start
                                   + dm_temperature
                                   + Plot_Cover_T
                                   + (1 | location), 
                                   data = platform_diversity)
summary(platform_shannon_mod5_gauss)
parameters(platform_shannon_mod5_gauss)
#check for singularity
performance::check_singularity(platform_shannon_mod5_gauss)
#check the model
check_model(platform_shannon_mod5_gauss, verbose = T)
#overdispersion
check_overdispersion(platform_shannon_mod5_gauss)
#collinearity
check_collinearity(platform_shannon_mod5_gauss)
# dharma package - simulate residuals and check model assumptions
platform_shannon_mod5_gauss_sim_res <- simulateResiduals(fittedModel = platform_shannon_mod5_gauss)
#plot(platform_shannon_mod5_gauss_sim_res)
testUniformity(platform_shannon_mod5_gauss_sim_res) 
```

```{r platform_shannon_mod6_gauss, fig.width=6, fig.height=6}
#remove dm temperature (p= 0.119    for platform_shannon_mod5_gauss)
platform_shannon_mod6_gauss <- lmer(shannon_diversity 
                                   ~ Floral_simpson_index_T 
                                   + rec_time_min_scaled
                                   #+ top2_ratio
                                   #+ Site_type
                                   #+ dm_wind_velocity
                                   #+ Days_since_start
                                   #+ dm_temperature
                                   + Plot_Cover_T
                                   + (1 | location), 
                                   data = platform_diversity)
summary(platform_shannon_mod6_gauss)
parameters(platform_shannon_mod6_gauss)
#check for singularity
performance::check_singularity(platform_shannon_mod6_gauss)
#check the model
check_model(platform_shannon_mod6_gauss, verbose = T)
#overdispersion
check_overdispersion(platform_shannon_mod6_gauss)
#collinearity
check_collinearity(platform_shannon_mod6_gauss)
# dharma package - simulate residuals and check model assumptions
platform_shannon_mod6_gauss_sim_res <- simulateResiduals(fittedModel = platform_shannon_mod6_gauss)
plot(platform_shannon_mod6_gauss_sim_res)
```


#### IV.C.3.a Compare the models with the performance package
```{r platform_shannon_gauss_comp1}
# Compare the models with the performance package
platform_shannon_gauss_comp1 <- compare_performance(platform_shannon_mod1_gauss, platform_shannon_mod2_gauss, platform_shannon_mod3_gauss, platform_shannon_mod4_gauss, platform_shannon_mod5_gauss, platform_shannon_mod6_gauss,
                                                     platform_shannon_mod5_gauss,platform_shannon_mod6_gauss,
                                                    metrics = c("AICc", "BIC", "R2", "ICC", "RMSE"))
# Print the comparison table
print(platform_shannon_gauss_comp1)
```

The first model platform_shannon_mod1_gauss is the only one that fits the dharma predicted vs residuals plot. The other models show a clear pattern in the residuals, indicating that they might not be a good fit for the data.

#### IV.C.3.b. Visualize the model results
```{r}
#plot_model(platform_shannon_mod1_gauss , type = "est", show.values = TRUE, value.offset = .3)
#plot_model(platform_shannon_mod2_gauss , type = "est", show.values = TRUE, value.offset = .3)
#plot_model(platform_shannon_mod3_gauss , type = "est", show.values = TRUE, value.offset = .3)
#plot_model(platform_shannon_mod4_gauss , type = "est", show.values = TRUE, value.offset = .3)
#plot_model(platform_shannon_mod5_gauss , type = "est", show.values = TRUE, value.offset = .3)
plot_model(platform_shannon_mod6_gauss , type = "est", show.values = TRUE, value.offset = .3)
(estplatshan <- plot_model(platform_shannon_mod6_gauss, 
           type = "est", 
           show.values = TRUE, 
           value.offset = 0.3,
           #sort.est = TRUE,
           axis.labels = c("Flower Cover % per Transect",
                           "Recording time (min)",
                           "Floral Simpson Index"
                           )) +
    labs(title = "Platform Camera: Shannon Diversity of Pollinators", x = "Predictors",y = "Estimate") + 
    theme(axis.text.y = element_text(hjust = 0)))  # 0 = left, 1 = right
```

```{r plot platform_shannon_mod6_gauss predictions}

##PLOT COVER platform_shannon_mod6_gauss---------
# Get the original mean and SD of plot cover before scaling
plot_cover_mean <- mean(envir_data$Plot_Cover_T, na.rm = TRUE)
plot_cover_sd <- sd(envir_data$Plot_Cover_T, na.rm = TRUE)
# Get predictions on the scaled variable
#pred_plot_cover <- ggpredict(platform_shannon_mod6_gauss , terms = "Plot_Cover_T")

# Get observed scaled range
range_scaled <- range(scale(envir_data$Plot_Cover_T), na.rm = TRUE)

# Generate predictions only within that range
pred_plot_cover <- ggpredict(platform_shannon_mod6_gauss , 
                             terms = paste0("Plot_Cover_T [", round(range_scaled[1], 2), ":", round(range_scaled[2], 2), "]"))

# Unscale the x-axis
pred_plot_cover$x_unscaled <- (pred_plot_cover$x * plot_cover_sd) + plot_cover_mean
# Plot
ggplot(pred_plot_cover, aes(x = x_unscaled, y = predicted)) +
  #plot with predictor color
  geom_line(size = 1.2, color = predictor_colors[["Plot_Cover_T"]]) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), 
              fill = alpha(predictor_colors[["Plot_Cover_T"]], 0.5)) +
  labs(
    title = "Platform: Predicted Insect Shannon Diversity vs Floral Cover %",
    x = "Floral Cover: average % of flower cover per transect",
    y = "Predicted Pollinator Shannon Diversity on platform cameras"
  )+
  scale_y_continuous(limits = c(0, 1.5))  # Set y-axis from 0 to 1.5


## floral simpson index platform_shannon_mod6_gauss---------
# Get the original mean and SD of floral simpson index before scaling
floral_simpson_mean <- mean(envir_data$Floral_simpson_index_T, na.rm = TRUE)
floral_simpson_sd <- sd(envir_data$Floral_simpson_index_T, na.rm = TRUE)
# Get predictions on the scaled variable
pred_floral_simpson <- ggpredict(platform_shannon_mod6_gauss , terms = "Floral_simpson_index_T")
# Unscale the x-axis
pred_floral_simpson$x_unscaled <- (pred_floral_simpson$x * floral_simpson_sd) + floral_simpson_mean
# Plot
(florplatshan <-ggplot(pred_floral_simpson, aes(x = x_unscaled, y = predicted)) +
  #plot with predictor color
  geom_line(size = 1.2, color = predictor_colors[["Floral_simpson_index_T"]]) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), 
              fill = alpha(predictor_colors[["Floral_simpson_index_T"]], 0.5)) +
  labs(
    title = "Platform: Predicted Insect Shannon Diversity vs Floral Simpson Index",
    x = "Floral Simpson Index",
    y = "Predicted Pollinator Shannon Diversity \non platform cameras"
  ))

## rec time min platform_shannon_mod6_gauss---------
# Get the original mean and SD of rec time min before scaling
rec_time_min_mean <- mean(platform_diversity$rec_time_min, na.rm = TRUE)
rec_time_min_sd <- sd(platform_diversity$rec_time_min, na.rm = TRUE)
# Get predictions on the scaled variable
pred_rec_time_min <- ggpredict(platform_shannon_mod6_gauss , terms = "rec_time_min_scaled")
# Unscale the x-axis
pred_rec_time_min$x_unscaled <- (pred_rec_time_min$x * rec_time_min_sd) + rec_time_min_mean
# Plot
ggplot(pred_rec_time_min, aes(x = x_unscaled, y = predicted)) +
  #plot with predictor color
  geom_line(size = 1.2, color = predictor_colors[["rec_time_min"]]) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), 
              fill = alpha(predictor_colors[["rec_time_min"]], 0.5)) +
  labs(
    title = "Platform: Predicted Insect Shannon Diversity vs Recording time",
    x = "Recording time (minutes)",
    y = "Predicted Pollinator Shannon Diversity on platform cameras"
  )
```


```{r}
#combine plots florplatshan and estplatshan
library(cowplot)

florplatshan1 <- florplatshan + 
  #change title
  labs(title = "Predicted Pollinator Shannon Diversity vs Floral Simpson Index")+
  #title font to 14
  theme(plot.title = element_text(size = 14))
estplatshan1 <- estplatshan + 
  #change title
  labs(title = "Pollinator Shannon Diversity") +
  theme(plot.title = element_text(size = 14))

# Step 1: Combine the plots and label ONLY them (A and B)
combined_plots <- cowplot::plot_grid(
  estplatshan1, florplatshan1,
  ncol = 2,
  labels = c("A", "B"),   # Label just these two plots
  label_size = 14, 
  rel_widths = c(1, 1.1) # Equal width for both plots
)

# Step 2: Add the title separately, so it doesn't get a label
(final_plot <- cowplot::plot_grid(
  ggdraw() + draw_label(
    "Platform Cameras: Pollinator Shannon Diversity", 
    fontface = 'bold', size = 14, x = 0.5, hjust = 0.5
  ),
  combined_plots,
  ncol = 1,
  rel_heights = c(0.1, 1)  # Title height vs. plots height
))

#save the plot
ggsave("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/figures/platform_shannon_diversity.png", 
       width = 12, height = 6, dpi = 600)



#rm(florplatshan,estplatshan , florplatshan1, estplatshan1)
```


#### IV.C.3.c. Interpretation of the model results

```{r}
#remove all objects starting with platform_shannon_
rm(list = ls(pattern = "^platform_shannon_"))
```


### IV.C.4. PLATFORM CAMERAS Simpson - beta regression

```{r platform_simpson}
#histogram of simpson index
platform_diversity %>%
  ggplot(aes(x = simpson_diversity)) +
  geom_histogram(binwidth = 0.1, fill = "lightblue", color = "black") +
  labs(title = "Histogram of Insect Simpson Diversity",
       x = "Insect Simpson Diversity",
       y = "Count")

#testing the normality of the simpson index
shapiro.test(platform_diversity$simpson_diversity) # p-value = 0.001222, simpson index is not normally distributed
datawizard::describe_distribution(platform_diversity$simpson_diversity)

#adding a small number to all simpson index values
platform_diversity <- platform_diversity %>%
  mutate(simpson_diversity = simpson_diversity + 0.0001)

#histogram of rec_time_min
platform_diversity %>%
  ggplot(aes(x = rec_time_min)) +
  geom_histogram(fill = "lightblue", color = "black") +
  labs(title = "Histogram of Recording Time",
       x = "Recording Time (minutes)",
       y = "Count")

#testing the normality of the rec_time_min
shapiro.test(platform_diversity$rec_time_min) # p-value = , rec_time_min is not normally distributed
datawizard::describe_distribution(platform_diversity$rec_time_min)
summary(platform_diversity$rec_time_min)
```

The data for simpson diversity captured with the platform cameras is not normally distributed (shapiro test: p-value = 0.001222) and has a skewness of -1.13, indicating a  left skew. The kurtosis is 0.35, slightly peaked. Since the values are between 0 and 1, we'll use a beta distribution. However, we need to add a small number to all values to avoid 0 and 1 values, as the beta distribution cannot handle them. We will add 0.000001 to all values. 

"Model fitting was performed using the glmmTMB package (Brooks et al., 2017), with the BFGS optimization method (optim(method = "BFGS")) specified to improve convergence. BFGS is a quasi-Newton optimization algorithm that uses both gradient and approximated Hessian information to locate the maximum likelihood estimates more efficiently, particularly in non-linear, constrained optimization problems such as beta regression. This method was chosen after initial fitting attempts using the default optimizer resulted in convergence warnings and NaN function evaluations. Using BFGS yielded stable estimates and improved model diagnostics, without overfitting or inflated standard errors."

```{r platform_simpson_mod1_beta, fig.width=6, fig.height=6}
# full model with insect simpson diversity as response variable and environmental, weather and plant diversity variables as explanatory variables, and site as random effect, and recording time is included to account for sampling effort differences

platform_simpson_mod1_beta <- glmmTMB(simpson_diversity 
                                       ~ Floral_simpson_index_T 
                                       + rec_time_min
                                       + top2_ratio
                                       + Site_type
                                       + Days_since_start
                                       + dm_wind_velocity 
                                       + dm_temperature 
                                       + Plot_Cover_T
                                       + (1 | location), 
                                     family = beta_family(link = "logit"), 
                                     control = glmmTMBControl(optimizer = optim, optArgs = list(method = "BFGS")),
                                     data = platform_diversity)
summary(platform_simpson_mod1_beta)
parameters(platform_simpson_mod1_beta)
#check for singularity
performance::check_singularity(platform_simpson_mod1_beta)
#check the model
check_model(platform_simpson_mod1_beta, verbose = T)
#overdispersion
check_overdispersion(platform_simpson_mod1_beta)
#collinearity
check_collinearity(platform_simpson_mod1_beta)
# dharma package - simulate residuals and check model assumptions
platform_simpson_mod1_beta_sim_res <- simulateResiduals(fittedModel = platform_simpson_mod1_beta)
plot(platform_simpson_mod1_beta_sim_res)
```

```{r platform_simpson_mod2_beta, fig.width=6, fig.height=6}
#remove top2 ratio (p= 0.060      for platform_simpson_mod1_beta)
platform_simpson_mod2_beta <- glmmTMB(simpson_diversity 
                                       ~ Floral_simpson_index_T 
                                       # top2_ratio
                                       + rec_time_min
                                       + Site_type
                                       + Days_since_start
                                       + dm_wind_velocity 
                                       + dm_temperature 
                                       + Plot_Cover_T
                                       + (1 | location), 
                                     family = beta_family(link = "logit"), 
                                     control = glmmTMBControl(optimizer = optim, optArgs = list(method = "BFGS")),
                                     data = platform_diversity)
summary(platform_simpson_mod2_beta)
parameters(platform_simpson_mod2_beta)
#check for singularity
performance::check_singularity(platform_simpson_mod2_beta)
#check the model
check_model(platform_simpson_mod2_beta, verbose = T)
#overdispersion
check_overdispersion(platform_simpson_mod2_beta)
#collinearity
check_collinearity(platform_simpson_mod2_beta)
# dharma package - simulate residuals and check model assumptions
platform_simpson_mod2_beta_sim_res <- simulateResiduals(fittedModel = platform_simpson_mod2_beta)
plot(platform_simpson_mod2_beta_sim_res)

```

```{r platform_simpson_mod3_beta, fig.width=6, fig.height=6}
#remove wind velocity (p= 0.040   for platform_simpson_mod2_beta)
platform_simpson_mod3_beta <- glmmTMB(simpson_diversity 
                                       ~ Floral_simpson_index_T 
                                       # top2_ratio
                                       + Site_type
                                       + rec_time_min
                                       #+ dm_wind_velocity 
                                       + Days_since_start
                                       + dm_temperature 
                                       + Plot_Cover_T
                                       + (1 | location), 
                                     family = beta_family(link = "logit"), 
                                     control = glmmTMBControl(optimizer = optim, optArgs = list(method = "BFGS")),
                                     data = platform_diversity)

summary(platform_simpson_mod3_beta)
parameters(platform_simpson_mod3_beta)
#check for singularity
performance::check_singularity(platform_simpson_mod3_beta)
#check the model
check_model(platform_simpson_mod3_beta, verbose = T)
#overdispersion
check_overdispersion(platform_simpson_mod3_beta)
#collinearity
check_collinearity(platform_simpson_mod3_beta)
# dharma package - simulate residuals and check model assumptions
platform_simpson_mod3_beta_sim_res <- simulateResiduals(fittedModel = platform_simpson_mod3_beta)
plot(platform_simpson_mod3_beta_sim_res)

```

```{r platform_simpson_mod4_beta, fig.width=6, fig.height=6}
#removing site type
platform_simpson_mod4_beta <- glmmTMB(simpson_diversity 
                                       ~ Floral_simpson_index_T 
                                       # top2_ratio
                                       #+ Site_type
                                       + rec_time_min
                                       #+ dm_wind_velocity 
                                       + Days_since_start
                                       + dm_temperature 
                                       + Plot_Cover_T
                                       + (1 | location), 
                                     family = beta_family(link = "logit"), 
                                     control = glmmTMBControl(optimizer = optim, optArgs = list(method = "BFGS")),
                                     data = platform_diversity)
summary(platform_simpson_mod4_beta)
parameters(platform_simpson_mod4_beta)
#check for singularity
performance::check_singularity(platform_simpson_mod4_beta)
#check the model
check_model(platform_simpson_mod4_beta, verbose = T)

#overdispersion
check_overdispersion(platform_simpson_mod4_beta)
#collinearity
check_collinearity(platform_simpson_mod4_beta)
# dharma package - simulate residuals and check model assumptions
platform_simpson_mod4_beta_sim_res <- simulateResiduals(fittedModel = platform_simpson_mod4_beta)
plot(platform_simpson_mod4_beta_sim_res)
```

```{r platform_simpson_mod5_beta, fig.width=6, fig.height=6}
#remove temperature
platform_simpson_mod5_beta <- glmmTMB(simpson_diversity 
                                       ~ Floral_simpson_index_T 
                                       # top2_ratio
                                       #+ Site_type
                                       + rec_time_min
                                       #+ dm_wind_velocity 
                                       + Days_since_start
                                       #+ dm_temperature 
                                       + Plot_Cover_T
                                       + (1 | location), 
                                     family = beta_family(link = "logit"), 
                                     control = glmmTMBControl(optimizer = optim, optArgs = list(method = "BFGS")),
                                     data = platform_diversity)
summary(platform_simpson_mod5_beta)
parameters(platform_simpson_mod5_beta)
#check for singularity
performance::check_singularity(platform_simpson_mod5_beta)
#check the model
check_model(platform_simpson_mod5_beta, verbose = T)
#overdispersion
check_overdispersion(platform_simpson_mod5_beta)
#collinearity
check_collinearity(platform_simpson_mod5_beta)
# dharma package - simulate residuals and check model assumptions
platform_simpson_mod5_beta_sim_res <- simulateResiduals(fittedModel = platform_simpson_mod5_beta)
plot(platform_simpson_mod5_beta_sim_res)

```

```{r platform_simpson_mod6_beta, fig.width=6, fig.height=6}
#remove days since start
platform_simpson_mod6_beta <- glmmTMB(simpson_diversity 
                                       ~ Floral_simpson_index_T 
                                       # top2_ratio
                                       #+ Site_type
                                       + rec_time_min
                                       #+ dm_wind_velocity 
                                       #+ Days_since_start
                                       #+ dm_temperature 
                                       + Plot_Cover_T
                                       + (1 | location), 
                                     family = beta_family(link = "logit"), 
                                     control = glmmTMBControl(optimizer = optim, optArgs = list(method = "BFGS")),
                                     data = platform_diversity)
summary(platform_simpson_mod6_beta)
parameters(platform_simpson_mod6_beta)
#check for singularity
performance::check_singularity(platform_simpson_mod6_beta)
#check the model
check_model(platform_simpson_mod6_beta, verbose = T)
#overdispersion
check_overdispersion(platform_simpson_mod6_beta)
#collinearity
check_collinearity(platform_simpson_mod6_beta)
# dharma package - simulate residuals and check model assumptions
platform_simpson_mod6_beta_sim_res <- simulateResiduals(fittedModel = platform_simpson_mod6_beta)
plot(platform_simpson_mod6_beta_sim_res)
```


#### IV.C.4.a. Compare the models with the performance package
```{r platform_simpson_beta_comp1}
# Compare the models with the performance package
platform_simpson_beta_comp1 <- compare_performance(platform_simpson_mod1_beta, platform_simpson_mod2_beta, platform_simpson_mod3_beta, platform_simpson_mod4_beta, platform_simpson_mod5_beta, platform_simpson_mod6_beta,
                                                  metrics = c("AICc", "BIC", "R2", "ICC", "RMSE"))
# Print the comparison table
print(platform_simpson_beta_comp1)
``` 

#### IV.C.4.b. Visualize the model results
```{r}
plot_model(platform_simpson_mod1_beta , type = "est", show.values = TRUE, value.offset = .3)

plot_model(platform_simpson_mod2_beta , type = "est", show.values = TRUE, value.offset = .3)
plot_model(platform_simpson_mod3_beta , type = "est", show.values = TRUE, value.offset = .3)
plot_model(platform_simpson_mod4_beta , type = "est", show.values = TRUE, value.offset = .3)
plot_model(platform_simpson_mod5_beta , type = "est", show.values = TRUE, value.offset = .3)
plot_model(platform_simpson_mod6_beta , type = "est", show.values = TRUE, value.offset = .3)
plot_model(platform_simpson_mod6_beta, 
           type = "est", 
           show.values = TRUE, 
           value.offset = 0.3,
           #sort.est = TRUE,
           axis.labels = c("Flower Cover % per Transect",
                           "Recording time (min)",
                           "Floral Simpson Index"
                           )) +
    labs(title = "Platform Camera: Simpson Diversity of Pollinators", x = "Predictors",y = "Estimate") + 
    theme(axis.text.y = element_text(hjust = 0))  # 0 = left, 1 = right
```

```{r}
##PLOT COVER platform_simpson_mod6_beta---------
# Get the original mean and SD of plot cover before scaling
plot_cover_mean <- mean(envir_data$Plot_Cover_T, na.rm = TRUE)
plot_cover_sd <- sd(envir_data$Plot_Cover_T, na.rm = TRUE)
# Get predictions on the scaled variable
pred_plot_cover <- ggpredict(platform_simpson_mod6_beta , terms = "Plot_Cover_T")
# Unscale the x-axis
pred_plot_cover$x_unscaled <- (pred_plot_cover$x * plot_cover_sd) + plot_cover_mean
# Plot
ggplot(pred_plot_cover, aes(x = x_unscaled, y = predicted)) +
  #plot with predictor color
  geom_line(size = 1.2, color = predictor_colors[["Plot_Cover_T"]]) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), 
              fill = alpha(predictor_colors[["Plot_Cover_T"]], 0.5)) +
  labs(
    title = "Platform: Predicted Insect Simpson Diversity vs Floral Cover %",
    x = "Floral Cover: average % of flower cover per transect",
    y = "Predicted Pollinator Simpson Diversity on platform cameras"
  )+
  #limit x axis to 0-100
  scale_x_continuous(limits = c(0, 120))

## floral simpson index platform_simpson_mod6_beta---------
# Get the original mean and SD of floral simpson index before scaling
floral_simpson_mean <- mean(envir_data$Floral_simpson_index_T, na.rm = TRUE)
floral_simpson_sd <- sd(envir_data$Floral_simpson_index_T, na.rm = TRUE)
# Get predictions on the scaled variable
pred_floral_simpson <- ggpredict(platform_simpson_mod6_beta , terms = "Floral_simpson_index_T")
# Unscale the x-axis
pred_floral_simpson$x_unscaled <- (pred_floral_simpson$x * floral_simpson_sd) + floral_simpson_mean
# Plot
ggplot(pred_floral_simpson, aes(x = x_unscaled, y = predicted)) +
  #plot with predictor color
  geom_line(size = 1.2, color = predictor_colors[["Floral_simpson_index_T"]]) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), 
              fill = alpha(predictor_colors[["Floral_simpson_index_T"]], 0.5)) +
  labs(
    title = "Platform: Predicted Insect Simpson Diversity vs Floral Simpson Index",
    x = "Floral Simpson Index",
    y = "Predicted Pollinator Simpson Diversity on platform cameras"
  )

## Rec time min platform_simpson_mod6_beta---------
# Get the original mean and SD of rec time min before scaling
rec_time_min_mean <- mean(platform_diversity$rec_time_min, na.rm = TRUE)
rec_time_min_sd <- sd(platform_diversity$rec_time_min, na.rm = TRUE)
# Get predictions on the scaled variable
pred_rec_time_min <- ggpredict(platform_simpson_mod6_beta , terms = "rec_time_min")
# Unscale the x-axis
pred_rec_time_min$x_unscaled <- (pred_rec_time_min$x * rec_time_min_sd) + rec_time_min_mean
# Plot
ggplot(pred_rec_time_min, aes(x = x_unscaled, y = predicted)) +
  #plot with predictor color
  geom_line(size = 1.2, color = predictor_colors[["rec_time_min"]]) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), 
              fill = alpha(predictor_colors[["rec_time_min"]], 0.5)) +
  labs(
    title = "Platform: Predicted Insect Simpson Diversity vs Recording time",
    x = "Recording time (minutes)",
    y = "Predicted Pollinator Simpson Diversity on platform cameras"
  )
```


#### IV.C.4.c. Interpretation of the model results

# WTF IS HAPPENING HERE
```{r}
#remove all objects starting with platform_simpson_
rm(list = ls(pattern = "^platform_simpson_"))
```



## IV.D. Flower cameras

The flower cameras images were taken every 5 seconds, so to account for some of the repeats in the images, we will group together the images taken in the same minute and classified as the same family. We will also remove the images that are not classified as a family, and those that are classified as other families. 
For now, we put the family confidence at a threshold of 0.5, but we can change that later if needed. 

In the platform cameras, we took recording time into account because not all sessions were the same length. For the flower cameras, the recording either worked well for the whole duration (360 minutes), or simply never started. That is why instead of having 5 flowers x 9 sites = 45 rows, we have 40 rows. The missing recordings are as follows: 
JEP	cam35	hyp_per
KOT	cam35	pas_sat
WED	cam35	pas_sat
STP	cam31	dau_car
DES	cam35	tri_pra

The flower cameras were not placed on specific transects, but on individual flowers that were representative of the most abundant flower species in the area. We need to calculate the average flower cover per site instead of per transect, as well as the average floral Simpson index per site. 

```{r}
# flower camera data
flower_camera_modelling <- flower_camera %>%
  #remove all rows in calssification categroy that are other_families
  filter(Classification_Category != "other_families") %>%
  #remove all rows that are below 0.5 in Family_Confidence
  filter(Family_Confidence >= 0.5) %>%
  #transform time as character 
  mutate(time = as.character(time)) %>%
  #transform specific row 08:59:13 to 09:01:00
  mutate(time = ifelse(time == "08:59:13", "09:01:00", time)) %>%
  #remove the last 3 characters of the time column
  mutate(time = substr(time, 1, nchar(time) - 3)) %>%
  #split the time column into two columns: hours and minutes
  separate(time, into = c("hours", "minutes"), sep = ":") %>%
  #convert the hours and minutes columns to numeric
  mutate(hours = as.numeric(hours),
         minutes = as.numeric(minutes)) %>%
  # transfrom time into minutes since 9am
  mutate(minutes_since_9am = (hours - 9) * 60 + minutes)
  
  
flower_camera_famcount_reduced <- flower_camera_modelling %>%
  #keep only first occurrence of a row where site, flower_sp, family and minutes since 9am are the same
  #this will remove the duplicates in the same minute
  distinct(site, date, cam, flower_sp, minutes_since_9am, Family, .keep_all = TRUE) %>%
  
  #group by site, flower_sp, family and minutes since 9am
  group_by(site, date , cam, flower_sp, Family) %>%
  #count the number of images per minute per family
  summarise(count = n(), .groups = 'drop')


#final count dataframe
flower_cam_count_full <- flower_camera_modelling %>%
  #summarize the number of images per site per flower_sp
  group_by(site, date , cam, flower_sp) %>%
  summarise(count = n(), .groups = 'drop')

#plant survey data
planty <- relative_flower %>%
  dplyr::select(Site, Transect, average_flower_cover, Floral_simpson_index)%>%
  #average of Floral  simpson index per site
  group_by(Site,average_flower_cover) %>%
  summarise(Floral_simpson_index_site = mean(Floral_simpson_index), .groups = 'drop')
  

flower_cam_count_full <- envir_data %>%
  #remove data irrelevant for flower camera, such as transect, minutes since 9am, floral simpson index
  dplyr::select(-c(Transect, minutes_since_9am,Floral_simpson_index_T, Pastinaca.sativa, Daucus.carota, top2_ratio, Plot_Cover_T)) %>%
  #join the flower camera data
  left_join(flower_cam_count_full, by = c("Site"= "site","Date"= "date"))%>%
  distinct()%>%
  #join the plant survey data
  left_join(planty, by = c("Site"= "Site", "average_flower_cover"))%>%
  #scale the environmental data
  mutate(across(c(dm_wind_velocity, dm_temperature, average_flower_cover,agri,grass,snh,forest,urban,water,Days_since_start,Floral_simpson_index_site), scale))

flower_cam_count_reduced <- flower_camera_famcount_reduced %>%
  #summarize the number of images per site per flower_sp
  group_by(site, date , cam, flower_sp) %>%
  summarise(count = n(), .groups = 'drop')%>%
  #join the plant survey data
  left_join(planty, by = c("site"= "Site"))%>%
  #join environmental data
  left_join(envir_data, by = c("site"= "Site","date"= "Date", "average_flower_cover"))%>%
  #remove 
  dplyr::select(-c(Plot_Cover_T, Floral_simpson_index_T, Transect, minutes_since_9am, Pastinaca.sativa, Daucus.carota, top2_ratio, majority_class, urban, agri, snh, grass,water, forest))%>%
  #scale the environmental data
  mutate(across(c(dm_wind_velocity, dm_temperature, average_flower_cover,Days_since_start,average_flower_cover, Floral_simpson_index_site), scale))%>%
  distinct()
  
  
sum(flower_cam_count_full$count);sum(flower_cam_count_reduced$count)
sum(flower_cam_count_reduced$count)/sum(flower_cam_count_full$count)
```

flower_cam_count1$count:
W = 0.73, p-value = 3.35e-07 → Strong evidence against normality.
Very right-skewed (Skewness = 1.91) and heavy-tailed (Kurtosis = 3.17).
Wide range: from 2 to 1503, high variance (SD = 388.98).

flower_cam_count2$count:
W = 0.89, p-value = 0.00077 → Also not normal.
Still skewed (Skewness = 0.90), but much more manageable.
Lower range: 2 to 57, smaller variance (SD = 15.20).

### IV.D.1. FLOWER CAMERA FULL Count  - NB

```{r}
#histogram of the number of images per flower camera
flower_cam_count_full %>%
  ggplot(aes(x = count)) +
  geom_histogram(binwidth=0.5,fill = "lightblue", color = "black") +
  labs(title = "Histogram of Number of Images per Flower Camera",
       x = "Number of Images",
       y = "Count")

#testin normality of the number of images per flower camera
shapiro.test(flower_cam_count_full$count) # p-value = 3.35e-07, number of images per flower camera is not normally distributed
datawizard::describe_distribution(flower_cam_count_full$count)
```


Since it is a count response variable, we will use a Poisson distribution.
```{r flower_abundance_mod1_nb, fig.width=6, fig.height=6}
# full model with insect abundance as response variable and environmental, weather and plant diversity variables as explanatory variables, and site as random effect, and recording time is included to account for sampling effort differences
flower_abundance_mod1_nb <- glmmTMB(count 
                                    ~ Site_type 
                                    #+ flower_sp
                                    + average_flower_cover 
                                    + Floral_simpson_index_site 
                                    + Days_since_start  
                                    + dm_wind_velocity  
                                    + dm_temperature  
                                    + (1 | Site),
                                    family = nbinom2,
                                    data = flower_cam_count_full
                                    )
summary(flower_abundance_mod1_nb)
parameters(flower_abundance_mod1_nb)
#check for singularity
performance::check_singularity(flower_abundance_mod1_nb)
#check the model
check_model(flower_abundance_mod1_nb, verbose = T)
#overdispersion
check_overdispersion(flower_abundance_mod1_nb)
#collinearity
check_collinearity(flower_abundance_mod1_nb)
# dharma package - simulate residuals and check model assumptions
flower_abundance_mod1_nb_sim_res <- simulateResiduals(fittedModel = flower_abundance_mod1_nb)
plot(flower_abundance_mod1_nb_sim_res)

```

```{r flower_abundance_mod2_nb, fig.width=6, fig.height=6}
#remove site type (p= 0.917  for flower_abundance_mod1_nb)
flower_abundance_mod2_nb <- glmer.nb(count 
                                     #~ Site_type
                                     ~ average_flower_cover
                                     #+ flower_sp
                                     + Floral_simpson_index_site
                                     + Days_since_start
                                     + dm_wind_velocity 
                                     + dm_temperature 
                                     + (1 | Site), 
                                   #negative binomial distribution model
                                   family = nbinom2,
                                   data = flower_cam_count_full)

summary(flower_abundance_mod2_nb)
parameters(flower_abundance_mod2_nb)
#check for singularity
performance::check_singularity(flower_abundance_mod2_nb)
#check the model
check_model(flower_abundance_mod2_nb, verbose = T)
#overdispersion
check_overdispersion(flower_abundance_mod2_nb)
#collinearity
check_collinearity(flower_abundance_mod2_nb)
# dharma package - simulate residuals and check model assumptions
flower_abundance_mod2_nb_sim_res <- simulateResiduals(fittedModel = flower_abundance_mod2_nb)
plot(flower_abundance_mod2_nb_sim_res)
report(flower_abundance_mod2_nb)
```

```{r flower_abundance_mod3_nb, fig.width=6, fig.height=6}
#remove days since start (p= 0.262   for flower_abundance_mod2_nb)
flower_abundance_mod3_nb <- glmmTMB(count 
                                     #~ Site_type
                                     #+ flower_sp
                                     ~ average_flower_cover
                                     + Floral_simpson_index_site
                                     #+ Days_since_start
                                     + dm_wind_velocity 
                                     + dm_temperature 
                                     + (1 | Site), 
                                   #negative binomial distribution model
                                   family = nbinom2,
                                   data = flower_cam_count_full)

summary(flower_abundance_mod3_nb)
parameters(flower_abundance_mod3_nb)
#check for singularity
performance::check_singularity(flower_abundance_mod3_nb)
#check the model
check_model(flower_abundance_mod3_nb, verbose = T)
#overdispersion
check_overdispersion(flower_abundance_mod3_nb)
#collinearity
check_collinearity(flower_abundance_mod3_nb)
# dharma package - simulate residuals and check model assumptions
flower_abundance_mod3_nb_sim_res <- simulateResiduals(fittedModel = flower_abundance_mod3_nb)
plot(flower_abundance_mod3_nb_sim_res)


```

```{r flower_abundance_mod4_nb, fig.width=6, fig.height=6}
#remove floral simpson index (p= 0.169       for flower_abundance_mod3_nb)
flower_abundance_mod4_nb <- glmmTMB(count 
                                     #~ Site_type
                                     #+ flower_sp
                                     ~ average_flower_cover
                                     # Floral_simpson_index_site
                                     #+ Days_since_start
                                     + dm_wind_velocity 
                                     + dm_temperature 
                                     + (1 | Site), 
                                   #negative binomial distribution model
                                   family = nbinom2,
                                   data = flower_cam_count_full)
summary(flower_abundance_mod4_nb)
parameters(flower_abundance_mod4_nb)
#check for singularity
performance::check_singularity(flower_abundance_mod4_nb)
#check the model
check_model(flower_abundance_mod4_nb, verbose = T)
#overdispersion
check_overdispersion(flower_abundance_mod4_nb)
#collinearity
check_collinearity(flower_abundance_mod4_nb)
# dharma package - simulate residuals and check model assumptions
flower_abundance_mod4_nb_sim_res <- simulateResiduals(fittedModel = flower_abundance_mod4_nb)
plot(flower_abundance_mod4_nb_sim_res)

```

```{r flower_abundance_mod5_nb, fig.width=6, fig.height=6}
#remove dm temperature (p= 0.215        for flower_abundance_mod4_nb)
flower_abundance_mod5_nb <- glmmTMB(count 
                                     #~ Site_type
                                     #+ flower_sp
                                     ~ average_flower_cover
                                     #+ Floral_simpson_index_site
                                     #+ Days_since_start
                                     + dm_wind_velocity 
                                     #+ dm_temperature 
                                     + (1 | Site), 
                                   #negative binomial distribution model
                                   family = nbinom2,
                                   data = flower_cam_count_full)
summary(flower_abundance_mod5_nb)
parameters(flower_abundance_mod5_nb)
#check for singularity
performance::check_singularity(flower_abundance_mod5_nb)
#check the model
check_model(flower_abundance_mod5_nb, verbose = T)
#overdispersion
check_overdispersion(flower_abundance_mod5_nb)
#collinearity
check_collinearity(flower_abundance_mod5_nb)
# dharma package - simulate residuals and check model assumptions
flower_abundance_mod5_nb_sim_res <- simulateResiduals(fittedModel = flower_abundance_mod5_nb)
plot(flower_abundance_mod5_nb_sim_res)

```

#### IV.D.1.a. Compare the models with the performance package
```{r flower_abundance_nb_comp1}
# Compare the models with the performance package
flower_abundance_nb_comp1 <- compare_performance(flower_abundance_mod1_nb, flower_abundance_mod2_nb, flower_abundance_mod3_nb, flower_abundance_mod4_nb, flower_abundance_mod5_nb,
                                                 metrics = c("AICc", "BIC", "R2", "ICC", "RMSE"))
# Print the comparison table
print(flower_abundance_nb_comp1)
```

#### IV.D.1.b. Visualize the model results

```{r}
#plot_model(flower_abundance_mod1_nb , type = "est", show.values = TRUE, value.offset = .3)
#plot_model(flower_abundance_mod2_nb , type = "est", show.values = TRUE, value.offset = .3)

(est_flowcam <- plot_model(flower_abundance_mod5_nb, 
           type = "est", 
           show.values = TRUE, 
           value.offset = 0.3,
           #sort.est = TRUE,
           axis.labels = c(#"Temperature", 
                           "Wind Velocity (km/h)",
                           #"Days since start",
                           #"Floral Simpson Index",
                           "Average Flower Cover %"
                           )) +
    labs(title = "Flower Camera: Activity of Pollinators", x = "Predictors",y = "Estimate") + 
    theme(axis.text.y = element_text(hjust = 0)) ) # 0 = left, 1 = right

#plot_model(flower_abundance_mod3_nb , type = "est", show.values = TRUE, value.offset = .3)
#plot_model(flower_abundance_mod4_nb , type = "est", show.values = TRUE, value.offset = .3)
#plot_model(flower_abundance_mod5_nb , type = "est", show.values = TRUE, value.offset = .3)

```

```{r plot flower_abundance_mod5_nb predictions}

## wind flower_abundance_mod2_nb---------
# Get the original mean and SD of wind velocity before scaling
wind_mean <- mean(envir_data$dm_wind_velocity, na.rm = TRUE)
wind_sd <- sd(envir_data$dm_wind_velocity, na.rm = TRUE)
# Get predictions on the scaled variable
pred_wind <- ggpredict(flower_abundance_mod5_nb , terms = "dm_wind_velocity")
# Unscale the x-axis
pred_wind$x_unscaled <- (pred_wind$x * wind_sd) + wind_mean
# Plot
(wind_count_flowercam <-ggplot(pred_wind, aes(x = x_unscaled, y = predicted)) +
  #plot with predictor color
  geom_line(size = 1.2, color = predictor_colors[["dm_wind_velocity"]]) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), 
              fill = alpha(predictor_colors[["dm_wind_velocity"]], 0.5)) +
  labs(
    title = "Flower camera: Predicted Insect Abundance by Wind Velocity",
    x = "Wind Velocity (km/h)",
    y = "Predicted Insect Abundance"
  ))

## average_flower_cover flower_abundance_mod5_nb---------
#plot the predictions for the average_flower_cover, WITHOUT UNSCALING
# Get the original mean and SD of average flower cover before scaling
flower_cover_mean <- mean(planty$average_flower_cover, na.rm = TRUE)
flower_cover_sd <- sd(planty$average_flower_cover, na.rm = TRUE)
# Get predictions on the scaled variable
pred_avg_flower_cover <- ggpredict(flower_abundance_mod5_nb , terms = "average_flower_cover")
# Unscale the x-axis
pred_avg_flower_cover$x_unscaled <- (pred_avg_flower_cover$x * flower_cover_sd) + flower_cover_mean

# Plot
(avg_flowcam <- ggplot(pred_avg_flower_cover, aes(x = x_unscaled, y = predicted)) +
  #plot with predictor color
  geom_line(size = 1.2, color = predictor_colors[["average_flower_cover"]]) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), 
              fill = alpha(predictor_colors[["average_flower_cover"]], 0.5)) +
  labs(
    title = "Flower camera: Predicted Insect Activity by Average Flower Cover",
    x = "Average Flower Cover (%)",
    y = "Predicted Insect Abundance"
  ))
```

```{r}
#plot all wind_count_net, wind_count_flowercam and wind_count_platform in one plot
library(cowplot)

wind_count_net1 <- wind_count_net + theme(plot.title = element_text(size = 16))+ labs(title = "Transect walk: Predicted Interaction \nCounts by Wind Velocity") 
wind_count_flowercam1 <- wind_count_flowercam + theme(plot.title = element_text(size = 16)) +labs(title = "Flower cameras: Predicted Insect \nAbundance by Wind Velocity") 
wind_count_platform1 <- wind_count_platform + theme(plot.title = element_text(size = 16))+ labs(title = "Platform cameras: Predicted Insect \nCount by Wind Velocity") 

(cowplot::plot_grid(wind_count_net1, wind_count_flowercam1, wind_count_platform1, ncol = 3, labels = c("A", "B", "C")) +
  theme(plot.title = element_text(hjust = 0.5))+
  # font size of titles
  theme(plot.title = element_text(size = 16)))

#save the plot in figures
ggsave("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/figures/wind_velocity.png", 
       width = 14, height = 6, dpi = 600)
```


#### IV.D.1.c. Interpretation of the model results

```{r}
#remove all objects starting with flower_abundance_
rm(list = ls(pattern = "^flower_abundance_"))
```



### IV.D.2. FLOWER CAMERA FULL Richness - NB

```{r flower_richness}
#count all unique families per site
flower_richness <- flower_camera_modelling %>%
  #count unique families per site and flower_sp
  group_by(site, date , cam, flower_sp) %>%
  summarise(family_count = n_distinct(Family), .groups = 'drop') %>%
  #join the plant survey data
  left_join(planty, by = c("site"= "Site"))%>%
  #join environmental data
  left_join(envir_data, by = c("site"= "Site","date"= "Date", "average_flower_cover"))%>%
  #remove Plot_Cover_T
  dplyr::select(-c(Plot_Cover_T, Transect,minutes_since_9am,majority_class,grass, snh, forest, urban, agri, water, majority_class, Pastinaca.sativa, Daucus.carota, Floral_simpson_index_T, top2_ratio))%>%
  #scale the environmental data
  mutate(across(c(dm_wind_velocity, dm_temperature, average_flower_cover,Days_since_start,average_flower_cover, Floral_simpson_index_site), scale))%>%
  distinct()

#histogram of the number of families per flower camera
flower_richness %>%
  ggplot(aes(x = family_count)) +
  geom_histogram(binwidth=1, fill = "lightblue", color = "black") +
  labs(title = "Histogram of Number of Families per Flower Camera",
       x = "Number of Families",
       y = "Count")
  
#testing normality of the number of families per flower camera
shapiro.test(flower_richness$family_count) # p-value = 0.0007664, number of families per flower camera is not normally distributed
datawizard::describe_distribution(flower_richness$family_count)
```
negative binomial distribution

```{r flower_richness_mod1_nb, fig.width=6, fig.height=6}
# full model with insect abundance as response variable and environmental, weather and plant diversity variables as explanatory variables, and site as random effect, and recording time is included to account for sampling effort differences
flower_richness_mod1_nb <- glmmTMB(family_count 
                                    ~ average_flower_cover 
                                    + Floral_simpson_index_site 
                                    + Days_since_start  
                                    + dm_wind_velocity  
                                    + dm_temperature  
                                    + (1 | site),
                                    family = nbinom2,
                                    data = flower_richness)

summary(flower_richness_mod1_nb)
parameters(flower_richness_mod1_nb)
#check for singularity
performance::check_singularity(flower_richness_mod1_nb)
#check the model
check_model(flower_richness_mod1_nb, verbose = T)
#overdispersion
check_overdispersion(flower_richness_mod1_nb)
#collinearity
check_collinearity(flower_richness_mod1_nb)
# dharma package - simulate residuals and check model assumptions
flower_richness_mod1_nb_sim_res <- simulateResiduals(fittedModel = flower_richness_mod1_nb)
plot(flower_richness_mod1_nb_sim_res)
```

```{r flower_richness_mod2_nb, fig.width=6, fig.height=6}
#remove days since start (p= 0.134  for flower_richness_mod1_nb)
flower_richness_mod2_nb <- glmmTMB(family_count 
                                    ~ average_flower_cover 
                                    + Floral_simpson_index_site 
                                    #+ Days_since_start  
                                    + dm_wind_velocity  
                                    + dm_temperature  
                                    + (1 | site),
                                    family = nbinom2,
                                    data = flower_richness)
summary(flower_richness_mod2_nb)
parameters(flower_richness_mod2_nb)

#check the model
check_model(flower_richness_mod2_nb, verbose = T)
#overdispersion
check_overdispersion(flower_richness_mod2_nb)
#collinearity
check_collinearity(flower_richness_mod2_nb)
# dharma package - simulate residuals and check model assumptions
flower_richness_mod2_nb_sim_res <- simulateResiduals(fittedModel = flower_richness_mod2_nb)
plot(flower_richness_mod2_nb_sim_res)

```

```{r flower_richness_mod3_nb, fig.width=6, fig.height=6}
#remove dm temperature (p= 0.6742      for flower_richness_mod2_nb)
flower_richness_mod3_nb <- glmmTMB(family_count 
                                    ~ average_flower_cover 
                                    + Floral_simpson_index_site 
                                    #+ Days_since_start  
                                    + dm_wind_velocity  
                                    #+ dm_temperature  
                                    + (1 | site),
                                    family = nbinom2,
                                    data = flower_richness)

summary(flower_richness_mod3_nb)
parameters(flower_richness_mod3_nb)
#check the model
check_model(flower_richness_mod3_nb, verbose = T)
#overdispersion
check_overdispersion(flower_richness_mod3_nb)
#collinearity
check_collinearity(flower_richness_mod3_nb)
# dharma package - simulate residuals and check model assumptions
flower_richness_mod3_nb_sim_res <- simulateResiduals(fittedModel = flower_richness_mod3_nb)
plot(flower_richness_mod3_nb_sim_res)

```

```{r flower_richness_mod4_nb, fig.width=6, fig.height=6}
#remove wind velocity (p= 0.386   for flower_richness_mod3_nb)
flower_richness_mod4_nb <- glmmTMB(family_count 
                                    ~ average_flower_cover 
                                    + Floral_simpson_index_site 
                                    #+ Days_since_start  
                                    #+ dm_wind_velocity  
                                    #+ dm_temperature  
                                    + (1 | site),
                                    family = nbinom2,
                                    data = flower_richness)
summary(flower_richness_mod4_nb)
parameters(flower_richness_mod4_nb)
#check the model
check_model(flower_richness_mod4_nb, verbose = T)
#overdispersion
check_overdispersion(flower_richness_mod4_nb)
#collinearity
check_collinearity(flower_richness_mod4_nb)
# dharma package - simulate residuals and check model assumptions
flower_richness_mod4_nb_sim_res <- simulateResiduals(fittedModel = flower_richness_mod4_nb)
plot(flower_richness_mod4_nb_sim_res)

```

```{r flower_richness_mod5_nb, fig.width=6, fig.height=6}
#remove floral simpson index (p= 0.169       for flower_richness_mod4_nb)
flower_richness_mod5_nb <- glmmTMB(family_count 
                                    ~ average_flower_cover 
                                    # Floral_simpson_index_site 
                                    #+ Days_since_start  
                                    #+ dm_wind_velocity  
                                    #+ dm_temperature  
                                    + (1 | site),
                                    family = nbinom2,
                                    data = flower_richness)
summary(flower_richness_mod5_nb)
parameters(flower_richness_mod5_nb)
#check the model
check_model(flower_richness_mod5_nb, verbose = T)
#overdispersion
check_overdispersion(flower_richness_mod5_nb)
#collinearity
check_collinearity(flower_richness_mod5_nb)
# dharma package - simulate residuals and check model assumptions
flower_richness_mod5_nb_sim_res <- simulateResiduals(fittedModel = flower_richness_mod5_nb)
plot(flower_richness_mod5_nb_sim_res)
report(flower_richness_mod5_nb)
```

#### IV.D.2.a. Compare the models with the performance package
```{r flower_richness_nb_comp1}
# Compare the models with the performance package
flower_richness_nb_comp1 <- compare_performance(flower_richness_mod1_nb, flower_richness_mod2_nb, flower_richness_mod3_nb, flower_richness_mod4_nb, flower_richness_mod5_nb,
                                                 metrics = c("AICc", "BIC", "R2", "ICC", "RMSE"))
# Print the comparison table
print(flower_richness_nb_comp1)
```

#### IV.D.2.b. Visualize the model results
```{r}
plot_model(flower_richness_mod1_nb , type = "est", show.values = TRUE, value.offset = .3)


plot_model(flower_richness_mod2_nb , type = "est", show.values = TRUE, value.offset = .3)
plot_model(flower_richness_mod3_nb , type = "est", show.values = TRUE, value.offset = .3)
plot_model(flower_richness_mod4_nb , type = "est", show.values = TRUE, value.offset = .3)
plot_model(flower_richness_mod5_nb , type = "est", show.values = TRUE, value.offset = .3)

plot_model(flower_richness_mod1_nb, 
           type = "est", 
           show.values = TRUE, 
           value.offset = 0.3,
           #sort.est = TRUE,
           axis.labels = c(
             "Temperature",
             "Wind Velocity (km/h)",
             "Days since start",
             "Floral Simpson Index",
             "Average Flower Cover %" )) +
    labs(title = "Flower Camera: Richness of Pollinators", x = "Predictors",y = "Estimate") + 
    theme(axis.text.y = element_text(hjust = 0))  # 0 = left, 1 = right

```

```{r plot flower_richness_mod5_nb predictions}
## average flower cover flower_richness_mod5_nb---------
# get the original mean and SD of average flower cover before scaling
average_flower_cover_mean <- mean(planty$average_flower_cover, na.rm = TRUE)
average_flower_cover_sd <- sd(planty$average_flower_cover, na.rm = TRUE)
# Get predictions on the scaled variable
pred_avg_flower_cover <- ggpredict(flower_richness_mod5_nb , terms = "average_flower_cover")
# Unscale the x-axis
pred_avg_flower_cover$x_unscaled <- (pred_avg_flower_cover$x * average_flower_cover_sd) + average_flower_cover_mean

# Plot
(avg_flowcam_rich <- ggplot(pred_avg_flower_cover, aes(x = x_unscaled, y = predicted)) +
  #plot with predictor color
  geom_line(size = 1.2, color = predictor_colors[["average_flower_cover"]]) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), 
              fill = alpha(predictor_colors[["average_flower_cover"]], 0.5)) +
  labs(
    title = "Flower camera: Predicted Insect Richness by Average Flower Cover",
    x = "Average Flower Cover (%)",
    y = "Predicted Insect Richness"
  ))

```

```{r}
#plot est_flowcam avg_flowcam avg_flowcam_rich together
library(cowplot)
#est_flowcam1 <- est_flowcam + theme(plot.title = element_text(size = 16))+ labs(title = "Predicted Insect Activity")
avg_flowcam1 <- avg_flowcam + theme(plot.title = element_text(size = 14))+ labs(title = "Predicted Insect Activity by Average Flower Cover")
avg_flowcam_rich1 <- avg_flowcam_rich + theme(plot.title = element_text(size = 14))+ labs(title = "Predicted Insect Richness by Average Flower Cover")

#combine plots
(combi <- cowplot::plot_grid(
  #est_flowcam1, 
  avg_flowcam1, 
  avg_flowcam_rich1, 
  ncol = 2, labels = c("A", "B", "C"), 
  #change width
  rel_widths = c(1, 1, 1)))

#add main title to combi
(final_plot <- cowplot::plot_grid(
  ggdraw() + draw_label(
    "Flower camera: Predicted Insect Activity and Richness", 
    fontface = 'bold', size = 16, x = 0.5, hjust = 0.5
  ),
  combi,
  ncol = 1,
  rel_heights = c(0.1, 1)  # Title height vs. plots height
))



#save the plot in figures
ggsave("C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/figures/flower_cam_abundance_richness.png",plot= final_plot,
       width = 14, height = 6, dpi = 600)
```



#### IV.D.2.c. Interpretation of the model results

```{r}
#remove all objects starting with flower_richness_
rm(list = ls(pattern = "^flower_richness_"))
```

### IV.D.3. FLOWER CAMERA FULL Shannon index - Gaussian distribution

```{r flower_cam_diversity}
#transform flower_camera_modelling into wide format to use vegan package to get the shannon and simpson index
flower_cam_diversity <- flower_camera_modelling%>%
  #create new column with counts = 1
  mutate(count = 1) %>%
  #wide format filled with counts, fill empty cells with 0
  pivot_wider(names_from = Family, values_from = count, values_fill = 0)%>%
  #combine rows that have the same site, flower and camera
  group_by(site, date , cam, flower_sp) %>%
  #sum the counts for each family
  summarise(across(Apidae:Chrysididae, sum), .groups = 'drop') %>%
  #calculate shannon index and simpson index
  mutate(shannon_diversity = diversity(across(Apidae:Chrysididae), index = "shannon"),
         simpson_diversity = diversity(across(Apidae:Chrysididae), index = "simpson"))%>%
  #keep only site, date, cam, flower_sp, shannon_diversity, simpson_diversity
 dplyr::select(site, date , cam, flower_sp, shannon_diversity, simpson_diversity)%>%
  #join the plant survey data
  left_join(planty, by = c("site"= "Site"))%>%
  #join environmental data
  left_join(envir_data, by = c("site"= "Site","date"= "Date", "average_flower_cover"))%>%
  #remove Plot_Cover_T, majority_class, grass, snh, forest, urban, agri, water, majority_class, Pastinaca.sativa, Daucus.carota, Floral_simpson_index_T, top2_ratio
 dplyr::select(-c(Plot_Cover_T, Transect, majority_class, grass, snh, forest, urban, agri, water, Pastinaca.sativa, Daucus.carota, Floral_simpson_index_T, top2_ratio, minutes_since_9am))  %>%
  #scale the environmental data
  mutate(across(c(dm_wind_velocity, dm_temperature, average_flower_cover,Days_since_start,average_flower_cover, Floral_simpson_index_site), scale))%>%
  #remove duplicates
  distinct()
```

```{r}
#histogram of the shannon index
flower_cam_diversity %>%
  ggplot(aes(x = shannon_diversity)) +
  geom_histogram(binwidth=0.1, fill = "lightblue", color = "black") +
  labs(title = "Histogram of Shannon Diversity Index per Flower Camera",
       x = "Shannon Diversity Index",
       y = "Count")

#testing normality of the shannon index
shapiro.test(flower_cam_diversity$shannon_diversity) # p-value = 0.3392, shannon index is normally distributed
datawizard::describe_distribution(flower_cam_diversity$shannon_diversity)
```

Since the shannon index is normally distributed, we can use a linear model. 

```{r flower_cam_diversity_mod1_gauss, fig.width=6, fig.height=6}
# full model with insect SHANNON INDEX as response variable and environmental, weather and plant diversity variables as explanatory variables, and site as random effect
# linear model
flower_cam_diversity_mod1_gauss <- lmer(shannon_diversity 
                                         ~ average_flower_cover 
                                         + Floral_simpson_index_site 
                                         + Days_since_start  
                                         + dm_wind_velocity  
                                         + dm_temperature  
                                         + (1 | site),
                                       data = flower_cam_diversity)

summary(flower_cam_diversity_mod1_gauss)
parameters(flower_cam_diversity_mod1_gauss)
#check the model
check_model(flower_cam_diversity_mod1_gauss, verbose = T)
  
#overdispersion
check_overdispersion(flower_cam_diversity_mod1_gauss)
#collinearity
check_collinearity(flower_cam_diversity_mod1_gauss)
# dharma package - simulate residuals and check model assumptions
flower_cam_diversity_mod1_gauss_sim_res <- simulateResiduals(fittedModel = flower_cam_diversity_mod1_gauss)
plot(flower_cam_diversity_mod1_gauss_sim_res)


```

```{r flower_cam_diversity_mod2_gauss, fig.width=6, fig.height=6}
#remove dm temperature (p= 0.857       for flower_cam_diversity_mod1_gauss)
flower_cam_diversity_mod2_gauss <- lmer(shannon_diversity 
                                         ~ average_flower_cover 
                                         + Floral_simpson_index_site 
                                         + Days_since_start  
                                         + dm_wind_velocity  
                                         #+ dm_temperature  
                                         + (1 | site),
                                       data = flower_cam_diversity)
summary(flower_cam_diversity_mod2_gauss)
parameters(flower_cam_diversity_mod2_gauss)
#check the model
check_model(flower_cam_diversity_mod2_gauss, verbose = T)
#overdispersion
check_overdispersion(flower_cam_diversity_mod2_gauss)
#collinearity
check_collinearity(flower_cam_diversity_mod2_gauss)
# dharma package - simulate residuals and check model assumptions
flower_cam_diversity_mod2_gauss_sim_res <- simulateResiduals(fittedModel = flower_cam_diversity_mod2_gauss)
plot(flower_cam_diversity_mod2_gauss_sim_res)

```

```{r flower_cam_diversity_mod3_gauss, fig.width=6, fig.height=6}
#remove days since start (p= 0.522    for flower_cam_diversity_mod2_gauss)
flower_cam_diversity_mod3_gauss <- lmer(shannon_diversity 
                                         ~ average_flower_cover 
                                         + Floral_simpson_index_site 
                                         #+ Days_since_start  
                                         + dm_wind_velocity  
                                         #+ dm_temperature  
                                         + (1 | site),
                                       data = flower_cam_diversity)
summary(flower_cam_diversity_mod3_gauss)
parameters(flower_cam_diversity_mod3_gauss)
#check the model
check_model(flower_cam_diversity_mod3_gauss, verbose = T)
#overdispersion
check_overdispersion(flower_cam_diversity_mod3_gauss)
#collinearity
check_collinearity(flower_cam_diversity_mod3_gauss)
# dharma package - simulate residuals and check model assumptions
flower_cam_diversity_mod3_gauss_sim_res <- simulateResiduals(fittedModel = flower_cam_diversity_mod3_gauss)
plot(flower_cam_diversity_mod3_gauss_sim_res)

```

```{r flower_cam_diversity_mod4_gauss, fig.width=6, fig.height=6}
#remove dm wind velocity (p= 0.355        for flower_cam_diversity_mod3_gauss)
flower_cam_diversity_mod4_gauss <- lmer(shannon_diversity 
                                         ~ average_flower_cover 
                                         + Floral_simpson_index_site 
                                         #+ Days_since_start  
                                         #+ dm_wind_velocity  
                                         #+ dm_temperature  
                                         + (1 | site),
                                       data = flower_cam_diversity)
summary(flower_cam_diversity_mod4_gauss)
parameters(flower_cam_diversity_mod4_gauss)
#check the model
check_model(flower_cam_diversity_mod4_gauss, verbose = T)
#overdispersion
check_overdispersion(flower_cam_diversity_mod4_gauss)
#collinearity
check_collinearity(flower_cam_diversity_mod4_gauss)
# dharma package - simulate residuals and check model assumptions
flower_cam_diversity_mod4_gauss_sim_res <- simulateResiduals(fittedModel = flower_cam_diversity_mod4_gauss)
plot(flower_cam_diversity_mod4_gauss_sim_res)

```

```{r flower_cam_diversity_mod5_gauss, fig.width=6, fig.height=6}
#remove average flower cover (p= 0.321        for flower_cam_diversity_mod4_gauss)
flower_cam_diversity_mod5_gauss <- lmer(shannon_diversity 
                                         #~ average_flower_cover 
                                         ~ Floral_simpson_index_site 
                                         #+ Days_since_start  
                                         #+ dm_wind_velocity  
                                         #+ dm_temperature  
                                         + (1 | site),
                                       data = flower_cam_diversity)
summary(flower_cam_diversity_mod5_gauss)
parameters(flower_cam_diversity_mod5_gauss)
#check the model
check_model(flower_cam_diversity_mod5_gauss, verbose = T)
#overdispersion
check_overdispersion(flower_cam_diversity_mod5_gauss)
#collinearity
check_collinearity(flower_cam_diversity_mod5_gauss)

# dharma package - simulate residuals and check model assumptions`
flower_cam_diversity_mod5_gauss_sim_res <- simulateResiduals(fittedModel = flower_cam_diversity_mod5_gauss)
plot(flower_cam_diversity_mod5_gauss_sim_res)
```

#### IV.D.3.a. Compare the models with the performance package
```{r flower_cam_diversity_gauss_comp1}
# Compare the models with the performance package
flower_cam_diversity_gauss_comp1 <- compare_performance(flower_cam_diversity_mod1_gauss, flower_cam_diversity_mod2_gauss, flower_cam_diversity_mod3_gauss, flower_cam_diversity_mod4_gauss, flower_cam_diversity_mod5_gauss,
                                                 metrics = c("AICc", "BIC", "R2", "ICC", "RMSE"))
# Print the comparison table
print(flower_cam_diversity_gauss_comp1)
```

#### IV.D.3.b. Visualize the model results

```{r}
#plot_model(flower_cam_diversity_mod1_gauss , type = "est", show.values = TRUE, value.offset = .3)
#plot_model(flower_cam_diversity_mod2_gauss , type = "est", show.values = TRUE, value.offset = .3)
#plot_model(flower_cam_diversity_mod3_gauss , type = "est", show.values = TRUE, value.offset = .3)
#plot_model(flower_cam_diversity_mod4_gauss , type = "est", show.values = TRUE, value.offset = .3)
plot_model(flower_cam_diversity_mod5_gauss , type = "est", show.values = TRUE, value.offset = .3)

plot_model(flower_cam_diversity_mod1_gauss, 
           type = "est", 
           show.values = TRUE, 
           value.offset = 0.3,
           #sort.est = TRUE,
           axis.labels = c(
             "Temperature",
             "Wind Velocity (km/h)",
             "Days since start",
             "Floral Simpson Index",
             "Average Flower Cover %" )) +
    labs(title = "Flower Camera: Shannon Diversity Index", x = "Predictors",y = "Estimate") + 
    theme(axis.text.y = element_text(hjust = 0))  # 0 = left, 1 = right
```

No predictor seems to significantly affect the shannon index captured by flower cameras. 

#### IV.D.3.c. Interpretation of the model results


### IV.D.4. FLOWER CAMERA FULL Simpson index - Beta regression

```{r flower_cam_simpson}
# histogram of the simpson index
flower_cam_diversity %>%
  ggplot(aes(x = simpson_diversity)) +
  geom_histogram( fill = "lightblue", color = "black") +
  labs(title = "Histogram of Simpson Diversity Index per Flower Camera",
       x = "Simpson Diversity Index",
       y = "Count")


#testing normality of the simpson index
shapiro.test(flower_cam_diversity$simpson_diversity) # p-value = 0.07352, simpson index is normally distributed
datawizard::describe_distribution(flower_cam_diversity$simpson_diversity)
summary(flower_cam_diversity$simpson_diversity)
```

Like all the other simpson indices, the simpson index score is found between 0 and 1. Here, with a mean of 0.55 and a sd of 0.23.
We will proceed with a beta regression model. 

```{r flower_cam_diversity_simpson_mod1_beta, fig.width=6, fig.height=6}
# full model with insect SIMPSON INDEX as response variable and environmental, weather and plant diversity variables as explanatory variables, and site as random effect
# beta regression model
flower_cam_diversity_simpson_mod1_beta <- glmmTMB(simpson_diversity 
                                         ~ average_flower_cover 
                                         + Floral_simpson_index_site 
                                         + Days_since_start  
                                         + dm_wind_velocity  
                                         + dm_temperature  
                                         + (1 | site),
                                       data = flower_cam_diversity, 
                                       family = beta_family())
summary(flower_cam_diversity_simpson_mod1_beta)
parameters(flower_cam_diversity_simpson_mod1_beta)
#check the model
check_model(flower_cam_diversity_simpson_mod1_beta, verbose = T)
#overdispersion
check_overdispersion(flower_cam_diversity_simpson_mod1_beta)
#collinearity
check_collinearity(flower_cam_diversity_simpson_mod1_beta)
# dharma package - simulate residuals and check model assumptions
flower_cam_diversity_simpson_mod1_beta_sim_res <- simulateResiduals(fittedModel = flower_cam_diversity_simpson_mod1_beta)
plot(flower_cam_diversity_simpson_mod1_beta_sim_res)
```

```{r flower_cam_diversity_simpson_mod2_beta, fig.width=6, fig.height=6}
#remove dm temperature (p= 0.940        for flower_cam_diversity_simpson_mod1_beta)
flower_cam_diversity_simpson_mod2_beta <- glmmTMB(simpson_diversity 
                                         ~ average_flower_cover 
                                         + Floral_simpson_index_site 
                                         + Days_since_start  
                                         + dm_wind_velocity  
                                         #+ dm_temperature  
                                         + (1 | site),
                                       data = flower_cam_diversity, 
                                       family = beta_family())
summary(flower_cam_diversity_simpson_mod2_beta)
parameters(flower_cam_diversity_simpson_mod2_beta)
#check the model
check_model(flower_cam_diversity_simpson_mod2_beta, verbose = T)
#check for singularity
performance::check_singularity(flower_cam_diversity_simpson_mod2_beta)
#overdispersion
check_overdispersion(flower_cam_diversity_simpson_mod2_beta)
#collinearity
check_collinearity(flower_cam_diversity_simpson_mod2_beta)
# dharma package - simulate residuals and check model assumptions
flower_cam_diversity_simpson_mod2_beta_sim_res <- simulateResiduals(fittedModel = flower_cam_diversity_simpson_mod2_beta)
plot(flower_cam_diversity_simpson_mod2_beta_sim_res)

```

```{r flower_cam_diversity_simpson_mod3_beta, fig.width=6, fig.height=6}
#remove days since start (p= 0.397     for flower_cam_diversity_simpson_mod2_beta)
flower_cam_diversity_simpson_mod3_beta <- glmmTMB(simpson_diversity 
                                         ~ average_flower_cover 
                                         + Floral_simpson_index_site 
                                         #+ Days_since_start  
                                         + dm_wind_velocity  
                                         #+ dm_temperature  
                                         + (1 | site),
                                       data = flower_cam_diversity, 
                                       family = beta_family())
summary(flower_cam_diversity_simpson_mod3_beta)
parameters(flower_cam_diversity_simpson_mod3_beta)
#check the model
check_model(flower_cam_diversity_simpson_mod3_beta, verbose = T)
#overdispersion
check_overdispersion(flower_cam_diversity_simpson_mod3_beta)
#collinearity
check_collinearity(flower_cam_diversity_simpson_mod3_beta)
# dharma package - simulate residuals and check model assumptions
flower_cam_diversity_simpson_mod3_beta_sim_res <- simulateResiduals(fittedModel = flower_cam_diversity_simpson_mod3_beta)
plot(flower_cam_diversity_simpson_mod3_beta_sim_res)

```


```{r flower_cam_diversity_simpson_mod4_beta, fig.width=6, fig.height=6}
#remove average flower cover (p= 0.205         for flower_cam_diversity_simpson_mod3_beta)
flower_cam_diversity_simpson_mod4_beta <- glmmTMB(simpson_diversity 
                                         #~ average_flower_cover 
                                         ~ Floral_simpson_index_site 
                                         #+ Days_since_start  
                                         + dm_wind_velocity  
                                         #+ dm_temperature  
                                         + (1 | site),
                                       data = flower_cam_diversity, 
                                       family = beta_family())
summary(flower_cam_diversity_simpson_mod4_beta)
parameters(flower_cam_diversity_simpson_mod4_beta)
#check the model
check_model(flower_cam_diversity_simpson_mod4_beta, verbose = T)
#overdispersion
check_overdispersion(flower_cam_diversity_simpson_mod4_beta)
#collinearity
check_collinearity(flower_cam_diversity_simpson_mod4_beta)
# dharma package - simulate residuals and check model assumptions
flower_cam_diversity_simpson_mod4_beta_sim_res <- simulateResiduals(fittedModel = flower_cam_diversity_simpson_mod4_beta)
plot(flower_cam_diversity_simpson_mod4_beta_sim_res)
```

```{r flower_cam_diversity_simpson_mod5_beta, fig.width=6, fig.height=6}
#remove dm wind (p= 0.169       for flower_cam_diversity_simpson_mod4_beta)
flower_cam_diversity_simpson_mod5_beta <- glmmTMB(simpson_diversity 
                                         #~ average_flower_cover 
                                        ~ Floral_simpson_index_site 
                                         #+ Days_since_start  
                                         #+ dm_wind_velocity  
                                         #+ dm_temperature  
                                         + (1 | site),
                                       data = flower_cam_diversity, 
                                       family = beta_family(link = "logit"))
summary(flower_cam_diversity_simpson_mod5_beta)
parameters(flower_cam_diversity_simpson_mod5_beta)
#check the model
check_model(flower_cam_diversity_simpson_mod5_beta, verbose = T)
#overdispersion
check_overdispersion(flower_cam_diversity_simpson_mod5_beta)
#collinearity
check_collinearity(flower_cam_diversity_simpson_mod5_beta)
# dharma package - simulate residuals and check model assumptions
flower_cam_diversity_simpson_mod5_beta_sim_res <- simulateResiduals(fittedModel = flower_cam_diversity_simpson_mod5_beta)
plot(flower_cam_diversity_simpson_mod5_beta_sim_res)
```


#### IV.D.4.a. Compare the models with the performance package
```{r flower_cam_diversity_simpson_comp1}
# Compare the models with the performance package
flower_cam_diversity_simpson_comp1 <- compare_performance(flower_cam_diversity_simpson_mod1_beta, flower_cam_diversity_simpson_mod2_beta, flower_cam_diversity_simpson_mod3_beta, flower_cam_diversity_simpson_mod4_beta, flower_cam_diversity_simpson_mod5_beta,
                                                 metrics = c("AICc", "BIC", "R2", "ICC", "RMSE"))
# Print the comparison table
print(flower_cam_diversity_simpson_comp1)
```

#### IV.D.4.b. Visualize the model results

```{r}
plot_model(flower_cam_diversity_simpson_mod1_beta , type = "est", show.values = TRUE, value.offset = .3)
plot_model(flower_cam_diversity_simpson_mod2_beta , type = "est", show.values = TRUE, value.offset = .3)
plot_model(flower_cam_diversity_simpson_mod3_beta , type = "est", show.values = TRUE, value.offset = .3)
plot_model(flower_cam_diversity_simpson_mod4_beta , type = "est", show.values = TRUE, value.offset = .3)
plot_model(flower_cam_diversity_simpson_mod5_beta , type = "est", show.values = TRUE, value.offset = .3)

plot_model(flower_cam_diversity_simpson_mod1_beta, 
           type = "est", 
           show.values = TRUE, 
           value.offset = 0.3,
           #sort.est = TRUE,
           axis.labels = c(
             "Temperature",
             "Wind Velocity (km/h)",
             "Days since start",
             "Floral Simpson Index",
             "Average Flower Cover %" )) +
    labs(title = "Flower Camera: Simpson Diversity Index", x = "Predictors",y = "Estimate") + 
    theme(axis.text.y = element_text(hjust = 0))  # 0 = left, 1 = right


```

#### IV.D.4.c. Interpretation of the model results

```{r}
#remove all objects starting with flower_cam_diversity_
rm(list = ls(pattern = "^flower_cam_diversity_"))
```


### Citations

```{r}
# Get attached packages
attached_pkgs <- sessionInfo()$otherPkgs

# Extract package names
pkg_names <- names(attached_pkgs)
print(pkg_names)
```

```{r}
# Get citations
pkg_citations <- lapply(pkg_names, function(pkg) {
  tryCatch(toBibtex(citation(pkg)), error = function(e) NULL)
})

# Combine and print
cat(unlist(pkg_citations), sep = "\n\n")

# Write to a .bib file here "C:\Users\Almas\Desktop\UNI_LEIPSI\Thesis\Thesis_Rproject\data"
writeLines(unlist(pkg_citations), "C:/Users/Almas/Desktop/UNI_LEIPSI/Thesis/Thesis_Rproject/data/r_packages.bib")

```

